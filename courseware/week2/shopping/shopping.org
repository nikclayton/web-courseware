#+Title: Powercoders Basel Coursework, DOM Shopping List Exercise
#+SETUPFILE: "../../include/settings.org"

* TODO Building a shopping list

#+BEGIN_NOTES
So far everything that we've been learning has been a bit abstract.

That's OK, but it's time to put the pieces together and start
building something more concrete, where we can see definite
progress towards an end-goal.

So we're going to build a web based shopping list, bit by bit.

Along the way we'll discover new things that we need to learn,
and incorporate that in to what we build.
#+END_NOTES

* TODO Features

- Box to enter an item
- Button to add the item to a list
- The list itself
- Each list item has a button to delete the item

#+BEGIN_NOTES
To start with, our app is going to be very simple.

It's going to need a box where the user can type in the name of
the item they want to add to the list. Add a button that the
user can click in order to add the thing to the list.

It's going to need to be able to show the list of things the user
has entered.

And each list item is going to need a button that allows the user
to delete the thing from the list.

At the moment we're not going to worry too much about how it
looks, so we're going to keep styling to a minimum. We want to
get the core functionality working properly first.
#+END_NOTES

* TODO Goal

#+BEGIN_CENTER
[[file:initial-wireframe.png]]
#+END_CENTER

#+BEGIN_NOTES
I used a sketch tool to throw together a quick wireframe of what
the app would look like initially, to make it a bit more concrete.

This is a very common approach -- the UI designer might come to you
with some sketches of different ideas, asking how difficult it is to
build their idea.

[Wireframe is: https://wireframe.cc/Lfqgye]
#+END_NOTES
* TODO What do / don't we know?

#+REVEAL_HTML: <div class="leftcol">
- We know
  - Paragraphs, lists
  - Listening for clicks
  - Adding DOM nodes
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here's the things we've already covered. From that little demo,
who can tell me things we're going to need to learn?
#+END_NOTES

* TODO What do / don't we know?

#+REVEAL_HTML: <div class="leftcol">
- We know
  - Paragraphs, lists
  - Listening for clicks
  - Adding DOM nodes
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- We don't know
  - Input boxes
  - Buttons
  - Removing DOM nodes
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
I think we're going to need to figure out

- input boxes
- buttons
- removing DOM nodes (so we can delete items from the list)

Everything else is stuff we've already done.
#+END_NOTES

* TODO Set up

- Create a =poco/shopping= directory
- Create =index.html=
  - Heading "My shopping list"
  - Empty unordered list
- Link to empty =style.css= and =shopping.js= files

#+BEGIN_NOTES
We'll set up the infrastructure for our project.

Create a new directory in your =poco= directory called =shopping=.

In there, create an =index.html= file. It should have a level 1 heading
with the text =My shopping list=, and an empty unordered list -- the =ul=
element should be there, but it shouldn't have an listitems.

Make sure this HTML file links to two empty files, =style.css= and
=shopping.hs=.
#+END_NOTES

* TODO Set up HTML

#+INCLUDE: "shopping-1.html" src html

#+BEGIN_NOTES
Put this text in your HTML file, and make sure it works.

There's nothing special about this -- it's just a skeleton file
that contains all the normal structure for an HTML page.

I've added comments that indicate where the things we're going
to need to learn are going to go, and we'll fill these in through
the class.

Add all of these files to your repository and make a commit
with a sensible commit message.

[Wait]
#+END_NOTES

* TODO Input boxes

- MDN documentation: [[[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/text][mdn html input type=text]]]
- Questions:
  - What element name and attributes should we use?
  - What property contains the typed in value?
  - How do you set a placeholder value?
  - What is the =label= element used for?

#+BEGIN_NOTES
We're going to start by focusing on the UI things that we don't know.

To do that, I want you to look at the Mozilla Developer Network
pages for =html input= element. Specifically, the one where the
=type= attribute is set to =text=.

Have a read through that page and keep these questions in mind as
you're reading, as I'll be asking questions in about 10 minutes...

[Wait]
#+END_NOTES

** Answers

*** What element name should be used?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: input-example
#+BEGIN_SRC html-chrome
<input type="text">
#+END_SRC

- The =input= element
- Specialised based on =type= attribute
  - =text=, =color=, =password=, ...
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[s7c0c47a9b351fbd177ba3deda8826d7d3733ff60]: input-example
[[file:input-example.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We use the =input= element, generally, to get input from the
user.

This element has a =type= attribute that is used to say exactly
what form the input should take. When we want to get a line of
text we set the =type= attribute to =text=, but there are others.

For example, if we set =type= to password then the text the user
typed in would automatically be hidden.
#+END_NOTES

*** What property contains the typed in value?

#+BEGIN_SRC html
<input type="text" id="an-input">
#+END_SRC

#+BEGIN_SRC javascript
let el = document.getElementById("an-input");
el.value;
#+END_SRC

#+BEGIN_NOTES
The =input= element has a property called =value=. This property
contains whatever text is in the element.
#+END_NOTES

*** How do you set a placeholder value?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: input-placeholder-example
#+BEGIN_SRC html-chrome
<input type="text" placeholder="Enter item">
#+END_SRC

- Use the =placeholder= attribute
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[d9899abd0468e79cd8a8a2d7e572f08d27a398eb]: input-placeholder-example
[[file:input-placeholder-example.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Simply enough -- there is a =placeholder= attribute. It's
value is used as the text to display in the input box if
the user hasn't entered anything.
#+END_NOTES

*** What is the =label= element used for?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: input-label-example
#+BEGIN_SRC html-chrome
<label for="item">Enter a new item:</label>
<input type="text" id="item" placeholder="Enter item">
#+END_SRC

- Associates a caption with the input
  - Clicking the label selects the input
  - Screenreaders and accessibility
- =label= =for= attribute points to =input= =id= attribute
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[51c3c50c098813ac2911a013d14aebcc6fb504ab]: input-label-example
[[file:input-label-example.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
The =label= element lets us associated a label with this specific
input element.

We could have used a =p=, but the =label= has a special attribute
that allows us to say exactly which input element the label is for.

If our input element has an =id= attribute, we set the label's
=for= attribute to the same value. Now, if the user clicks the
label the cursor will move in to the input element. And if they
have accessibility issues -- maybe they're using a screenreader --
then their tools will be able do a better job.
#+END_NOTES

** Add =label= and =input= elements

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "shopping-2.html" :lines "12-18" src html -n 11

- Edit =index.html=
- Add these elements to the page
- Don't forget to add and commit
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :exports results
    <div>
      <label for="item">Enter a new item:</label>
      <input type="text" id="item" placeholder="Type something to buy">
    </div>
#+END_SRC

#+RESULTS:
[[file:add-label-and-input-elements.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
So, now that we know all of that you can go ahead and add these
elements to your page. Here's the HTML to use, just as a
reminder.

When it's working don't forget to add and commit the change.
#+END_NOTES
** Checking that we can read the value                             :exercise:

- Type something in the box

#+BEGIN_SRC javascript
let el = document.getElementById('item');
el.value;
#+END_SRC

- Do you see what you typed?

#+BEGIN_NOTES
We already saw that the input widget has a =value= property that
contains whatever is entered in to the box.

We're going to need this information later.

So lets make sure that our understanding is correct.

Load the page in your browser, and open the developer tools.

Then type something -- it doesn't matter what -- in to input
box.

Then, in the console, type this Javascript. All this does is
find the =input= element in the page and display its =value=
property.

If everything's working then you should see what you typed in
to the box in the console.

[Wait]
#+END_NOTES
** Can we write the value?                                         :exercise:

#+BEGIN_SRC javascript
el.value = 'hello';  // <-- What happens?
#+END_SRC

#+BEGIN_NOTES
Try this out in the console. What happens?

[Wait]

That's cool -- we can change the value in the box by writing
to the property.

This is just like changing the value of the =className= property
to change the =class= attribute value that we did earlier.
#+END_NOTES

* TODO Buttons                                                     :exercise:

- MDN documentation: [[[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button][mdn html button]]]
- Questions:
   - What element name and attributes should we use?
   - Can we make buttons look pretty?

#+BEGIN_NOTES
Now we know how to provide somewhere for the user to enter
information we need to give them a button that they can click
which will add the entered item to the shopping list.

Again, I want you to look at the MDN pages for buttons. Do that
search, and read the page keeping these questions in mind. I'll
be asking questions again in about 10 minutes...

[Wait]
#+END_NOTES

** Answers

*** What element name should be used?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: button-example
#+BEGIN_SRC html-chrome
<button>Click me!</button>
#+END_SRC

- The =button= element
- At the moment we don't need attributes
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[16d52427a726393a450c01eb6c3f4dab10dcc94f]: button-example
[[file:button-example.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Creating buttons is pretty easy. We just use the =button= element,
without any special attributes.

The content of the element becomes the text shown on the button.
#+END_NOTES

*** Can we make the buttons look pretty?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: button-style-example
#+BEGIN_SRC html-chrome
<button
  style="
    border: 0;
    line-height: 2.5;
    padding: 0 20px;
    font-size: 1rem;
    text-align: center;
    color: #fff;
    text-shadow: 1px 1px 1px #000;
    border-radius: 10px;
    background-color: rgba(220, 0, 0, 1);
    background-image: linear-gradient(to top left,
                                      rgba(0, 0, 0, .2),
                                      rgba(0, 0, 0, .2) 30%,
                                      rgba(0, 0, 0, 0));
    box-shadow: inset 2px 2px 3px rgba(255, 255, 255, .6),
                inset -2px -2px 3px rgba(0, 0, 0, .6);
    text-shadow: 1px 1px 1px #000;">Click me!</button>
#+END_SRC

- =style= attribute is only for demo purposes, do not do this
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[fa4fa39c37eb9a955e44abfb77dc0627fad23741]: button-style-example
[[file:button-style-example.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Yes we can. There are lots of opportunities for styling buttons.

This is a somewhat extreme example.
#+END_NOTES

** Add a =button= element to your page                             :exercise:

- Add a =button= element after the =input= element
  - Inside the =div=
- Make sure it shows up
- Add and commit

#+BEGIN_NOTES
So lets add that =button= element to the page. Place it after
the =input= element, and inside the =div=.

The text on the button can be anything you want.

Once you've done that and it's showing up, add and commit.

[Wait]
#+END_NOTES

*** Solution: Add a =button= element

  #+REVEAL_HTML: <div class="leftcol">
  #+INCLUDE: "shopping-3.html" :lines "11-19" src html -n 11
  #+REVEAL_HTML: </div>

  #+REVEAL_HTML: <div class="rightcol">
  #+BEGIN_SRC html-chrome :exports results
      <div>
	<label for="item">Enter a new item:</label>
	<input type="text" id="item" placeholder="Type something to buy">
	<button>Add item</button>
      </div>
  #+END_SRC

  #+RESULTS[fa65ef25afcb970a28ca6144c0c8bbe9cbf8a9e8]:
  [[file:solution-add-a-button-element.png]]

  #+REVEAL_HTML: </div>

 #+BEGIN_NOTES
 So lets add that =button= element to the page. Place it after
 the =input= element, and inside the =div=.

 The text on the button can be anything you want.

 Once you've done that and it's showing up, add and commit.

 [Wait]
 #+END_NOTES

* Widgets / controls
  :PROPERTIES:
  :TOPICS:   widget
  :END:

#+BEGIN_NOTES
The general term for things like the input box, buttons, and
other things that you can add to forms -- like checkboxes, drop-down
lists, radio buttons, and more -- is a *widget*. The term *control*
is also used.

So you might hear me talk about the *input widget* or the *input
control*, or the *button widget*.

You'll see these terms come up a lot in documentation as well.
#+END_NOTES

* TODO Responding to button clicks                                 :exercise:

- Use an event listener, exactly as before

#+BEGIN_SRC javascript
document.addEventListener('DOMContentLoaded', function(event) {
  document.querySelector('button').addEventListener('click', function(event) {
      console.log('The button was clicked');
  });
});
#+END_SRC

#+BEGIN_NOTES
Our button is on the page, but it's not doing anything yet.

We need to write some Javascript that will run when the button is
clicked that will do something.

To listen for button clicks we use an event listener exactly as we've
done in the past.

I know =querySelector= here is new. We're going to talk about that
in a moment.

For now, make sure that =index.html= is loaded, open the console,
type this, and click the button a few times to make sure it works.

[Wait]

Does everyone see how this works? Did you get the message in the
console when the button was clicked?
#+END_NOTES

*** =querySelector()=

#+BEGIN_SRC javascript
  document.querySelector('button').addEventListener('click', function(event) {
      console.log('The button was clicked');
  });
#+END_SRC

- Finds the *first* element that matches the CSS selector string
- Much more flexible than =getElementById()=

#+BEGIN_NOTES
So far we've been using =getElementById= to find elements based on their
=id= attribute.

Here I'm using the =querySelector= method. This method has a single
parameter which is a string which should look like a CSS selector.

Remember, the selector is the part in a CSS rule that's *before* the
curly-brackets and all the style rules.

If more than one element matches the selector only the first matching
element is returned.

#+END_NOTES

*** =querySelector()= examples

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html
<p id="first">...</p>

<h1 class="warning">...</h1>

<p class="warning">...</p>

<ul>
  <li>First li</li>
  <li>Second li</li>
</li>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
document.querySelector('#first');
  // <p id="first">
  // Identical to getElementById('first');

document.querySelector('.warning');
  // <h1 class="warning">

document.querySelector('p.warning');
  // <p class="warning">

document.querySelector('ul li:nth-of-type(2)').innerText;
  // "Second li"

document.querySelector('p');
  // <p id="first">
  // Finds the first matching element
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here are some examples.

On the left we have some HTML. On the right, some calls to
=querySelector()=.

In the Javascript, the call in line 1 returns the first =p= element,
also on line 1 of the HTML. This is because the =p= element has
an =id= of "first", and remember that the =#= sign is how you specify
an ID in CSS.

The call on line 5 returns the =h1= element. Although there are two
elements -- the =h1= and the =p= that have the =warning= class,
=querySelector= returns the *first* one.

The call on line 8 specifically finds the =p= element because the
selector is more specific.

And on line 11 this selector finds the second =li= element of the
first =ul= element. And then retrieve's its =innerText= property.
#+END_NOTES

* Log the value in the input box                                   :exercise:

- Modify the click listener
  - Retrieve the input widget's value
  - Log it using =console.log=

#+BEGIN_NOTES
We can use =console.log= to verify that we've got the value
correctly before moving on to the next part of the problem.
#+END_NOTES

** Solution: Button click listener

#+BEGIN_SRC javascript
  // With a variable.
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      let inputBox = document.getElementById('item');
      console.log(inputBox.value);
    });
  });
#+END_SRC

#+BEGIN_SRC javascript
  // With chaining.
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      console.log(document.getElementById('item').value);
    });
  });
#+END_SRC

* TODO Adding list items

#+BEGIN_SRC html
<ul>
  <!-- List items go here -->
</ul>
#+END_SRC

#+BEGIN_SRC html
<li><span>Eggs</span> <button>Delete</button></li>
#+END_SRC

#+BEGIN_NOTES
Now that we can do something when the user clicks the button, and
we can see what text they added, we need to figure out how we're
going to add an item to the list.

In our HTML file our list starts out like the example at the top.
It's just the =ul= element with no children.

What we want is to create a new entry in the list for each item.
Each entry is going to need to contain the text that the user
typed in, and a button to delete the item from the list.

In other words, it's going to look like the HTML at the bottom.
Except "Eggs" is going to be replaced by whatever the user typed in.

This means we need to write a function that can take whatever's in the
=input=, create a new =li=, create a =span=, set the text of the
=span=, add a button.

Before we do that, let's make sure that our understanding of what
the DOM tree for this is going to look like is correct.
#+END_NOTES

** List item graph                                                 :exercise:

#+BEGIN_SRC html
<li><span>Eggs</span> <button>Delete</button></li>
#+END_SRC

- Draw the DOM tree for this HTML

#+BEGIN_NOTES
This is what we're going to add to the =ul= element every time
the button is clicked.

Go ahead and draw out the tree for these elements.

[Wait]
#+END_NOTES
*** Solution: List item graph
#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html
<li><span>Eggs</span> <button>Delete</button></li>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file list-item-graph.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
digraph G {
  node [shape="hexagon"];

  li -> span
  li -> button

  span -> span_content;
  span_content [label="Eggs" shape=none];
  button -> button_content;
  button_content [label="Delete" shape=none];
}
#+END_SRC

#+RESULTS:
[[file:list-item-graph.svg]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Did everybody's tree look like this?

[Wait]

For anyone's that didn't.

We start with the =li= element -- that's the first node.

We see that this has a child element called =span=, so we add
that to the tree.

Then we see that it has some content, so we add that as well.

Then the =span= ends, and a new =button= element starts. This is
also a child of the =li= element. And that has some text content
too, so we add that as its own node.
#+END_NOTES

** Exercise: Write a function that creates this tree

#+REVEAL_HTML: <div class="leftcol">
[[file:list-item-graph.svg]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  // Fill this in
}
#+END_SRC
#+REVEAL_HTML: </div>

** Exercise (hint): Write a function that creates this tree

#+REVEAL_HTML: <div class="leftcol">
[[file:list-item-graph.svg]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  // Create an li node

  // Create a span node

  // Set the span's .innerText property

  // Create a button node

  // Set the button's .innerText property

  // Append the span to the li node

  // Append the button node to the li node

  // Return the li node
}
#+END_SRC
#+REVEAL_HTML: </div>



** Solution: Write a function that creates this tree

#+NAME: createNewListItemNoDelete
#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  let listItem = document.createElement('li');

  let listText = document.createElement('span');
  listText.textContent = itemName;

  let deleteButton = document.createElement('button');
  deleteButton.textContent = 'Delete';

  listItem.appendChild(listText);
  listItem.appendChild(deleteButton);

  return listItem;
}
#+END_SRC

#+BEGIN_NOTES
Here's one possible solution.

There are 5 sections to this code:

1. Creating the =li=
2. Creating and populating the =span=
3. Creating and populating the =button=
4. Appending children to the =li=
5. Returning the value.

Steps 1, 2, and 3 can happen in any order.

I'm going to show you some variations of this function.
#+END_NOTES

** Solution: Write a function that creates this tree

#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  let listItem = document.createElement('li');
  let listText = document.createElement('span');
  let deleteButton = document.createElement('button');

  listText.textContent = itemName;
  deleteButton.textContent = 'Delete';

  listItem.appendChild(listText);
  listItem.appendChild(deleteButton);

  return listItem;
}
#+END_SRC

#+BEGIN_NOTES
This has exactly the same effect as the previous function. But
here the nodes are created before being modified. This is absoutely
fine.

My personal preference is to not do this -- I generally prefer it if a
variable is declared as close to where it will be used as possible,
but different people have different opinions about this.
#+END_NOTES

** Solution: Create and append

#+BEGIN_SRC javascript
  function createNewListItem(itemName) {
    let listItem = document.createElement('li');

    let listText = document.createElement('span');
    listText.textContent = itemName;
    listItem.appendChild(listText);

    let deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';
    listItem.appendChild(deleteButton);

    return listItem;
  }
#+END_SRC

#+BEGIN_NOTES
This also has the same effect, but we append the nodes to the
list item as soon as we're done with them.

This is also a perfectly fine way to do things.
#+END_NOTES

* TODO Adding list items when the button is clicked                :exercise:

#+BEGIN_CENTER
This is our current click listener
#+END_CENTER

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      let inputBox = document.getElementById('item');
      console.log(inputBox.value);
    });
  });
#+END_SRC

- Call =createNewListItem= to generate the =li= node
- Find the =ul= element and use =appendChild= to add the =li= node

#+BEGIN_NOTES
This is the click listener that we wrote earlier. Yours might have
slightly different variable names, but it should work -- when the
button is clicked it should log whatever is in the input widget.

Modify this =click= listener so that it calls =createNewListItem=
with the input widget's value to create the new =li= element.

Then find the =ul= element and use =appendChild= to add the =li= node.

[Wait for everyone to do this]
#+END_NOTES

*** TODO Solution: Adding list items when the button is clicked
#+BEGIN_SRC javascript
  // Variables
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      let inputBox = document.getElementById('item');
      let li = createNewListItem(inputBox.value);
      document.querySelector('ul').appendChild(li);
    });
  });
#+END_SRC

#+BEGIN_SRC javascript
  // Chaining
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      document.querySelector('ul').appendChild(
        createNewListItem(document.getElementById('item').value));
    });
  });
#+END_SRC

#+BEGIN_NOTES
Here's what one solution looks like.

We call =createNewListItem()=, passing it =inputBox.value=, so it
receives whatever text the user typed in.

This returns an =li= elemnt, which we save in the =li= variable.

On the next line we find the =ul= element and append our new =li=
element to the end.

[Questions?]

This alternative version here does the same thing, but chains
things together instead of using intermediate variables.
#+END_NOTES

* TODO The =Delete= button

#+BEGIN_SRC javascript :noweb yes
<<createNewListItemNoDelete>>
#+END_SRC

#+BEGIN_NOTES
Now that adding items to the list works we need to figure out how
we're going to delete them.

Deleting a list item is the same thing as deleting (or removing) it
from the DOM tree.

This is the code that I wrote that creates and returns a new list
item. We talked about this code a few slides back -- your code
might look slightly different, but the end result is the same.

The important bit for the delete button is finding the place in
the code where the button is created. In my code that's right here,
lines 7 and 8.

Go ahead and find that spot in your code.

Because we're going to make a change right there.

Let me know when you've found your equivalent code.
#+END_NOTES

** TODO Exercise: Checking we can detect the click                 :exercise:

#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  let listItem = document.createElement('li');

  let listText = document.createElement('span');
  listText.textContent = itemName;

  let deleteButton = document.createElement('button');
  deleteButton.textContent = 'Delete';

  // Add a click handler that logs the click here
  // ...

  listItem.appendChild(listText);
  listItem.appendChild(deleteButton);

  return listItem;
}
#+END_SRC

#+BEGIN_NOTES
As always, let's make sure we can detect the click before we do
anything more complicated.

We're always trying to make the simplest change that can work, and then
build upon it.

So, change your =createNewListItem= function and add a click listener
after the delete button has been created.

This is my code, so I'd put the new code where the comment is. Your
code might create the elements in a slightly different order, but
as long as you create the handler after the button is created you'll
be OK.

This click listener is going to be just like the one we made for the
"Add Item" button a while back -- it does has to listen for the
=click= event and use =console.log= to send a message to the console.

[Wait]
#+END_NOTES

** TODO Solution: Checking we can detect the click
#+NAME: createNewListItemLogClick
#+BEGIN_SRC javascript
  function createNewListItem(itemName) {
    let listItem = document.createElement('li');

    let listText = document.createElement('span');
    listText.textContent = itemName;

    let deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';

    deleteButton.addEventListener('click', function(event) {
      console.log('Delete button clicked');
    });

    listItem.appendChild(listText);
    listItem.appendChild(deleteButton);

    return listItem;
  }
#+END_SRC

#+BEGIN_NOTES
Here's my solution. There's nothing special here that we haven't
done before.

I add an event listener for the =click= event to the delete
button, and when it's clicked I used =console.log= to confirm
that the listener was working.

That's the new code on lines 10, 11, and 12. Everything else is
the same.
#+END_NOTES
** TODO Removing DOM nodes                                         :exercise:
   :PROPERTIES:
   :REQUIREMENTS: dom
   :TOPICS:   dom-remove
   :END:

 - [[[https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove][MDN remove element]]] / [[[https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove][MDN delete element]]]

#+BEGIN_NOTES
Now that we know we can detect the click and run an event listener we
need to find out how we delete the current list item from the tree.

For that we can use the documentation again. Try one of these
searches in Google, and read the documentation that comes up.

See if you can figure out what *one line of code* we need to write
in the click event listener to delete the listitem when the
button is clicked.

[Wait]
#+END_NOTES

** Solution: Removing DOM nodes
#+BEGIN_SRC javascript
element.remove();
#+END_SRC

#+BEGIN_NOTES
The general way to remove an element from the DOM tree is to
call its =remove()= method.  If you do this then the element,
and anything that it contains, will be deleted.
#+END_NOTES

*** =remove()= and the DOM

#+BEGIN_SRC html
  <ul>
    <li><span>Eggs</span> <button>Delete</button></li>
    <li><span>Milk</span> <button>Delete</button></li>
    <li><span>Bread</span> <button>Delete</button></li>
  </ul>
#+END_SRC

#+BEGIN_NOTES
Imagine our list has three list items in it, for "Eggs", "Milk",
and "Bread", like this.

#+END_NOTES

*** =remove()= and the DOM

 #+BEGIN_SRC dot :file list-item-graph2.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
 digraph G {
   node [shape="hexagon"];

   ul -> {li1, li2, li3};
   li1 [label="li"];
   li1 -> span1
   li1 -> button1

   span1 [label="span"];
   span1 -> span_content1;
   span_content1 [label="Eggs" shape=none];
   button1 [label="button"];
   button1 -> button_content1;
   button_content1 [label="Delete" shape=none];

   li2 [label="li"];
   li2 -> span2
   li2 -> button2

   span2 [label="span"];
   span2 -> span_content2;
   span_content2 [label="Milk" shape=none];
   button2 [label="button"];
   button2 -> button_content2;
   button_content2 [label="Delete" shape=none];

   li3 [label="li"];
   li3 -> span3
   li3 -> button3

   span3 [label="span"];
   span3 -> span_content3;
   span_content3 [label="Bread" shape=none];
   button3 [label="button"];
   button3 -> button_content3;
   button_content3 [label="Delete" shape=none];
 }
 #+END_SRC

 #+RESULTS:
 [[file:list-item-graph2.svg]]

#+BEGIN_NOTES
This is what the DOM tree for that looks like.

Does this make sense to everyone so far?

[Wait]
#+END_NOTES

*** Finding the second list item

#+BEGIN_SRC javascript
let secondLi = document.querySelector('li:nth-child(2)');
#+END_SRC

 #+BEGIN_SRC dot :file list-item-graph3.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
 digraph G {
   node [shape="hexagon"];

   ul -> {li1, li2, li3};
   li1 [label="li"];
   li1 -> span1
   li1 -> button1

   span1 [label="span"];
   span1 -> span_content1;
   span_content1 [label="Eggs" shape=none];
   button1 [label="button"];
   button1 -> button_content1;
   button_content1 [label="Delete" shape=none];

   subgraph cluster_li2 {
     li2 [label="li"];
   }
   li2 -> span2
   li2 -> button2

   span2 [label="span"];
   span2 -> span_content2;
   span_content2 [label="Milk" shape=none];
   button2 [label="button"];
   button2 -> button_content2;
   button_content2 [label="Delete" shape=none];

   li3 [label="li"];
   li3 -> span3
   li3 -> button3

   span3 [label="span"];
   span3 -> span_content3;
   span_content3 [label="Bread" shape=none];
   button3 [label="button"];
   button3 -> button_content3;
   button_content3 [label="Delete" shape=none];
 }
 #+END_SRC

 #+RESULTS:
 [[file:list-item-graph3.svg]]

*** Removing the second list item

#+BEGIN_SRC javascript
let secondLi = document.querySelector('li:nth-child(2)');
secondLi.remove();
#+END_SRC

#+BEGIN_SRC dot :file list-item-graph4.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
 digraph G {
   node [shape="hexagon"];

   ul -> li1;
   ul -> li2 [style=invis];
   ul -> li3;

   li1 [label="li"];
   li1 -> span1;
   li1 -> button1;

   span1 [label="span"];
   span1 -> span_content1;
   span_content1 [label="Eggs" shape=none];
   button1 [label="button"];
   button1 -> button_content1;
   button_content1 [label="Delete" shape=none];

   li2 [label="li" style=invis];

   li2 -> span2 [style=invis];
   li2 -> button2 [style=invis];

   span2 [label="span" style=invis];
   span2 -> span_content2 [style=invis];
   span_content2 [label="Milk" style=invis shape=none];
   button2 [label="button" style=invis];
   button2 -> button_content2 [style=invis];
   button_content2 [label="Delete" style=invis shape=none];

   li3 [label="li"];
   li3 -> span3
   li3 -> button3

   span3 [label="span"];
   span3 -> span_content3;
   span_content3 [label="Bread" shape=none];
   button3 [label="button"];
   button3 -> button_content3;
   button_content3 [label="Delete" shape=none];
 }
 #+END_SRC

 #+RESULTS:
 [[file:list-item-graph4.svg]]


*** TODO Exercise: Remove the listitem when the delete button is clicked :exercise:

#+BEGIN_SRC javascript :noweb yes
<<createNewListItemLogClick>>
#+END_SRC

#+BEGIN_NOTES

#+END_NOTES
*** TODO Solution: Remove the listitem when the delete button is clicked
#+NAME: createNewListItemDelete
#+BEGIN_SRC javascript
  function createNewListItem(itemName) {
    let listItem = document.createElement('li');

    let listText = document.createElement('span');
    listText.textContent = itemName;

    let deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';

    deleteButton.addEventListener('click', function(event) {
      listItem.remove();
    });

    listItem.appendChild(listText);
    listItem.appendChild(deleteButton);

    return listItem;
  }
#+END_SRC

#+BEGIN_NOTES
Here we simply call the =remove= method on the =listItem=.
#+END_NOTES

* TODO Recap: What have we learned?

#+REVEAL_HTML: <div class="leftcol">
- Widgets
  - =input=
    - Different types exist, ~type=...~
    - Retrieving the value
  - =button=
    - Reacting to clicks
  - =label=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- =document.querySelector('...')=
  - More flexible way to select elements
- =element.remove()=
  - To remove elements from the DOM
#+REVEAL_HTML: </div>

* Play

- Play around with the shopping list
- Identify things we could change to make it easier for users

* TODO UX followup work

- Press =ENTER= to add an item
- Clear the input widget after adding an item
- Setting the input focus
- Prevent empty items from being added

#+BEGIN_NOTES
So, there's good news and bad news.

The good news is that our CEO is very happy with our work, and
thinks that our shopping list app could make a fortune.

The bad news is that we've done some user experience tests with
early adopters, and they've identified a number of things that
they'd like us to change about the app.

They are:

- At the moment they have to click the button to add an item. They'd
  like to press the Enter key as well

- After they've added an item it's still in the input widget. So they
  have to delete whatever they typed in last before entering a new
  item

- Some of them use the keyboard a lot, and they keep having to use
  the mouse to click in the input box before they can type there

- It's really easy to add empty items to the list

Lets get on and fix those problems.
#+END_NOTES

* Press ENTER to add an item

- Need to click the button to add the item
- Natural to press ENTER to add to the list
- How?

** MDN key events                                                  :exercise:

- Search MDN for information about keyboard events
- Look for information about keys being released

#+BEGIN_NOTES
Given the events we've been dealing with so far, you're probably not
surprised to know that events also fire when the user presses and
releases keys.

Search MDN for information about keyboard events, look particularly
for anything that can tell you when a key has been released by
the user.

[Wait]

What did you find?
#+END_NOTES

** TODO =keyup= event properties

#+BEGIN_CENTER
[[https://developer.mozilla.org/en-US/docs/Web/Events/keyup]]
#+END_CENTER

#+BEGIN_SRC javascript
document.addEventListener('DOMContentLoaded', function(event) {
  ...
});
#+END_SRC

#+BEGIN_NOTES
So far our event listeners have only been interested in whether
or not the event occurred. There's nothing else about the event
that's interesting to them.

Things are different for the =keyup= event. Here, we don't just
want to know that a key was released, we want to know which key
was released -- specifically, was it the ENTER key?

All of our event listeners have taken an =event= parameter, but
we haven't used it.

This parameter is where the browser tells us extra things about
the event so that we can make decisions about it.

The documentation for each event tells us what properties the
event parameter has for this type of event, and what they mean.

Looking through these there are a number of things we haven't
covered yet, including event bubbling and cancellation. Don't worry
about those.

I'm more interested in these ones here -- from =char= on down.
These all sound like they'll tell us more information about
the key that was released.

The =key= property looks interesting, based on its description.
Reading that, it sounds like regular keys will have a =key=
value like the key itself, so if you press =a= then the value
will the string =a=, =b= is =b=, and so on.

This note here about =Key values= is also interesting. This
strongly suggests that special keys, like =Enter=, are
represented specially, so lets look at that doc for more
information.

[[https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values][Key values]]

So this document has lots of tables. It looks like the first
column is the value of that =key= property, and then there are
more details.

Looking at the scroll bar on the right tells me that this is
a huge document, so I'm going to just search for =Enter= and
see if anything turns up.

[Search for Enter]

And straightaway, we can see that if the user presses the
Enter key we should get a =key= value of the string =Enter=. I
can tell that it's a string because it's surrounded by double
quotes.

#+END_NOTES

** Exercise: Listening for =keyup= and inspecting =event.key=      :exercise:
#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    // Add code here that listen for 'keyup' on the 'input' element
    // and logs the event.key property.
  });
#+END_SRC

#+BEGIN_NOTES
Lets go and check that our understanding is correct, by writing an
input event listener that listens for =keyup= events on the input
widget and logs the results.

Do this, and let me know when it's done, and you have confirmed
which string is used to repesent the ENTER key.

[Wait]
#+END_NOTES

** Solution: Listening for =keyup= and inspecting =event.key=
#+NAME: EventKeyLog
#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      console.log(event.key);
    });
  });
#+END_SRC

#+BEGIN_NOTES
Here's a solution -- the new event listener here simply logs the
=key= property of the =event= argument so we can take a look at it.

What special string is used if the user presses the ENTER key?

[Wait]

Are there strings for any other special keys?

[Wait]

=Control=, =Shift=, =Alt=, =AltGraph=, =CapsLock=
#+END_NOTES

** How do we use this?

#+BEGIN_NOTES
Now we know that we can tell if the user pressed the ENTER key in
the input widget.

At the moment we're just logging the key that was pressed. We need
to be able to run some code only if the key that was pressed is
ENTER.

How do we do that?
#+END_NOTES
** Making a decision: using =if= statements
   :PROPERTIES:
   :REQUIREMENTS: js-control-flow
   :TOPICS:   js-if
   :END:

#+BEGIN_SRC javascript
if (expression) {
  // Code that only runs if 'expression' is true
  //
  // We call this the "body" of the "if" block.
}
#+END_SRC

#+BEGIN_NOTES
The answer to that is an =if= statement.

We haven't seen these yet.

Remember when we first talked about the flow of control. Initially
control in the program flows down, line by line by line.

Then we introduced functions, which allows the flow to jump to a
different function, run the code that's in that function, and then
jump back to carry on where it left off.

=if= statements change the flow so that some code -- the code inside
the =if= block -- runs only if the expression inside the parentheses
is true.

Notice how the =if= block uses curly brackets -- just like functions --
to enclose the code that might run.
#+END_NOTES
** True and false values in Javascript?

#+REVEAL_HTML: <div class="leftcol">
- False values
  - =false=
  - =undefined=
  - =null=
  - =NaN=
  - =0= (number zero)
  - =''= (empty string)
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- True values
  - Everything else
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Looked a little bit at these earlier in the week.

TODO: Look back to when that was and what was discussed

On the left hand side is every value that Javascript considers to be
false. If the result of an expression evalutes to false and the
expression is used in an =if= condition, the body of the =if= will not
run.
#+END_NOTES
** Comparison operators, numbers

#+BEGIN_SRC javascript
let a = 10;
let b = 20;

a === b;   // false, === means "is equal to?"
a !== b;   // true,  !== means "is not equal to?"
a <   b;   // true,  <   means "is less than?"
a >   b;   // false, >   means "is greater than?"
a <=  b;   // true,  <=  means "is less than or equal to?"
a >=  b;   // false, >=  means "is greater than or equal to?"
#+END_SRC

#+BEGIN_NOTES
Javascript supports numerous operators that are used to compare two
or more values.

Here are the six most common, and what they return.

Try all of these in the console, and make sure you get the same
result.

[Wait]
#+END_NOTES

** Comparison operators, strings
#+NAME: string-comparison-operators
#+BEGIN_SRC javascript
let c = 'This is a string';
let d = 'This is also a string';

c === d;   // false, === means "is equal to?"
c !== d;   // true,  !== means "is not equal to?"
c <   d;   // true,  <   means "is less than?"
c >   d;   // false, >   means "is greater than?"
c <=  d;   // true,  <=  means "is less than or equal to?"
c >=  d;   // false, >=  means "is greater than or equal to?"
#+END_SRC

#+BEGIN_NOTES
You can use these same operators to compare strings. Try these out
in the console.

[Wait]
#+END_NOTES
** What does =<= and =>= mean for strings?

- Dictionary order

#+BEGIN_SRC javascript
// let c = 'This is a string';
// let d = 'This is also a string';

c < d;   // true

let e = 'Another string example';
let f = 'Another example string';

e < f;   // false, 'e' comes before 's'
#+END_SRC

#+BEGIN_NOTES
Strings are compared in dictionary order. Imagine that you had to put
the string in a dictionary. Any word, or string that would occur first
in the dictionary is *less than* any word or string that would appear
after.

Here, strings =e= and =f= are different from the first letter of the
second word. Since the =e= in =example= is before the =s= in =string=,
string =f= is less then string =e=, and the comparison is false.
#+END_NOTES

** Expressions can mix variables and values

#+BEGIN_SRC javascript
// let a = 10;
// let c = 'This is a string';

a > 5;                      // true
a <= 10;                    // true

c === 'This is a string';   // true
#+END_SRC

#+BEGIN_NOTES
Of course expressions can mix variables and values. Here are some
examples of that.

Try these out too.

[Wait]
#+END_NOTES
** Warning: ~==~ and ~!=~

- Do not use ~==~ and ~!=~

#+BEGIN_SRC javascript
let g = 10;
let h = '10';

g === h;   // false, comparing numbers and strings
g ==  h;   // true, Javascript converts h to a number first (DANGER)

g + 1 == h + 1;  // false (DANGER)
#+END_SRC

#+BEGIN_NOTES
Javascript has two other equality operators, the double-equals, and the
bang-equals.

You will probably see them in older code.

You should not use them.

Rembeer how values have types -- a number, or a string say.
Triple-equals returns true only if the values are the same and the
types are the same.  In this first comparison here it returns false
because the types don't match.

Single-equals and bang-equals don't do this. If the types don't match it
tries to convert them. So on this line here the result is true, because
it convers the string one-zero to the number ten first, and that is
equal.

This can lead to very strange behaviour. For example, if you have two
values that are identical according to double-equals, and add 1 to both
values you think that the results would be the same.

But they're not, because the plus-sign in Javascript does different
things depending on whether the value is a number or a string.

This can lead to subtle bugs, so always use triple-equals and
bang-equals-equals.
#+END_NOTES

** Reminder: =if= statement syntax

#+BEGIN_SRC javascript
if (expression) {
  // Code that only runs if 'expression' is true
  //
  // We call this the "body" of the "if" block.
}
#+END_SRC

#+BEGIN_NOTES
So as a quick reminder after all that, this is the structure of an
=if= statement.

We have the =if= keyword, an expression in parentheses, and then the
code to run if the expression is true inside curly brackets.
#+END_NOTES

** Exercise: Only log the key if it's =Enter=                      :exercise:

#+BEGIN_SRC javascript :noweb yes
<<EventKeyLog>>
#+END_SRC

#+BEGIN_NOTES
Here's our current logging code.

Change this so that the key is only logged if it's =Enter=

[Wait]
#+END_NOTES

*** Exercise (hint): Only log the key if it's =Enter=

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      if (/* What goes here? */) {
        console.log(event.key);
      }
    });
  });
#+END_SRC

** Solution: Only log the key if it's =Enter=
   :PROPERTIES:
   :REQUIREMENTS: webstorm
   :END:

#+NAME: EnterKeyLog
#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      if (event.key === 'Enter') {
        console.log(event.key);
      }
    });
  });
#+END_SRC

#+BEGIN_NOTES
If this is working then you should see that the log message only
appears when you press the Enter key.

[Demo this in WebStorm to show the control flow changing]
#+END_NOTES
** Exercise: Adding the item if the ENTER key is released          :exercise:
   :PROPERTIES:
   :END:
#+BEGIN_SRC javascript :noweb yes
<<EnterKeyLog>>
#+END_SRC

#+BEGIN_NOTES
So, back to our code. And the last thing we need to do here is to
replace the logging code with code that creates the new list item
and appends it to the list, exactly as the code for clicking the
button does.

Off you go.

[Wait]
#+END_NOTES
** Solution: Adding the item if the ENTER key is released
#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      if (event.key === 'Enter') {
        let inputBox = document.getElementById('item');
        let li = createNewListItem(inputBox.value);
        document.querySelector('ul').appendChild(li);
      }
    });
  });
#+END_SRC

#+BEGIN_NOTES
And here's that final part of the function.

We listen for the keyup event, and check to see if it's the Enter
key here.

If it is then this block will run, and this is the same code that we
used to create a new list item and add it to the list.
#+END_NOTES
** Recap: What have we learned?
#+REVEAL_HTML: <div class="leftcol">
- Events fire for keypresses
  - =keyup=
  - =keydown=
  - =keypress=
- The =event= parameter
  - Holds event-specific information
  - MDN documentation has info
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Decisions with =if=
  - Expressions, true/false values
- Different comparison operators
- Don't use ~==~ and ~!=~
#+REVEAL_HTML: </div>
** Add and commit the changes
* Clear the input widget after adding an item
** Problems
- The user has to delete the text in the input widget
- And if they double-click, or press =Enter= twice then the item is added twice
- Fix this by clearing the =input= widget after appending the list item
- We've already seen how

** Exercise: Clear the input widget                                :exercise:

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // Existing code that adds to the list

      // <-- new code goes here
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      // Existing code that adds to the list

      // <-- new code goes here
    });
  });
#+END_SRC

** Solution: Clear the input widget

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // Existing code that adds to the list

      inputBox.value = '';
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      // Existing code that adds to the list

      inputBox.value = '';
    });
  });
#+END_SRC

** Add and commit the changes
* Setting the input focus
  :PROPERTIES:
  :TOPICS:   focus scope
  :END:
** Focus means "Where do your keystrokes go?"

#+BEGIN_NOTES
On a form with multiple controls, like this (an input widget and a
button), where do you keystrokes go?

For example, you can press SPACE to click the button. Or you can
press SPACE to put a space in the input widget. How does the system
decide what happens when SPACE is pressed?

We say that there is the *focus*. Only one widget at a time has
the focus. It's where your clicks and keystrokes go.
#+END_NOTES

** The focus moves with TAB key                                    :exercise:

#+BEGIN_NOTES
Click on the input widget.

You should see a blue highlight around it -- the colour might change
depending on your system.

This highlight means that the input widget has the focus.

Press the TAB key. The focus should have shifted to the button.

[Wait]

Press the TAB key again. Where has the focus gone now?

[Wait]
#+END_NOTES

** Javascript has methods to set the focus

- [[https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus][MDN element focus]]

#+BEGIN_NOTES
Javascript provides methods to set the focus to a given element.

Do this search to read up on how to do it.
#+END_NOTES

** Exercise: Give the input widget the focus after adding an item  :exercise:

- No code hint this time. See how you do!

#+BEGIN_NOTES
[Wait]
#+END_NOTES
** Solution: Give the input widget the focus

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // Existing code that adds to the list and clears the box.

      inputBox.focus();
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      // Existing code that adds to the list
    });

    let inputBox = document.getElementById('item');
    inputBox.focus();
  });
#+END_SRC

#+BEGIN_NOTES
Did your changes look like this?

[Wait]

We had to add this in two places.

The first is in the event listener for the button click. When the user
clicks the button the focus moves to the button, so we have to send
it back to the input widget.

We *don't* have to do it when the user presses ENTER in the input
widget, because the focus doesn't move at that point -- it stays
in the widget.

I found that when the page is loaded nothing has the focus. So I've
explicitly set the focus to the input widget when the DOM content
had loaded as well.

[Questions? Any problems?]
#+END_NOTES

** Add and commit the changes

* A quick refactoring

#+INCLUDE: "shopping-3.js" :lines "26-45" src javascript

#+BEGIN_NOTES
This is my code at this point (just for the event listeners, this
isn't the code that creates the list item).

Your code should look similar. I've used method chaining, you might
not have, but the general structure of the code should be the same.

I'm going to do a quick refactoring of this.

I don't like that the input widget has to be found three different
times. It clutters up the code a bit, and makes it a little harder
to focus on what's going on.

And the shopping list also has to found twice, so lets remove that
duplication.

It also gives me the chance to explain *scope* to you, so let's do
that.
#+END_NOTES

** Refactored: variables at higher scopes

#+INCLUDE: "shopping-4.js" :lines "26-47" src javascript -n

#+BEGIN_NOTES
This is the refactored code.

On lines two and three I declare and initialise two variables, one
for the inputBox, one for the shopping list.

Then I use these throughout the rest of function.

So lets talk about *scope* for a second.

When we declare variables in Javascript we say that they have a
*scope* (you might also hear the word *visibility* used).

Very roughly, Javascript uses these curly brackets to indicate where
scopes start and end.

And because we can have curly bracket sections inside curly bracket
sections, we say that they are nested inside each other.

This is very similar to the way that HTML elements are nested inside
one another.

You can think of this as creating different *levels* of scope. Each
new curly bracket pair in the nested set increases the scope level by
one.

The rule is that a variable is visible in its scope, and any scopes
that are nested inside it.

I'll use this code to explain, and then we'll do a couple more examples.

At the very top level is the outermost, or *global* scope. Anything at
this scope is visible to everything else.

In this code example we don't have any variables at the global scope.

Line 1 introduces a curly bracket, so we know a new scope has been
created. Let's call this the L1 scope.

We define two variables in the L1 scope.

Line 5 uses the =inputBox= variable. We're in L2 scope and the
variable was defined in L1, so this is fine.

Line 5 also introduces a curly bracket, so everything from there on in
is at L2 scope.

Line 6 has another one -- the if() body -- so L3 scope starts there.
That uses =shoppingList= and =inputBox=, both L1 scope, so visible.

Line 9 has a closing curly brace, so we jump up one scope level, and
we're back to L2 scope.

On line 11 I can use the =inputBox= variable instead of calling
=querySelector= again.

Lines 13 through 18 are very similar. Importantly, when the L2 scope
is created in line 13, and the L3 scope in line 14, these are
*different* from the L2 and L3 scopes from earlier

This is one of the reasons why we're careful to indent code -- the
indentation also helps to show the scopes, and prevent mistakes.
#+END_NOTES

** Refactored: variables at higher scopes

#+INCLUDE: "scope.html" src javascript -n

#+BEGIN_NOTES
Here's a somewhat contrived example that maybe helps.

In our script element we start in global scope. That's where
the =a= variable is defined, so it's in global scope.

Our =scope= function creates an L1 scope. The =b= and =c=
variables are in this scope.

The =if= statement creates an L2 scope. Crucially, inside
this scope we create a new =c= variable. This means that that
=c= variable from line 6 is temporarily hidden, and replaced with
this new =c= variable.

We exit the L2 scope on line 12, back to the L1 scope.

The log on line 14 shows the *original* version of =c=, not the
one from line 10.

Finally, the log statement on line 17 generates an error. We're
back in global scope here, and =b= was defined in an L1 scope,
so it's not visible.

Is that -- somewhat -- clear?
#+END_NOTES

** Quick note on the backticks, =`=
   :PROPERTIES:
   :TOPICS:   backticks
   :END:

#+BEGIN_SRC javascript
let a = '[a:g]';
let b = '[b:1]';
let c = '[c:1]';

console.log(a + ' ' + b + ' ' + c); // "[a:g] [b:1] [c:1]"
console.log(`${a} ${b} ${c}`);      // "[a:g] [b:1] [c:1]"
#+END_SRC

#+BEGIN_NOTES
When you want to include a variable's value in a string we've
been doing string concatenation with the plus sign, as in the first
example.

If you use backticks, as in the second example, you can put the
value of the variable in the string by using this syntax with a
dollar sign, an opening curly, the name of the variabe, and a
closign curly.

As you can see, it can be quite a bit easier to read.
#+END_NOTES

* Prevent empty items from being added
- Pressing Enter or clicking the button adds an item
  - Even if it's the empty string

#+BEGIN_NOTES
Now that we're refactored the code slightly lets move on to the
next problem -- prevening empty items from being added.

This is the current problem.

How should we solve it?

[Wait]
#+END_NOTES

** Rules
- If the input widget is empty
  - Pressing =Enter= in the input widget should do nothing
  - The button should be disabled / clicks ignored
** Multiple parts to this problem
- How do we say that input is required?
- How do we disable the button?

* Using =if= to require input                                      :exercise:

#+INCLUDE: "shopping-4.js" :lines "26-47" src javascript -n

#+BEGIN_NOTES
Here's our code again.

We already use an =if= statement here (line 12) to check to see
if the value of the =event.key= property is correct.

How can we use extra =if= statements to see if the =inputBox=
=value= is not the empty string?

[Wait]
#+END_NOTES

** (hint) Which comparison operator to use?

#+BEGIN_SRC javascript :noweb yes
<<string-comparison-operators>>
#+END_SRC

** Solution: Using =if= to require input

#+BEGIN_SRC javascript
if (inputBox.value !== '') {
  // Code to add the listitem goes here
}
#+END_SRC

#+BEGIN_NOTES
We can wrap our code in this =if= statement. The code inside the
body of the =if= will only run if =inputBox.value= is not the empty
string.

If you haven't already done that, do that, and make sure it works.

[Wait]
#+END_NOTES

** Solution: Using =if= to require input

#+INCLUDE: "shopping-5.js" :lines "26-49" src javascript -n

#+BEGIN_NOTES
Here's the new code, with the additional =if= statements starting
on line 6 and 14.

Everyone OK with this change? It makes sense?

[Wait]

OK, so add this change to your file, and commit as normal.

[Wait]

Now that we've done that, there's a problem with this code.
Can anyone tell me what it is?
#+END_NOTES

** Problem: Only looks at empty strings

#+BEGIN_SRC javascript
if (inputBox.value !== '') {
  // Code goes here
}
#+END_SRC

- Only looks at completely empty strings
- What if the user has typed in one space?
- Or three spaces? Or 15?

#+BEGIN_NOTES
This is a very specific check -- it only looks to see if the string
is completely empty.

If the user has typed in a space, or lots of spaces, the string
will no longer be empty.

So the test will pass and the user will have entered what looks like
an empty shopping list item. We'll know it's not really empty, but
it still looks like a problem to them.

So we'll have to fix that.
#+END_NOTES

** Dealing with whitespace                                         :exercise:

- [[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String][MDN string]]]
- Review the available string methods
- Are there any that deal with whitespace?

#+BEGIN_NOTES
Lets see if we can figure out how to deal with this.

Find the MDN documentation for strings by doing this search.

On that page you'll see long section called "Methods". Review that
section, looking for methods that deal with whitespace.

Are there any methods that would let us deal with potential whitespace
in the string?
#+END_NOTES

** The =trim= method                                               :exercise:

#+BEGIN_QUOTE
Trims whitespace from the beginning and end of the string.
#+END_QUOTE

#+BEGIN_NOTES
In case it's not clear, 'trim' means remove.

So this takes the string, and removes any whitespace that appears
at the beginning or end of the string

On the general string page is a link to the more detailed page for
the =trim= method. Follow that link (the top of the page should say
"String.prototype.trim()". There you'll see some more examples and
a console you can play around with.

Use that to get familiar with the method, then figure out what we
should change in our code to use it to make the check work properly.

Make that change to your code, and check that empty items aren't being
added to the list any more.

[Wait]
#+END_NOTES

** Solution: Using =if= and =trim= to require input

#+INCLUDE: "shopping-6.js" :lines "26-49" src javascript -n

#+BEGIN_NOTES
Here's what I came up with.

I use =trim()= in both of the =if= expressions so that the input
string is trimmed of all whitespace.

That's here on line 6 and on line 14.

But I also make sure that the input is trimmed when it's added to
the list, here on line 7 and on line 16. That's probably worth a
refactor later, but it will do for the moment.

Everyone OK with this so far?

[Wait]
#+END_NOTES

** Add and commit the changes

* Disabling the button                                             :exercise:

- [[[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button][MDN button disable]]]

#+BEGIN_NOTES
With this change in place pressing the Enter key or clicking the
button won't do anything while the input box is empty or only
contains whitespace.

This is good, but we can go a step further.

At the moment the button still looks active when there's nothing
that can be added.

This is a visual clue to the user the button can be clicked, so
they're going to be surprised when clicking the button does
nothing.

You know the drill by now -- go and look for an MDN article that
mentions =button= and =disable=, and see if you can figure out
how to mark a button as being disabled.

[Wait]
#+END_NOTES

** Solution: Disabling the button                                  :exercise:

#+BEGIN_SRC javascript
let button = document.querySelector('button');
button.disabled = true;  // Disable the button
button.disabled = false; // Enable the button
#+END_SRC

#+BEGIN_NOTES
Buttons have a =disabled= value that can be set. When it's
=true= the button appears to be disabled.

When it's set to =false= the button is enabled again.

Load your shopping list page in to the browser, and open the console.

Try these commands. Notice what happens visually to the button when
you disable it. Try clicking on it when it's disabled and see what
it does.

Then enable it, watch the visuals change, and try clicking on it
again.

[Wait]
#+END_NOTES

** Where should we put this code?

#+INCLUDE: "shopping-6.js" :lines "26-49" src javascript -n

#+BEGIN_NOTES
Now that we know how to disable the button, we need to think about
where the code should go.

Here's my current code again. Where in this should we put the code
that's going to control if the button is enabled or disabled?

[Wait]

We need to control the button's visibility every time the user
presses a key.

There are two possibilities -- either the input is empty, or its
not.

If it's empty we should disable the button, and if it's not empty
we should enable the button.

We already have one =if= block for if the input is not empty. So
we can add new code there.

We'll need another =if= block for the case where the input is not
empty.

And we need to find the button.

So go ahead and add code here, immediately after my line 14 that
enables the button.

And add another =if= statement after line 19 that disables the
button if the input is empty.

And you'll need a variable for the button.
#+END_NOTES

** Solution: Disabling the button, variables

#+INCLUDE: "shopping-7.js" :lines "26-30" src javascript -n 26

#+BEGIN_NOTES
I've had to split the code over three slides to show it all.

The first part is the top of the =DOMContentLoaded= listener.

All I've done here is added a third variable, =addItemButton=,
and found the first button in the DOM.

Make sense?

[Wait]
#+END_NOTES

** Solution: Disabling the button, input widget

#+INCLUDE: "shopping-7.js" :lines "40-56" src javascript -n 40

#+BEGIN_NOTES
Jumping ahead to my line 40, and the =keyup= listener for the input
widget I've made two changes.

The first is line 3 of this code. The =if= statement immediately
before means that this code will only run if the input widget is
*not* empty.

So we know that the button should be enabled here. And to enable
the button you set its =disabled= property to =false=.

The second change is lines 10-12. We need to deal with the case
where the input box *is* empty, so I have a second =if= statement
here to deal with that.

Those of you with more programming experience are probably wondering
why I didn't use an =else= clause here. I'm coming to that in a bit,
don't worry.
#+END_NOTES

** Solution: Disabling the button, button widget

#+INCLUDE: "shopping-7.js" :lines "31-39" src javascript -n 31

#+BEGIN_NOTES
Finally, and jumping back up the code, I've been a bit sneaky.

Earlier, I didn't tell you that when the button is clicked to add
an item to the list it should disable itself. This is because
one of the things the button does when it's clicked is empty
out the input wideget (here, on line 34).

But there's no =keyup= event fired when that happens, so the
button has to know to disable itself.

Do you have this bug in your code? Does your button disable itself
after it's clicked?

[Wait]

Fix your code so that it disables the button in all cases, then
add and commit your changes.

[Wait]
#+END_NOTES

* Recap: What have we learned
#+REVEAL_HTML: <div class="leftcol">
- =.focus()= method
- Variable scopes
- Strings with backticks =`=
- String methods
  - =.trim()=
- =.disabled= property
#+REVEAL_HTML: </div>

* Refactoring: =const=

#+BEGIN_NOTES
I mentioned that I wanted to refactor this code, and there are a
few things I want to do and introduce you to.
#+END_NOTES

** Recap: =let=

- =let= declares a variable with a value that can change

#+BEGIN_SRC javascript
let a = 10;
a;            // 10
a = 20;
a;            // 20
let b;        // Variable without initial value
b;            // undefined
b = 30;
b;            // 30
#+END_SRC

#+BEGIN_NOTES
We're familiar with the =let= keyword.

We use it to declare a variable, and optionally give it a value.

We can later change the value in the variable, and use the new
value.

We can also declare a variable that starts out with the
=undefined= value, and then give it a value later.

This is great when the value might legitimately change in the
future.

But what do you do if you know the value should never change?
#+END_NOTES

** Introducing =const=

- =const= declares a variable with a value that can't change
  - We call this a *constant*

#+BEGIN_SRC javascript
const c = 15;
c;            // 15;
c = 20;       // Uncaught TypeError: Assignment to constant
              // variable.

const d;      // Uncaught SyntaxError: Missing initializer
              // in const declaration.
#+END_SRC

#+BEGIN_NOTES
When we know that the value should never change we should use the
=const= keyword instead.

This does a couple of useful things.

First, if the value shouldn't change, and you have a bug in the code
that tries to change the value then Javascript will tell you when that
code runs.

This is much better than if the code silently succeeded by mistake.

Second, it helps communicate your intent to the next programmer
that comes along. Now they know that this variable is not supposed
to change in value.

Third, it allows other tools to spot problems even before the code
runs. WebStorm, for example, will analyse the code and tell you
that you've tried to assign a value to a constant variable as you
are writing the code, which is very helpful in preventing bugs in
the first place.
#+END_NOTES

** Replacing =let= with =const=

- =Edit= > =Find= > =Replace...=
- Replace =let= with =const=

*** Replacing =let= with =const=

#+INCLUDE: "shopping-8.js" :lines "7-25" src javascript

*** Replacing =let= with =const=

#+INCLUDE: "shopping-8.js" :lines "26-30" src javascript

* Refactoring: =else=

#+BEGIN_SRC javascript
if (expression) {
  // Body of the if-statement
}
#+END_SRC

#+BEGIN_NOTES
This is the =if= statement that we've been using so far. We
have the =if= keyword, an expression in parentheses, and then
the body surrounded by curly brackets.

The code in the body is only executed if the expression is true.

But what if we want to do something else if the expression is false?
#+END_NOTES

** The =else= keyword

#+BEGIN_SRC javascript
if (expression) {
  // Code run if expression is true
} else {
  // Code run if expression is false
}
#+END_SRC

#+BEGIN_NOTES
We can use the =else= keyword. This starts immediately after the
closing curly bracket of the =if= statement, and is the keyword,
followed by its own curly brackets, with the code to be run
inside them.

Does this make sense to everyone?

[Wait]
#+END_NOTES

** Exercise: Using the =else= keyword

#+BEGIN_SRC javascript -n
function elseTest(num) {
  if (num < 10) {
    console.log('less than 10');
  } else {
    console.log('bigger than 10');
  }
}
#+END_SRC

#+BEGIN_SRC javascript
elseTest(9);
elseTest(11);
#+END_SRC

#+BEGIN_NOTES
Try this exercise. In the Chrome console type this function, and
then test it with these two arguments.

What's printed?

[Wait]
#+END_NOTES

*** Exercise: Using the =else= keyword                             :exercise:

#+BEGIN_SRC javascript -n
function elseTest(num) {
  if (num < 10) {
    console.log('less than 10');
  } else {
    console.log('bigger than 10');
  }
}
#+END_SRC

#+BEGIN_SRC javascript
elseTest(9);
elseTest(11);
#+END_SRC

#+BEGIN_SRC javascript
elseTest(10);
#+END_SRC

#+BEGIN_NOTES
Now try it with =10= as the argument.

What's printed?

[Wait]

Do you see why?

[Wait]

There are three possible answers to this question, but we've only
covered two of them.
#+END_NOTES

*** Exercise: Using the =else= keyword                             :exercise:

#+BEGIN_SRC javascript -n
function elseTest(num) {
  if (num < 10) {
    console.log('less than 10');
  } else if (num > 10) {
    console.log('bigger than 10');
  } else {
    console.log('same as 10');
  }
}
#+END_SRC

#+BEGIN_SRC javascript
elseTest(9);
elseTest(11);
elseTest(10);
#+END_SRC

#+BEGIN_NOTES
We can have a chain of if/else clauses that test various things

Look at the syntax on line 4 -- as well as the =else= keyword we have
a new =if= statement that checks to see if the number is larger than
10. Finally, on line 6 we have a final =else= that covers all the
other cases.

Try this.

[Wait]
#+END_NOTES

** Exercise: Refactoring with the =else= keyword                   :exercise:

#+INCLUDE: "shopping-7.js" :lines "40-53" src javascript -n 40

#+BEGIN_NOTES
So, lets refactor this bit of code here.

Instead of the two different =if= blocks on line 1 and line 9, replace
the line 9 one with an =else= clause.

Do that, and make sure that program still works as expected.

[Wait]
#+END_NOTES

** Solution: Refactoring with the =else= keyword

#+INCLUDE: "shopping-9.js" :lines "40-51" src javascript -n

#+BEGIN_NOTES
Here's the solution. How did everyone get on with it?

[Wait]

OK, go ahead and add and the commit your changes.

[Wait]

Now, I still don't like this code very much. There are a number of
red flags for it that stand out to me.

I don't expect you to notice any problems -- this is a matter of
taste and experience. But I'm going to walk you through them, and
then refactor them out one by one.

Those problems are:

- Repeated calls to inputBox.value.trim()

Now, we only do this twice in this function, but it's clear that
every time we need the value from the input box we should trim
it.

To make this very clear I'd like to create a constant that contains
the trimmed value from the input box, and use that instead. That
should help make the code a bit clearer as well.

- There are =false= and =true keywords inside an =if= body.

This is a big red flag. =if= statemtents work by evaluting the
expression inside the parentheses to either a true or a false
value.

When you see a literal =true= or =false= inside the body of the
=if= statement, as we have here, that's an indicator that maybe
this =if= block isn't needed, and the value can be assigned
directly.

Don't worry if that's not very clear yet, I'm going to give some
examples.

- Too much nesting.

This bit of code has 3 levels of nesting. There's one for the
outermost function, and then we have two =if= statements nested
inside each other, for three levels in total.

That's not super excessive. But in general, the more levels
of nesting you have the more complicated the code is to understand.
It makes it more difficult for you to glance at it and see what
it's going.

If we can reduce the amount of nesting then we can make the code
simpler and easier to read.

And the simpler and easier to read it is the less chance there
are any bugs.
#+END_NOTES

* Refactoring: Hoisting duplicate code in to a variable

#+INCLUDE: "shopping-10.js" :lines "40-53" src javascript -n 40

#+BEGIN_NOTES
Here I've created a new constant variable called =trimmedValue=
and set it to the trimmed copy of whatever's in the input widget.

Then I use this constant in two places, once in the =if= statement,
and once in the call to =createNewListItem=.

Does this make sense to everyone?

[Wait]

OK, make this change to your code, check that it works, then
add and commit.

IMPORTANT: This doesn't actually work, because the else branch
needs to always be taken.

[Wait]

Now, lets look at these =true= and =false= values inside the
=if= block.
#+END_NOTES

* Refactoring: =false= and =true= inside the =if= block

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC javascript
if (expression) {
  // Body
}
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
let x = 10;
let y = x === 9;
y;                  // false
y = x < 20;
y;                  // true
#+END_SRC
#+REVEAL_HTML: </div>

- Expression must evaluate to either =true= or =false=

#+BEGIN_NOTES
Remember the structure of an =if= block.

In particular, the code inside the parentheses immediately
after the =if= keyword is an expression that must evaluate
to either a true or false value.

We can take the result of an expression and assign it to
a variable.
#+END_NOTES

** Refactoring: =false= and =true= inside the =if= block

#+BEGIN_SRC javascript
const isEmpty = inputBox.value.trim() === '';
#+END_SRC

#+BEGIN_NOTES
This means we could write something like this. If the trimmed
value is the empty string then =isEmpty= will be true.

And if the trimmedValue is not empty then =isEmpty= will be
false.

Does that make sense?

[Wait]
#+END_NOTES


** Refactoring: =false= and =true= inside the =if= block

#+BEGIN_SRC javascript
const isEmpty = inputBox.value.trim() === '';
#+END_SRC

#+BEGIN_SRC javascript
addItemButton.disabled = inputBox.value.trim() === '';
#+END_SRC

#+BEGIN_NOTES
But this is also exactly how we want the value for the
=disabled= property to be calculated.

So there's no need to create a new variable, we can set
the value directly.
#+END_NOTES

** Refactoring: =false= and =true= inside the =if= block

#+INCLUDE: "shopping-11.js" :lines "40-53" src javascript -n 40

#+BEGIN_NOTES
This is what that looks like.

This is not obviously better than just using the literal
=true= and =false= values, right?

Our code is now longer on line 44 and 50, and it's also
duplicated.

Wasn't I just talking about hoisting duplicated code in to
a variable so that the value can be re-used?

Yes I was.

The reason for this step is that it lets us see that this bit of code
in both branches of the =if / else= block is identical. Check, lines
44 and 50 are the same.

Since they're the same, they don't need to be inside the =if / else=
block at all.

And if we remove line 50 to outside the =else= block then we don't
need the =else= either.

Before I show you the resulting code, does that make sense?

[Wait]
#+END_NOTES

** Refactoring: =false= and =true= inside the =if= block

#+INCLUDE: "shopping-12.js" :lines "40-52" src javascript -n 40

#+BEGIN_NOTES
On line 50 I've set the =disabled= property on the =addItemButton=.

This allows me to remove that code from inside the =if= block, and
completely remove the =else= block.

This code does exactly the same thing as the previous code, but it's
a little but shorter and a little bit clearer.
#+END_NOTES

* Refactoring: Nesting

#+INCLUDE: "shopping-12.js" :lines "40-52" src javascript -n 40

#+BEGIN_NOTES
This is our current code. It's definitely better, but I still don't
like the nesting.

This is definitely a matter of taste, but I'd prefer it if we didn't
have =if= blocks inside =if= blocks we can help it.

We can refactor those, but first we need to talk about how we return
from a function.
#+END_NOTES

** Flow of control

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_CENTER
Normal flow of control
#+END_CENTER
#+BEGIN_SRC javascript
function foo() {
  // Do something

  // Do something else
}

// Some code
// ...

foo();

// Some more code
// ...
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_CENTER
Flow of control with an =if=
#+END_CENTER
#+BEGIN_SRC javascript
function foo() {
  // Do something

  if (expression) {
    // Only happens when
    // expression === true
  }

  // Do something else
}

// Some code
// ...

foo();

// Some more code
// ...
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here are two main types of flow of control we've seen so far.

On the left is without an =if= statement. Our code runs, and
we call a function. Control flow jumps in to the function, runs
all the way through, and then jumps back out of the function to
where it left off.

On the right is control flow with an =if= statement. It's very
similar, but in the function there's a chance that some of the
code might not run if the expression is false.
#+END_NOTES

** Returning early from a function

#+REVEAL_HTML: <div class="leftcol">
- =return= keyword allows early return from a function
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
function foo() {
  // Do something

  if (expression) {
    // Only happens when
    // expression === true
    return;
  }

  // Do something else
}

// Some code
// ...

foo();

// Some more code
// ...
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We can use a new keyword, called =return=, to return earlier than
normal from a function.

In this example, if the expression in the =if= statement is true
then the code in the body of the =if= statement will be run, and
then the function stops and control returns to where it was called
from. The code under "// Do something else" is never run in this
case.
#+END_NOTES

** Solution: Returning early from a function

#+INCLUDE: "shopping-13.js" :lines "40-56" src javascript -n 40

#+BEGIN_NOTES
Here's what our function looks like using =if= statements and
returning early.

We still have two =if= statements, but they're no longer nested
inside one another, making the code a bit simpler in my opinion.

The trade off is that function is now a bit longer.

This is a pretty good pattern to follow when writing functions.

Specifically:

- Start with a block of code defines any variables or constants
that you need.

- Then have a block of code that checks to see if the function should
do any work, or if it should return early.

- Finally, have the code that actually does what the function is
supposed to do.

This clearly separates out the different responsibilities of the
function, and reduces the amount of nesting and duplicated code.

Does this make sense? Any questions?

[Wait]

OK, go ahead and make the equivalent change to your =keyup=
handler, test it, add and commit.

[Wait]
#+END_NOTES

** Solution: Returning early from a function

#+INCLUDE: "shopping-13.js" :lines "31-39" src javascript -n 31

#+BEGIN_NOTES
And we can make a very similar change to the click handler for
the button.

Again, we save the trimmed value in to a constant, and perform
an early return if the value is empty.

Any questions on this?

[Wait]

OK, go ahead and make the equivalent change to your =click=
handler, test it, add and commit.

[Wait]
#+END_NOTES

* Refactoring: Before and after
  :PROPERTIES:
  :HTML_CONTAINER_CLASS: smaller
  :END:

#+INCLUDE: "shopping-7.js" :lines "31-55" src javascript

#+REVEAL: split

#+INCLUDE: "shopping-13.js" :lines "31-56" src javascript

* Refactoring: Recap

- =const= to declare constant variables
- =if (...) { ... } else if (...) { ... } else { ... }= blocks
- Returning early from functions
  - =return= keyword
- Refactoring to remove nesting

* TODO JSDoc comments
  :PROPERTIES:
  :TOPICS:   jsdoc
  :END:

** Good practice to comment functions
   :PROPERTIES:
   :REQUIREMENTS: webstorm
   :END:

- Programming is about communication
  - Good comments cover *what*, and *why*
  - The code describes *how*
- Javascript does not have a single standard for comments
  - =JSDoc= is a widely adopted standard
  - IDEs understand JSDoc and do useful things with it

** Sample JSDoc

#+BEGIN_SRC javascript
/**
 * Creates and returns an 'li' element for inclusion in shopping list.
 *
 * @param {string} itemName Name of the item to add to the list
 * @returns {HTMLElement} li element
 */
#+END_SRC

- =/**=
- Function description
- Optionally, more detail about the function
  - Design decisions, links to documents, specifications, etc
- 0-n =@param= entries that describe each parameter
- 0-1 =@return= entry for the return value

#+BEGIN_NOTES
JSDoc comments all start with =/**= (slash, star, star). If you type
that before a function WebStorm will automatically prefill some of
the rest of the material.

The next line starts with a description of the function. Typically
you would try and keep this short -- keep it one line if possible.

If your "brief" description is longer than a line it's an indicator
that the function might be doing too much and needs breaking up in
to smaller functions.

If necessary you can include more information in new paragraphs after
the brief description. Here you can go in to more detail -- maybe
there's a specification you're trying to follow, or a design doc
that describes what the function needs to do. This would be a good
place to link to that information.

If the function takes any parameters then you describe them with
=@param= entries.

Each =@param= entry consists of the type of the parameter that the
function expects, in curly brackets. Here, our function expects that
the =itemName= parameter contains a string.

After that is the name of the parameter. And then a brief description
of what the parameter is for.

Finally, if the function returns a value then there is an =@return=
block that explains the value. This is like an =@param= block, only
without the "name" part -- it goes straight from the type in curly
brackets to the description.
#+END_NOTES

** Exercise: Add this JSdoc
#+BEGIN_SRC javascript
/**
 * Creates and returns an 'li' element for inclusion in the shopping list.
 *
 * @param {string} itemName Name of the item to add to the list
 * @returns {HTMLElement} li element
 */
#+END_SRC

- Add this immediately before your =createNewListItem= function.
- Go to a place where the function is called, and press:
  - =Ctrl-Q= (Windows)
  - =Ctrl-J= (OS X)
- =File= > =Settings= > =Editor= > =General= > =Show quick documentation on mouse move=
- What do you think?
** TODO Followup material on comments and commenting style
- [[https://google.github.io/styleguide/jsguide.html#jsdoc][Google Javascript Style Guide]]

* TODO UI followup work

#+REVEAL_HTML: <div class="leftcol">
- Choose a colour palette
- Header image
- Styling input elements
  - Red border when the input is empty?
- Different fonts and font-sizes
  - A font that looks like handwriting for the list?
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Using icons
  - Font Awesome, trash can icon for delete button
  - Shopping cart icon for "Add item"
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Time for a change of pace.

We've been doing a lot Javascript, and it's been a while since
we touched CSS.

So now you've got some time to add some CSS
#+END_NOTES
* TODO Functionality followup work

- Adding a "Delete all" button
- Handling =document.readyState=
- Adding quantities


* Add a "Delete all" button (or "Clear list")

#+REVEAL_HTML: <div class="leftcol">
- We know
 - How to create a button
 - How to listen for button clicks
 - How to find an element
  - =document.querySelector()=
 - How to delete an element
  - =el.remove()=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- We don't know
 - How to find all elements of a type
 - How to delete all elements of a type
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We want to be able to add a button called "Clear list".

When it's clicked we'll delete all of the list items that have been
added, so the list is empty.

We already know most of how to do this. We can create the button and
listen for clicks on it, and we can find individual elements. But
finding more than one element, or deleting more than element is new.

So lets learn how to do that.
#+END_NOTES

** =document.querySelectorAll()=

- =.querySelector(...);= returns first element
- =.querySelectorAll(...);= returns all elements
- As a =NodeList=

** =NodeList=?

- A collection of nodes in the DOM tree
- Organised as a list of things
- A bit like an array

** Array?
** Non-array variables

#+BEGIN_SRC javascript
let x = 10;
let y = 'This is a string';
let z = document.querySelector('body');
#+END_SRC

#+BEGIN_NOTES
Before we can progress much further though we need to expand our
understanding of Javascript variables and what they can contain.

So far we've been looking at variables as though they contain a
single thing.

That thing might be a number, or a string, or an element, but it's
always been just one thing.
#+END_NOTES

** Arrays of numbers

#+BEGIN_SRC javascript
let a = [1, 2, 3];

a[0];  // 1  (index 0)
a[1];  // 2  (index 1)
a[2];  // 3  (index 2)
a[3];  // undefined
a;     // [1, 2, 3]
#+END_SRC

#+BEGIN_NOTES
Here's how we declare and use an array.

Just like with regular variables we use =let= to declare them, and
we give them a name.

However, because the array variable can contain multiple values
we have to write those values inside square brackets, and separate them
with spaces.

This creates the array with three different values.

We say that each value is at a different *index* in array.

*Indicies* start counting at 0. So the first value in the array is at
index 0, the second value is at index 1, and so on.

To find out what value is in the array at a particular index we write the
name of the array variable, and then we put the index number that we are
interested in inside square brackets.

There should be no spaces between the name of the variable and the square
brackets.

If we try and use an index value that does not contain a value then we get
back the special =undefined= value that we've seen before.

We can also use the whole array, by giving its name. We use this if we want
to pass an array as a parameter to a function, for example.
#+END_NOTES

** Arrays of strings

#+BEGIN_SRC javascript
let b = ['Hello', 'Powercoders'];

b[0];  // "Hello";
b[1];  // "Powercoders";
#+END_SRC

#+BEGIN_NOTES
Values in an array don't have to be numbers, they can be strings too,
as in this example.

Using the index numbers to find out what values are at each index is
identical.
#+END_NOTES

** Arrays of mixed types

#+BEGIN_SRC javascript
let c = [100, 'Basel'];

c[0];  // 100
c[1];  // "Basel"
#+END_SRC

#+BEGIN_NOTES
And you can mix the types of the values in a single array. Here we have an
array where the first element in the array is a number and the second is a
string.
#+END_NOTES

** Index values can be expressions

#+BEGIN_SRC javascript
// let c = [100, 'Basel'];

let x = 1;
c[x];      // "Basel"
c[x - 1];  // 100
#+END_SRC

#+BEGIN_NOTES
Array index values don't have to be numbers -- they can be expressions that
evaluate to numbers as well.

In this example =x= is 1, so if we use that as the index value we get the
second element in the array.

If we substract 1 from x we get 0, which is why the second example returns
the first element in the array (remember, indices always start at 0).
#+END_NOTES

** Arrays have a =length= property

#+BEGIN_SRC javascript
// let c = [100, 'Basel'];

c.length;  // 2

c[c.length - 1];  // "Basel"
#+END_SRC

#+BEGIN_NOTES
Arrays are also objects, which means that they have properties and methods.

The only property we typically care about for an array is the =length=
property. This tells us how long the array is -- how many elements it
contains.

This is always one larger than the last index in the array. So you can use
the length property to find the value of the last element in the array like
this.
#+END_NOTES

** Single-element arrays

#+BEGIN_SRC javascript
let d = [1];

d.length;  // 1
#+END_SRC

#+BEGIN_NOTES
Even if an array is going to start with only a single element you must
still put the element inside square brackets, like this.
#+END_NOTES

** Empty arrays

#+BEGIN_SRC javascript
let e = [];

e.length;  // 0
#+END_SRC

#+BEGIN_NOTES
And it's possible to have completely empty arrays, with no elements. We
declare them like this.
#+END_NOTES

** Modifying arrays

#+BEGIN_SRC javascript
// let e = [];

e[0] = 1;
e[1] = 2;
e;         // [1, 2]
e[0] = 3;
e;         // [3, 2]
e.length;  // 2

e.length = 0;
e;         // []
e.length = 3;
e;         // [undefined, undefined, undefined]
#+END_SRC

#+BEGIN_NOTES
Assigning a value to an array is the same as assigning a value to a
variable, you use the equals sign.

However, you must specify the index in the array that you're assigning
in to.

If you assign in to an index that doesn't already exist, as in the first
two examples, then it's automatically created for you.

If you assign to an index that does exist then the value at that index is
replaced with the new value.

And if you change the length then the array shrinks or grows based on the
new length.
#+END_NOTES

** (some) Array methods

- =push=
- =pop=
- =shift=
- =unshift=
- =join=
- =foreach=
- Check MDN for more

#+BEGIN_NOTES
As objects arrays also have some useful methods, including =push=, =pop=,
=shift=, =unshift=, =join=, and =foreach=.

This isn't a complete list by the way, for that you can check out MDN.

#+END_NOTES
*** =push=

- Adds a new element to the end of the array
- Returns the new length

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.push(0);  // 4
x;          // [1, 2, 3, 0];
#+END_SRC

*** =pop=

- Removes the last element from the end of the array
- Returns the element removed

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.pop();    // 3
x;          // [1, 2]
#+END_SRC

*** =shift=

- Removes the first element from the array
- Returns the element removed

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.shift();  // 1;
x;          // [2, 3]
#+END_SRC

*** =unshift=

- Adds one or more elements to the front of the array
- Returns the new length

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.unshift(4, 5);  // 5
x;                // [4, 5, 1, 2, 3]
#+END_SRC

*** =join=

- Converts elements to strings
- Returns new string, joining the elements

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.join(' ');   // "1 2 3"
x.join(',');   // "1,2,3"
x.join(', ');  // "1, 2, 3"

[1, 2, 3].join(' ');  // "1 2 3"
#+END_SRC

*** =join=

#+BEGIN_SRC javascript
let x = ['Hello', 'Powercoders', 'Basel'];

x.join('');     // "HelloPowercodersBasel"
x.join(' ');    // "Hello Powercoders Basel"
x.join(' - ');  // "Hello - Powercoders - Basel"
#+END_SRC

*** =forEach=

- Calls a function once for each element

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.forEach(function(el) {
  console.log(el + 2);
});

// 3
// 4
// 5
#+END_SRC

** Iterables

- =forEach= *iterates* over the array

#+BEGIN_QUOTE
Iterate: To say or do again and again
#+END_QUOTE

#+BEGIN_QUOTE
Iterable: Something we can iterate over
#+END_QUOTE

#+BEGIN_NOTES
=forEach= is an important example here.

We say that it *iterates* over the array. Our function is called again
and again while there are elements in the array.

This means that our array is an example of an *iterable* -- something that
we can iterate over.
#+END_NOTES

** =NodeList= is not an array...

- ... but it is an *iterable*
- So we can iterate over it with =forEach=
- And we can remove elements with =.remove()=

** Exercise: Removing nodes

- Open the shopping list in the browser
- Add some items
- Open the console
- Find all the list items using =querySelectorAll()=
- Iterate over them using =forEach()=
- Call the =remove()= method in the function

** Solution: Removing nodes

#+BEGIN_SRC javascript
let items = document.querySelectorAll('li');
items.forEach(function(el) {
  el.remove();
});
#+END_SRC

** Adding a "Clear list" button

*** Exercise: Add a button

- Add a button next to the "Add item" button
- Set the =id= to =clear=
- Give the existing button an =id= of =add=

*** Solution: Add a button

#+INCLUDE: "shopping-15.html" :lines "14-21" src html

*** Exercise: Click listener to delete the listitems

- Add a =const= variable, store the "Clear list" button
- Add a click event listener that
 - Finds all the =li= elements
 - Removes them
 - Disables the "Clear list" button

*** Solution: Click listener to delete the listitems

#+INCLUDE: "shopping-15.js" :lines "32-37" src javascript

#+INCLUDE: "shopping-15.js" :lines "70-78" src javascript

*** Exercise: Enable the button when items are added

- Find both places in the code where items are added
- Modify both of them to enable =clearListButton=

*** Solution: Enable the button when items are added

#+INCLUDE: "shopping-15.js" :lines "38-51" src javascript

*** Solution: Enable the button when items are added

#+INCLUDE: "shopping-15.js" :lines "52-69" src javascript

*** Exercise: Disable the button when the page is loaded

- Disable the button when =DOMContentLoaded= fires

*** Solution: Disable the button when the page is loaded

#+INCLUDE: "shopping-15.js" :lines "77-83" src javascript

*** Conditionally disable the button when clicking delete item

- Deleting an item might need to disable the button
 - If there are still items in the list then leave it enabled
 - Otherwise, delete it
- Find the =deleteButton= click handler code
- Modify it to disable the button if there are no =li= elements

*** Hint: Conditionally disable the button when clicking delete item

- How do you find all the =li= elements?
- What property can you check to see if any elements were found?

*** Big hint

- How do you find all the =li= elements?

#+BEGIN_SRC javascript
const listItems = document.querySelectorAll('li');
#+END_SRC

- What property can you check to see if any elements were found?

#+BEGIN_SRC javascript
listItems.length;
#+END_SRC

*** Solution: Conditionally disable the button when clicking delete item

#+BEGIN_SRC javascript
deleteButton.addEventListener('click', function(event) {
  listItem.remove();

  const clearListButton = document.querySelector('button#clear');
  const listItems = document.querySelectorAll('li');

  if (listItems.length === 0) {
    clearListButton.disabled = true;
  } else {
    clearListButton.disabled = false;
  }
});
#+END_SRC

*** Refactor: Remove the =if= statement

#+BEGIN_SRC javascript
deleteButton.addEventListener('click', function(event) {
  listItem.remove();

  const clearListButton = document.querySelector('button#clear');
  const listItems = document.querySelectorAll('li');

  clearListButton.disabled = listItems.length === 0;
});
#+END_SRC

*** Refactor: Remove the variables

#+INCLUDE: "shopping-15.js" :lines "19-25" src javascript

* More loops
** =for= loops

 - =.forEach= is a good way to loop over everything
 - Sometimes you need more control

*** =for= loop syntax

 #+BEGIN_SRC javascript
 for (initial; condition; last) {
   // Loop body
 }
 #+END_SRC

 - =initial= - code executed before the loop starts
 - =condition= - expression evaluated before each loop
  - If true then the loop body runs
 - =last= - code executed at the end of each loop
 - All three separated by =;=

*** =for= loop example

 #+BEGIN_SRC javascript
 for (let i = 0; i < 9; i = i + 1) {
   console.log(i);
 }
 #+END_SRC

 1. Create a variable called =i=, set to =0=.
 2. Is =i= < =9=? If so, run the loop body, else exit
 3. Add =1= to =i=.
 4. Go to step 2.

 #+BEGIN_NOTES
 Creates a variable called =i=

 Checks to see if i < 9. It is, so it runs the body of the loop.

 Then adds one to i.

 The =i= variable's visibility, or scope, is limited to the body
 of the =for= loop.
 #+END_NOTES

*** =i++= syntax

 #+BEGIN_SRC javascript
 i = i + 1;
 #+END_SRC

 #+BEGIN_SRC javascript
 i++;
 #+END_SRC

*** =for= loop example

 #+BEGIN_SRC javascript
 let a = [1, 2, 3, 4, 5, 6, 7, 8];

 for (let i = 0; i < a.length; i = i + 1) {
   console.log(a[i]);
 }
 #+END_SRC

*** What if you wanted to process every second element?

 #+BEGIN_SRC javascript
 let a = [1, 2, 3, 4, 5, 6, 7, 8];

 for (let i = i; i < a.length; i = i + 2) {
   console.log(a[i]);
 }
 #+END_SRC

*** =for= loop for deleting elements

 #+BEGIN_SRC javascript
 clearListButton.addEventListener('click', function (event) {
   const listItems = document.querySelectorAll('li');
   for (let i = 0; i < listitems.length; i++) {
     listItems.item(i).remove();
   });
   clearListButton.disabled = true;
 });
 #+END_SRC

** =while= loops

  #+BEGIN_SRC javascript
  while (expression) {
    // Loop body
  }
  #+END_SRC

  - Executes the loop body while the expression is true
  - Might not execute the expression at all

*** =while= loop example

 #+BEGIN_SRC javascript
 let i = 0;
 while (i < 9) {
   console.log(i);
   i++;
 }
 #+END_SRC

*** =while= loop to delete elements

 #+BEGIN_SRC javascript
 clearListButton.addEventListener('click', function (event) {
   const listItems = document.querySelectorAll('li');
   let i = 0;
   while (i < listItems.length) {
     listItems.item(i).remove();
     i++;
   }
   clearListButton.disabled = true;
 });
 #+END_SRC

 #+BEGIN_NOTES
 Here's how we could delete elements with a =for= loop, just as
 a reminder.
 #+END_NOTES

*** =firstChild= property

 - Elements have a =firstChild= property

 #+BEGIN_QUOTE
 The =.firstChild= property returns the node's first child in
 the tree, or =null= if the node has no children.
 #+END_QUOTE

 - =null= is a false value.

*** =while= loop to delete elements

 #+BEGIN_SRC javascript
 clearListButton.addEventListener('click', function (event) {
   const ul = document.querySelector('ul');
   while (ul.firstChild) {
     ul.firstChild.remove();
   }
 });
 #+END_SRC
** Leaving loops earlier than normal

 - Use =break= to exit a loop sooner than normal

 #+BEGIN_SRC javascript
 let a = [1, 2, 3, 4, 'stop', 5, 6, 7];

 for (let i = 0; i < a.length; i++) {
   if (a[i] === 'stop') {
     break;
   }
   console.log(a[i]);
 }
 #+END_SRC

 #+BEGIN_SRC javascript
 let a = [1, 2, 3, 4, 'stop', 5, 6, 7];

 let i = 0;
 while (i < a.length) {
   if (a[i] === 'stop') {
     break;
   }
   console.log(a[i])
 }
 #+END_SRC

** Restarting loops earlier than normal

 - Use =continue= to restart a loop sooner than normal

 #+BEGIN_SRC javascript
 let a = [1, 2, 3, 4, 'ignore', 5, 6, 7];

 for (let i = 0; i < a.length; i++) {
   if (a[i] === 'ignore') {
     continue;
   }
   console.log(a[i]);
 }
 #+END_SRC

 #+BEGIN_SRC javascript
 let a = [1, 2, 3, 4, 'ignore', 5, 6, 7];

 let i = 0;
 while (i < a.length) {
   if (a[i] === 'ignore') {
     continue;
   }
   console.log(a[i])
 }
 #+END_SRC

** When to use each loop type

 - =forEach=, you need to process everything
   - You won't need to stop part way through the loop
 - =for=, knowing the loop index is important
   - You won't need the index variable elsewhere
 - =while=, everything else
* Speed, and =document.readyState=

- Websites need to be fast
 - Fast to load
 - Fast to interact with
- We notice latency (delays) of 1/10th of a second
 - 1/10th is 100ms (milliseconds)
- Each new file loaded takes time
 - Overhead even if the file is small

#+BEGIN_NOTES
We want websites to be fast.

Roughly, this means two things.

First, the site should be fast to load - the time between you pressing
RETURN on the URL or clicking a link, and the site loading, should be
as small as possible -- the user should see something very quickly.

Second, it should be possible to interact with the site quickly. If the user
has to wait around for the Javascript to load, or images to appear, or things
like that then they will get frustrated with your site. Or worse, they'll get
bored and go and do something else.

When we talk about delays we typically talk about it as *latency*. This is
(roughly) a fancy word for how long something takes to start. If you've
ever had a phone call or video chat with someone thousands of miles away
then you've experienced this -- you think they've stopped talking, so you
start talking, but there's a half second delay, they've started talking
again, and you end up talking over them.

Humans can easily notice latency of a 10th of a second or more.

We normally measure latency in thousanths of a second, or milliseconds.

Every time we need to load a new file as part of our site there's some
overhead involved in loading that file, even if the file is small. We want
to do things to minimise that as much as possible.
#+END_NOTES

** How long is our page taking to load?

#+BEGIN_CENTER
[Network tab for shopping-15.html]
#+END_CENTER

#+BEGIN_NOTES
- Demo the Network tab
- Show how long the HTML takes to load
- Show how long it takes until DOMContentLoaded fires
 - Should be roughly 80ms.
- Big delay that we can reduce
#+END_NOTES

** Loading timeline

#+BEGIN_SRC dot :file timeline1.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
digraph G {
  load_html [label="Load HTML"];
  parse_html [label="Parse HTML"];
  load_css [label="Load CSS"];
  load_javascript [label="Load Javascript"];
  parse_javascript [label="Parse Javascript"];
  finish_html [label="Finish HTML"];
  dom_loaded [label="DOMContentLoaded"];
  js_runs [label="Javascript runs"];

  load_html -> parse_html;
  parse_html -> load_css;
  parse_html -> load_javascript;
  load_javascript -> parse_javascript;
  parse_javascript -> finish_html;
  finish_html -> dom_loaded;
  dom_loaded -> js_runs;
}
#+END_SRC

#+RESULTS:
[[file:timeline1.svg]]

** Loading Javascript asynchronously

- =<script ... async>=

#+BEGIN_NOTES
We can tell the browser that we want the Javascript to be loaded in the
background, at the same time as the rest of the HTML is being processed.

We say that the the Javascript is being handled *asynchronously*.

To do that, we add the =async= attribute to the =script= element in the
HTML.

[Demo this, with the inspector, show the difference in =DOMContentLoaded=
time]
#+END_NOTES

** Loading timeline now

#+BEGIN_SRC dot :file timeline2.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
digraph G {
  load_html [label="Load HTML"];
  parse_html [label="Parse HTML"];
  load_css [label="Load CSS"];
  load_javascript [label="Load Javascript"];
  parse_javascript [label="Parse Javascript"];
  finish_html [label="Finish HTML"];
  dom_loaded [label="DOMContentLoaded"];
  js_runs [label="Javascript runs"];

  load_html -> parse_html;
  parse_html -> load_css;
  parse_html -> load_javascript;
  parse_html -> finish_html;
  load_javascript -> parse_javascript;
  parse_javascript -> js_runs;
  finish_html -> dom_loaded;
  dom_loaded -> js_runs;
}
#+END_SRC

#+RESULTS:
[[file:timeline2.svg]]

#+BEGIN_NOTES
So now the operations that are happening look more like this.

But there's a problem here -- the =DOMContentLoaded= event might fire before
we've had a chance to listen to it.

The event only fires once, if we're not listening for it when it fires we
have a problem.

[Demo the problem in the page -- none of the UI should work]
#+END_NOTES

** Race Conditions

- This is called a *Race Condition*
- Two things are *racing* to finish
- Depending on which one wins changes the result

#+BEGIN_NOTES
We call this a *race condition*.

We have two things that need to finish -- loading the HTML, and running the
Javascript.

They are *racing* to finish.

Sometimes loading the HTML will finish first -- it wins the race. If that
happens then the =DOMContentLoaded= event will fire before the Javascript
runs, and we see this problem.

Other times the Javascript might win the race, and run first. If that happens
then everything appears to be fine.

Race conditions can be difficult to track down, because the problem might
not occur all the time. So you need to have a good mental model of what the
code is doing at all times in order to be able to predict things like this.
#+END_NOTES

** Fixing the race with =document.readyState=

- =document.readyState= property (string)
- Describes the *loading* state of the page
- 3 possible values
  - =loading=
  - =interactive=
  - =complete=

** Using =document.readyState=

#+BEGIN_SRC javascript
/**
 * Set up event listeners and configure initial element state when the
 * DOM is ready.
 */
function domContentLoaded() {
  // Code that needs to interact with the DOM
}

if (document.readyState === 'loading') {
  // DOMContentLoaded has not fired yet.
  document.addEventListener('DOMContentLoaded', function(event) {
    domContentLoaded();
  });
} else {
  // DOMContendLoaded has fired.
  domContentLoaded();
}
#+END_SRC

#+BEGIN_NOTES
In general terms, this is how we can use =document.readyState=.

We have to put our set up code in to a function, instead of being an
anonymous function here. This is because we need to call it from two places.

It's still only going to be called once, but we can't predict when it's
going to be called.

This is the new =domContentLoaded= function.

Then we use an =if= statement to decide how to call our function.

If the document is still loading then we know that =DOMContentLoaded= hasn't
fired yet, and we should use an event handler.

But if the =readyState= is not =loading= then we know that the DOM is ready
and we can run our code directly.

Go and make this change to your code, and verify that everything works as
you expect.
#+END_NOTES

* Add quantities

- Allow the user to say how much of a thing to buy
  - 6 eggs
  - 1 litre milk
  - 500g flour

** Quantity: HTML changes

- Add a new =input= element for quantity
- What problems do you see?

*** Problems

- Focus is wrong
  - How do you fix this?
- Input widget is very wide
  - How do you fix this ([MDN input size])
- Quantity is not cleared when adding items
  - How do you fix this?

*** Fixes

#+BEGIN_NOTES
Show shopping-18.html and shopping-18.js
#+END_NOTES

** Quantity: Using the new quantity

- =createNewListItem= needs a new =quantity= parameter
  - If the =quantity= parameter is not =''=
    - Create a new text node
      - Set the content to =' '= (single space)
      - Append to the list item
    - Create a new =span=
      - Set the =span= content to =(= + the quantity + =)=
      - Append to the list item
  - Don't forget the JSDoc!
- Modify calls to =createNewListItem=
  - Pass a value for the new parameter

** Solution: Pass param to =createNewListItem=

#+INCLUDE: "shopping-19.js" :lines "1-9" src javascript

#+BEGIN_NOTES
We change =createNewListItem= so that it takes a second parameter,
the quantity string.

Since we're changing the paramaters the function takes we have to
change the JSDoc for the function as well.
#+END_NOTES

** Solution: Add quantity to list item

#+INCLUDE: "shopping-19.js" :lines "26-36" src javascript

#+BEGIN_NOTES
This is later in the code.

We start with the code that appends the text of the list item.

And here, below, is the code that appends the delete button. These
are exactly as before.

The new code is here in the middle.

We check to see if the quantity parameter is the empty string. If it
is then there's nothing to do.

If it contains text then we create a text node with that text and
append it, and then create a span for the quantity value. The
span's =innerText= property is updated to display the information,
and then it's added to the DOM as normal.
#+END_NOTES

* Objects

** Problem: Loosely-coupled data

- Each list item has two values
  - Name of the thing
  - Quantity
- But we have to pass them around separately
- Better if we could bundle them together in some way
- Objects!

** Already seen objects

- E.g., Elements
  - Bundles of data, different properties
    - =id=, =value=, =innerText=, etc
 - Different methods
  - =querySelector()=, =querySelectorAll()=, etc
  - With a single name

** Object terms

- *class* or *prototype* descibes an object
 - A bit like a blueprint, or general instructions
- *instance* is a specific object created from a class
- Objects have
  - *properties* -- data that is specific to the object
  - *methods* -- functions that work on the object's data

** Object example: tables

- Table has 4 legs, flat top, no back
  - That's the *class*
- The specific tables in this room are *instances* of that
- Other tables elsewhere are also *instances* of the table *class*

** Multiple instances of the same class

- Once we have a class we can create multiple instances
- =item1= and =item2= are *instances* of the =ShoppingListItem= class

#+BEGIN_SRC javascript
const item1 = new ShoppingListItem('Eggs', '6');
const item2 = new ShoppingListItem('Flour', '500g');

item1.name;  // "Eggs" (first instance of the object)
item2.name;  // "Flour" (second instance of the object)
#+END_SRC

#+BEGIN_NOTES
This is what we're working towards.

Our object's class is going to be called =ShoppingListItem=. Note that this is the UpperCamelCase -- it's very common to use that for class names.

Our object is going to have two properties, one for the item name, and one for the quantity.

To create an *instance* of the object we use the =new= keyword, and the name of the object. We pass in two parameters, one for the name of the object, and one for the quantity.

Our object is going to have two properties that let us retrieve the item's name and quantity. And it will have one method, that generates the HTML elements to show the item in a list.

This is the goal. Let's look at how we get there.
#+END_NOTES

** An object for shopping list items

- Each list item has two values
  - Name of the thing
  - Quantity

#+BEGIN_NOTES
Our shopping list items are quite simple at the moment, they contain two values, the name of the item, and the quantity we want.
#+END_NOTES

** Simple object data structures

#+BEGIN_SRC javascript
const item = {   // item variable contains an instance of the object
  name: 'Eggs',
  quantity: '6'
};

item.name;       // 'Eggs'
item.quantity;   // '6'
#+END_SRC

#+BEGIN_NOTES
This is how we start to declare that a variable contains an object.

This is the simplest type of object -- it doesn't have any methods, it just has properties.

To declare an object like this, we start and end the object's value with curly brackets.

Inside the object we write the name of each property, a colon, and the value that we want that property to have.
#+END_NOTES

*** Object *members*

#+BEGIN_SRC javascript
const objectName = {
  memberName1: memberValue1;
  memberName2: memberValue2;
  memberName3: memberValue3;
  // ...
};
#+END_SRC

#+BEGIN_NOTES
The technical term for these things, whether they are properties or methods, is *members* of the object.
#+END_NOTES

*** Values

#+BEGIN_SRC javascript
const person = {
  name: 'Nik',
  interests: ['Teaching', 'Skiing'],
  greet: function() {
    console.log(`Hello ${this.name}`);
  }
};

person.name;          // 'Nik'
person.interests[0];  // 'Teaching'
person.greet();       // 'Hello Nik'
#+END_SRC

#+BEGIN_NOTES
The value of an object's member can be anything that we've seen so far. So here's a slightly more complex object with three members.

The first member is called =name=, and its value is a simple string.

The second member is called =interests=, and its value is an array of strings.

The third member is called =greet=, and its value is an anonymous function. Don't worry about the special =this= in there just yet, we're going to come to that.

To access the values in the members we use the dot-notation that we've seen in many places already. We write the instance's name, a dot, and then the member name. We get back the value.

if the value is an array then we can use square brackets to access the item at a particular index in the array.

And if the value is a function then we can call it by using parentheses exactly as we've called every other function and method so far.
#+END_NOTES

*** =this=

#+BEGIN_SRC javascript
const person = {
  name: 'Nik',
  interests: ['Teaching', 'Skiing'],
  greet: function() {
    console.log(`Hello ${this.name}`);
  }
};
#+END_SRC

- Inside an object, =this= refers to the object
- Allows code in an object to reference itself

#+BEGIN_NOTES
Notice how the code in the =greet= function uses the =this= keyword.

Code inside an object can refer to other members  in the same object. To do so it uses the special keyword =this=, followed by a dot, and then the member name.

So in the code here, =this.name= means "The value of the =name= member in the current object.".
#+END_NOTES

*** =this=

#+BEGIN_SRC javascript
const person = {
  name: 'Nik',
  interests: ['Teaching', 'Skiing'],
  greet: function() {
    console.log(`Hello ${this.name.first}`);
  }
};

person.greet();                  // 'Hello Nik'
person.name = 'Nicholas';
person.greet();                  // 'Hello Nicholas'
#+END_SRC

#+BEGIN_NOTES
If we change the value of the property then accessing it via =this= in the code ensures that we always get the correct value.

In the example here the =greet()= function uses it to ensure that when the =name= property is changed it uses the correct value.
#+END_NOTES

*** Nested objects

#+BEGIN_SRC javascript
const person = {
  name: {
    first: 'Nik',
    last: 'Clayton',
  },
  interests: ['Teaching', 'Skiing'],
  greet: function() {
    console.log(`Hello ${this.name.first}`);
  }
};

person.name.first;    // 'Nik'
person.name.last;     // 'Clayton'
person.interests[0];  // 'Teaching'
person.greet();       // 'Hello Nik'
#+END_SRC

#+BEGIN_NOTES
Objects can contain other objects.

If that happens we say that the objects are *nested* inside each other.

Here, the value of the =name= member is another object, with two members, =first= and =last=.

We use the same dotted notation to access them.

Notice how the code in the =greet= method has had to be changed because of this.
#+END_NOTES

*** Bracket syntax

#+BEGIN_SRC javascript
const person = {
  name: {
    first: 'Nik',
    last: 'Clayton',
  },
  interests: ['Teaching', 'Skiing'],
  greet: function() {
    console.log(`Hello ${this.name.first}`);
  }
};

person['name']['first'];    // 'Nik'
person['name']['last'];     // 'Clayton'
person['interests'][0];     // 'Teaching'
person['greet']();          // 'Hello Nik'
#+END_SRC

#+BEGIN_NOTES
There's another syntax for access member values. Instead of writing the names and using dots, you use square brackets, and write the name of the member as a string inside the square brackets.

Can anyone suggest why we would want to do this?
#+END_NOTES

*** Bracket syntax and variables

#+BEGIN_SRC javascript
const person = {
  name: {
    first: 'Nik',
    last: 'Clayton',
  },
  interests: ['Teaching', 'Skiing'],
  greet: function() {
    console.log(`Hello ${this.name.first}`);
  }
};

const property = 'interests';

person[property];  // ['Teaching', 'Skiing']

person.property;   // DOES NOT WORK
#+END_SRC

#+BEGIN_NOTES
Sometimes the name of the property you want to access is stored in a variable. If that's the case then you need to use the square bracket syntax with the variable.

That's what we do here.

You can't use the dotted syntax with a variable, it won't work.
#+END_NOTES

*** Assigning values

#+BEGIN_SRC javascript
const person = {
  name: {
    first: 'Nik',
    last: 'Clayton',
  },
  interests: ['Teaching', 'Skiing'],
  greet: function() {
    console.log(`Hello ${this.name.first}`);
  }
};

person['name']['first'];    // 'Nik'
person.name.first = 'Nicholas';
person.name.first;          // 'Nicholas'
person['name']['first'] = 'Nik';
person.name.first;          // 'Nik'
#+END_SRC

#+BEGIN_NOTES
You can assign values to member just like assigning values to variables.

In this example we mix and match the square-bracket and dotted notation just to show that we can.
#+END_NOTES
*** =const= ?

#+BEGIN_SRC javascript
const person = {
  name: {
    first: 'Nik',
    last: 'Clayton',
  },
  interests: ['Teaching', 'Skiing'],
  greet: function() {
    console.log(`Hello ${this.name.first}`);
  }
};

person.name.first = 'Nicholas';  // Works

person = {                       // DOES NOT WORK
  name: { ... }
  ...
};

#+END_SRC

#+BEGIN_NOTES
Notice how we declare that =person= is a constant, with =const=.

This *does* *not* mean that we can't change the value of its members -- we can.

It does mean that after we have declared =person= to contain one object, we can *not* assign it a completely different object.
#+END_NOTES

*** Javascript Object Notation (JSON)

#+BEGIN_SRC javascript
const person = {
  name: {
    first: 'Nik',
    last: 'Clayton',
  },
  interests: ['Teaching', 'Skiing'],
  greet: function() {
    console.log(`Hello ${this.name.first}`);
  }
};
#+END_SRC

#+BEGIN_NOTES
This way of writing complex data structures has become popular in the industry, and you will see it referred to as JSON, or Javascript Object Notation.

Lots of languages use this notation as a way of passing data around, not just Javascript.
#+END_NOTES

** Single variable, complex structure

#+BEGIN_NOTES
As you've seen, objects allow us to have a single variable with an arbitrarily complex structure.
#+END_NOTES

** Modeling shopping items as objects

#+BEGIN_SRC javascript
const item = {
  name: /* item name value goes here */,
  quantity: /* item quantity goes here */,
}
#+END_SRC

#+BEGIN_NOTES
To model our shopping list items as objects we need to think about what members they should have.

Our items are quite simple at the moment, they only contain two values that we care about -- one is the item's name, and the other is the quantity of the item that we want to buy.

So we can model that as a simple object ike this.

Make sense?
#+END_NOTES

** Changing our code to use objects                                :exercise:

- Create the object before calling =createNewListItem=
  - We do this in two places in the code
- Pass the object as the only parameter to =createNewListItem=
  - Again, in two places
- Modify =createNewListItem=
  - Change the parameters it receives
  - Access the members of the passed in object
  - Update the documentation

#+BEGIN_NOTES
Unfortunately this is not the sort of the change that we can make incrementally in our code. Because the data flows from one part of the code to the other, every part of the code that touches this data needs to be updated to handle the new data structure -- our object.

These are the steps that we're going to take.

[Run through the steps]

 We're going to do this step by step together.
#+END_NOTES

*** Create the object before calling =createNewListItem=           :exercise:

- Find the two places in your code where you call =createNewListItem=
- Create an object with the data we need
  - Call it =item=
  - Two members
    - =name=
    - =quantity=
  - Give the members sensible values

*** Solution: Create the object before calling =createNewListItem=

#+BEGIN_SRC javascript
// ...

const item = {
  name: trimmedValue,
  quantity: quantityBox.value
};

shoppingList.appendChild(
    createNewListItem(trimmedValue, quantityBox.value));

// ...
#+END_SRC

*** Pass the object to =createNewListItem=

- Use the new object as the only parameter to =createNewListItem=

*** Solution: Pass the object to =createNewListItem=

#+BEGIN_SRC javascript
// ...

const item = {
  name: trimmedValue,
  quantity: quantityBox.value
};

shoppingList.appendChild(createNewListItem(item));

// ...
#+END_SRC

*** Modify =createNewListItem= to receive the object               :exercise:

- Change the definition of =createNewListItem=
  - Remove the existing parameters
  - Add a new =item= parameter
  - Update the JSDoc

*** Solution: Modify =createNewListItem= to receive the object

#+INCLUDE: "shopping-20.js" :lines "1-8" src javascript

#+BEGIN_NOTES
There are two changes here.

The first is on the line where we define the function. This used to receive two parameters, =name= and =quantity=. Now it only needs to receive one, our object.

We've also had to the change the JSDoc and update it to reflect that there's only one parameter, and give it's name.

We've also had to change the *type* information in the JSDoc.

We always write the type information inside curly brackets, so that's what the outermost ones are doing here.

When we're passing in an object like this we then write more curly brackets, because it's an object, and then we write the name of each member and it's expected type. Here our object has =name= and =quantity= members, and they're both strings, so that's what we write in the JSDoc.
#+END_NOTES

*** Modify =createNewListItem= to use the object                   :exercise:

- Adjust the code to use the values in the object's properties
  - =item.name=
  - =item.quantity=

#+BEGIN_NOTES
=createNewListItem= uses the name and quantity information in a few places.

Previously they came in as separate parameters.

Now it's passed in as one object. So update the code to get the information from the members of the object that's passed in.
#+END_NOTES

*** Solution: Modify =createNewListItem= to use the object

#+iNCLUDE: "shopping-20.js" :lines "10-12" src javascript

#+INCLUDE: "shopping-20.js" :lines "27-33" src javascript

#+BEGIN_NOTES
Here are the two places that I had to update in my code.

The first is the block of code that creates the span that's going to contain the item name and sets its value.

This code used to use the =name= parameter, now it has to use the =name= member of the =item= parameter.

And then the second block of code is the bit that sets the quantity value (if present), This used to use the =quantity= parameter, now it uses the =quantity= member of the =item= parameter.
#+END_NOTES

*** Double check everything still works

- And commit

#+BEGIN_NOTES
With those changes made everything should still work.
#+END_NOTES

*** What did we do?

- Created an object to model our shopping list item
  - Two members, =name= and =quantity=
- Modified the code to create this object
- Passed the object as a parameter to =createNewListItem=
- Modified =createNewListItem= to receive the object
  - And the docuentation
- Modified =createNewListItem= to use the object
- Had to do this as one change
  - Individual changes wouldn't work, because of the data flows

** Recap: Object terms

- Objects are a type of *data structure*
  - Arrays are another type of data structure
- Each object represents a new *type*
- Object type is defined by a *class*
- An object created from a class is an *instance* of that class
  - We say it has been *instantiated*
- Objects have *properties* (data) and *methods* (functions)
  - Generic term: *members*

** Recap: Data-only objects

- Objects can bundle related data under one name

#+BEGIN_SRC javascript
const person = {  // 'person' is an instance of the object
  name: 'Nik',
  interests: ['Teaching', 'Skiing']
};
#+END_SRC

** Recap: Objects with methods

- Objects can contain *methods*
- Within the method, =this= refers to the current instance

#+BEGIN_SRC javascript
const person = {
  name: 'Nik',
  interests: ['Teaching', 'Skiing'],
  about: function() {
    console.log(`${this.name} likes:`);
    console.log(this.interests.join(', '));
  }
};

person.about();  // 'Nik likes:'
                 // 'Teaching, Skiing'
#+END_SRC
* Constructors
** Constructing objects, object literals

#+BEGIN_SRC javascript
const item1 = {
  name: trimmedValue,
  quantity: quantityBox.value,
}

const item2 = {
  name: trimmedValue,
  quanlity: quantityBox.value,
}
#+END_SRC

#+BEGIN_NOTES
The code so far creates objects using an *object literal* value.

This is no different than the ways we've been creating strings or numbers -- we write the literal value that we want the variable to have.

However, this can get tiresome when we have objects with a complex structure. It's more typing (imagine we had to create lots of different objects like this) and there's plenty of opportunity to make mistakes -- for example, by accidentally misspelling the name of a property.

It would be nice if we could automate this in some way.

For example, in this code here we create two objects of the same type. We have to repeat the names of the members, which is always a risk. What if you make a typo?

For example, the way I've done here, where I've mis-spelled quantity.

To fix that we use special functions, called *constructors*.
#+END_NOTES

** Constructor functions

- *Constructor* is any function that creates ("constructs") an  object
- Name starts with a capital letter, by convention
- Called using the =new= keyword
- Inside constructor, =this= means the object being created

#+BEGIN_NOTES
When we create an object, the technical term for it is *constructing* the object.

So we call functions that create objects *constructor* functions.

By convention, these function names always start with a capital letter, and the name of the function is also the name of the type of the object we are constructing.

We call these functions slightly differently, using the =new= keyword.

Inside the function, the =this= keyword refers to the object we're constructing.

Let's take a look.
#+END_NOTES

*** Writing a constructor

#+BEGIN_SRC javascript
function Person(first, last, interests) {
  this.name = {
    first: first,
    last: last
  };
  this.interests = interests;
  this.greet = function() {
    console.log(`Hello ${this.name.first}`);
  };
}

const nik = new Person('Nik', 'Clayton', ['Teaching', 'Skiing']);

nik.first.name;   // 'Nik'
nik.greet();      // 'Hello Nik'

const chris = new Person('Christian', 'Hirsig', ['Powercoders']);
chris.interests;  // ['Powercoders']
chris.greet();    // 'Hello Chris'
#+END_SRC

#+BEGIN_NOTES
Here's  a re-write of some of the examples from earlier.

Instead of using an object literal for our person object, we've created a constructor function, called =Person= -- notice the capital letter.

This also means that the type of our object is also =Person=.

Our constructor function takes three parameters that correspond to the first and last names, and the interests.

Inside the body of the function we can then construct the object.

=this.name= is itself going to be an object, with =first= and =last= members that we initialise to the values passed in from the parameters.

=this.interests= is initialised in a very similar way.

And we create the =greet()= method by assinging to the member as well.

Once we have this function we can start constructing objects using it. Remember, we have to use the =new= keyword to do this.

So here I construct a new instance of the =Person= object and initialise it to some information about myself, and check that the object behaves the way I expect.

And then I create another instance of the Person object and initialise it to information about Christian.

These are completely distinct objects -- I can change the values in one and it won't affect the other.
#+END_NOTES

** Writing a constructor for a shopping list item                  :exercise:

#+BEGIN_SRC javascript
let item = new ShoppingListItem('apples', '6');
item.name;      // Should print 'apples'
item.quantity;  // Should print '6'
#+END_SRC

#+BEGIN_SRC javascript
/**
 * You write the JSDoc that goes here
 * @constructor
 */
function ShoppingListItem(name, quantity) {
  // You write the code that goes here
}
#+END_SRC

#+BEGIN_NOTES
Lets create a constructor function for our shopping list items.

The code at the top is what we want to be able to do when we've written the constructor -- that's our goal.

Below that I've written a skeleton of the constructor function for you to put in your Javascript file -- you have to fill in the missing information.

I've decided that the name of our type is going to be =ShoppingListItem=, so that's the name of the function.

All you need to do is write this out, complete the documentation, and fill in the function body.

You know you've got something that works when you can reload the page in the browser and type the three lines of code at the top  and see the expected result.
#+END_NOTES
** Solution: Writing a constructor for a shopping list item

#+INCLUDE: "shopping-21.js" :lines "39-50" src javascript

#+BEGIN_NOTES
Here's the solution.

Looking at the code first, it's straightforward -- we just take the values in the two paramaters passed in to the function, and assign them to members in the object with the same names, using the =this.= (this dot) syntax that we've seen before.

The documentation should be straightforward as well. You might have written something slightly different -- the important thing is that you have at least one sentence that describes what the constructor does, and two =@param= entries that describe the parameters that the function receives.

The =@constructor= indicates that this is a constructor. Remember, Javascript doesn't care if this is there or not, this is just to make the code easier for us to read.

And because this is a constructor there's no =return= statement or an =@returns= tag in the JSDoc.
#+END_NOTES

** Exercise: Using a constructor in our code                       :exercise:

#+BEGIN_SRC javascript
const item = {
  name: trimmedValue,
  quantity: quantityBox.value
};
#+END_SRC

- Replace this code with code that calls the constructor using =new=

#+BEGIN_NOTES
Here we have the code we've just written that creates an object literal, using the curly brackets.

You have this code in two places in your existing code.

Now we can replace this, and initialise the =item= variable by calling the constructor using =new=.

Make this change to your code, and check that everything still works.
#+END_NOTES

** Solution: Using a constructor in our code

#+INCLUDE: "shopping-21.js" :lines "62-72" src javascript -n 62

#+BEGIN_NOTES
There are two places in the code where a =ShoppingListItem= object is created. Here's the first, it's the =click= listener when the user clicks the add-item button.

In my code it's on line 69, your line numbers might be different.

Now =item= is initialised by calling the =ShoppingListItem= constructor. Remember, you have to use the =new= keyword here.

#+END_NOTES

** Solution: Using a constructor in our code

#+INCLUDE: "shopping-21.js" :lines "79-94" src javascript -n 79

#+BEGIN_NOTES
And here's the second place, in the =keyup= event listener.

For me, it was here on line 91 -- again, your line number might be different.
#+END_NOTES

** Alternative code

#+BEGIN_SRC javascript
shoppingList.appendChild(createNewListItem(
    new ShoppingListItem(trimmedValue, quantityBox.value)));
#+END_SRC

#+BEGIN_NOTES
We don't need the =item= variable, since we only use it once.

So a more concise way to write this code would be create the new =ShoppingListItem= object when we call =createNewListItem=, like this.

As we've done before, you read this inside-out to understand what's going on.
#+END_NOTES

** Exercise: Change the JSDoc                                      :exercise:

- Our object's type has changed
  - Was ={{name: string, quantity: string}}=
  - Now: ={ShoppingListItem}=
- Change the JSDoc in =createNewListItem= accordingly

** Solution: Change the JSDoc

#+INCLUDE: "shopping-21.js" :lines "1-8" src javascript

#+BEGIN_NOTES
This is a simple change to the JSDoc for the =@param= entry.

Notice how we've just created our own type. Just like Numbers, or Strings, or
HTMLElements, or any other type we've seen, ShoppingListItem is now its own type in the code.
#+END_NOTES

** Recap: Constructors

- *Constructor* functions create ("construct") objects
- Name of the constructor names the type of the object
  - We can create our own types!
- Don't return a value
- Use =this= in the constructor to set the object's properties

#+BEGIN_SRC javascript
function Course(loc, count, teacher) {
  this.location = loc;
  this.numStudents = count;
  this.teacher = teacher;
}

let nik = new Person('Nik', 'Clayton', ['Teaching']);
let basel = new Course('Basel', 20, nik);

basel.teacher.name.first; // 'Nik'
basel.numStudents;        // 20
#+END_SRC

* Replacing =createNewListItem= with a method

- =createNewListItem= is a regular function
  - We pass it a parameter for the item
  - It returns a DOM fragment
- Lets make it a method
  - Encapsulate all our list item code in the object
  - Going to call it =toListItem=

#+BEGIN_NOTES
Lets look at our =createNewListItem= function.

At the moment this is a regular, standalone function.

We pass it a single parameter -- an instance of our
ShoppingListItem object -- and it generates and returns a DOM
fragment to represent that object.

We should make that a method.

That way, all of our code for creating and figuring out how to
display a single list item is in one place.

We say that the functionality is *encapsulated* in the object.
#+END_NOTES

*** Goal

- What we have:

#+BEGIN_SRC javascript
const item = new ShoppingListItem(trimmedValue, quantityBox.value);

shoppingList.appendChild(createNewListItem(item));
#+END_SRC

- What we want:

#+BEGIN_SRC javascript
const item = new ShoppingListItem(trimmedValue, quantityBox.value);

shoppingList.appendChild(item.toListItem());
#+END_SRC

#+BEGIN_NOTES
Here's where we want to be.

At the top is our current code.

At the bottom, notice how we're calling a method on the item to
create the DOM fragment -- our item *knows* how to convert itself
into a DOM fragment.

This is a small change, but very significant.
#+END_NOTES

*** One way -- put the code in the constructor

#+BEGIN_SRC javascript
function ShoppingListItem(name, quantity) {
  this.name = name;
  this.quantity = quantity;
  this.toListItem = function() {
    // About 30 lines of code here
  }
}
#+END_SRC

#+BEGIN_NOTES
This is one way to do it -- we could write the function inside the constructor. This is how I showed you the =greet= function earlier when we were playing around with the =Person= object.

However, this is not ideal.

For one thing, our function to create the list items is about 30 lines long. That would bloat the constructor and make it harder to see what else the constructor is doing.

Remember, we're trying to make sure that our code is readable.

It also adds an additional level of indentation -- the code in our =toListItem= method would be indented one more level than normal, which is another red flag to look out for when thinking about code complexity.

Fortunately, there's another way that we can attach methods to our object, called the object's *prototype*.

#+END_NOTES
*** The object =prototype=

- All objects of the same type share a blueprint
  - Or =prototype=
- Prototype describes the properties and methods
- Change the prototype, change all objects of that type

#+BEGIN_NOTES
Imagine you're trying to build three identical houses.

You have a blueprint for the house, and you use the blueprint to
carefully build three identical houses.

Objects in Javascript are a bit similar. Every type of object has
a blueprint, and when the object is constructed the blueprint is
examined to figure out what properties and methods the object
should have.

The Javascript word for this blueprint is =prototype=.

So we say that an object's prototype determines what properties and
methods it has.

If you have the prototype for a particular type of object, all objects
that are that type get the change.
#+END_NOTES

*** =prototype= is a property                                     :exercise:

#+BEGIN_SRC javascript
const x = 10;      // Number, with value 10
const y = 'hello'; // String, with value 'hello'

document;   // HTMLDocument type
#+END_SRC

- Try:
  - =Number.prototype;=
  - =String.prototype;=
  - =Array.prototype;=
  - =Document.prototype;=
  - =ShoppingListItem.prototype;=

#+BEGIN_NOTES
[Debug shopping-21.js for this]

So far, when we've been looking at types, there's always been a value
attached, normally as part of a variable.

So in the two examples at the top we can say that =x= and =y= are
both variables. =x= contains a =Number= with the value =10= and =y=
contains a =String= with the value =hello=.

We're used to objects having properties and methods that we can call,
but types have them as well.

We can inspect the value of a type's =prototype= property the same way
that we inspect the property of a value inside a variable. However,
instead of writing a variable name, a dot, and then the property name
we write the type's name (which will almost certainly start with a
capital letter), a dot, and then the property name.

So now we can explore a bit in the console.

[Demo this, debug shopping-21.js to get a ShoppingListItem]
#+END_NOTES

*** Adding a method to an object

#+BEGIN_SRC javascript -n
ShoppingListItem.prototype;

let item = new ShoppingListItem('apples', '6');
item.hello();  // Uncaught TypeError: item.hello is not a function

ShoppingListItem.prototype.hello = function() {
  return 'hello';
};

item.hello();  // Returns 'hello'

ShoppingListItem.prototype;
#+END_SRC

#+BEGIN_NOTES
Here's how we add a method to an object.

On the first line we print the prototype, just to check that there's no =hello= property defined.

Then we create a new item, and try and call a method named =hello=.

This doesn't work, we get an error.

On lines 6 through 8 we change the value of the =prototype= property. We create a new sub-property, called =hello=, and we assign it a function that just returns a string.

On line 10 we call that function as a method, and because we've changed the prototype this now works.

On the last line we check the value of the prototype property, and can see that it's changed.

Notice how, once we change the prototype, all objects of that type see the change immediately -- we create =item= on line 4 and changed the prototype on line 6, after we created it. But the change affects all objects of that type, even ones we have already created.

This is different to our building-a-house-with-blueprints idea from earlier. If you have to build three houses from a blueprint, build the first two, and then change the blueprint before you build the third house, the first two houses don't magically get the changes -- they've already been built.

Javascript is different -- if you change something on an object's prototype then *all* objects that use prototype, even ones you've already constructed, will get the change.
#+END_NOTES

*** Methods can take parameters like functions

#+BEGIN_SRC javascript
ShoppingListItem.prototype.hello = function(name) {
  return `hello, ${name}`;
};

item.hello('Basel');  // Returns 'hello, Basel'
#+END_SRC

#+BEGIN_NOTES
Methods are just functions that are attached to the prototype, so they can take parameters just like regular functions can.
#+END_NOTES

*** The special =this= variable

- Inside a method, =this= refers to the current instance

#+BEGIN_SRC javascript -n
ShoppingListItem.prototype.details = function() {
  return `There are ${this.quantity} ${this.name}`;
}

const item1 = new ShoppingListItem('apples', '6');
const item2 = new ShoppingListItem('bananas', '10');

item1.details();  // "There are 6 apples"
item2.details();  // "There are 10 bananas"
#+END_SRC

#+BEGIN_NOTES
Every function that's acting as a method has a special variable automatically available to it called =this=. Inside the body of the method, =this= contains whatever object the method was called on.

Lets look at this example. On the first three lines we create a new method called =details=. This method returns a single string that contains the quantity and name of the item.

On lines 5 and 6 we create two instances of this object, with different values.

On line 8 we call the =details= method. Inside this method, the special =this= variable is going to refer to =item1=. So it prints =There are 6 apples=.

On line 9 we call the =details= method again, but on the =item2= object. Inside the =details= method =this= is going to refer to =item2=.

We've seen this before in earlier examples, so this is just to repeat the concept.
#+END_NOTES

*** A mental model for =this=

#+BEGIN_SRC javascript -n
ShoppingListItem.prototype.details = function() {
  return `There are ${this.quantity} ${this.name}`;
}

const item1 = new ShoppingListItem('apples', '6');

item1.details();  // "There are 6 apples"
#+END_SRC

#+BEGIN_SRC javascript -n
ShoppingListItem.prototype.details = function(this) {
  return `There are ${this.quantity} ${this.name}`;
}

const item1 = new ShoppingListItem('apples', '6');

ShoppingListItem.prototype.details(item1);  // "There are 6 apples"
#+END_SRC

#+BEGIN_NOTES
Here's a way of thinking about =this= that might help you think about what's going on.

This is *not* exactly what's happening, but it might be a helpful way of thinking about it.

The code at the top is very similar to what we've just seen, and is the code that you actually write.

The code at the bottom is one way to think about it. There are two changes.

The first is here on line 1, I've made =this= be a parameter that's explicitly passed in.

The second is on line 7.

Remember, the top section, here, is the code that you actually write -- =item1.details()=.

However,  we can pretend that the code behaves like this -- the function is called through the definition on the prototype, and the object is passed in as the magical first =this= parameter.

To be very clear -- the code at the bottom is *not* correct, this does not run, this is just another way of thinking about what's going on. If this is helpful, great. If you look at that and feel confused don't worry about what's going on under the hood, you just have to remember that in a method, =this= refers to the instance of the object that the method is acting on.
#+END_NOTES

*** Converting =createNewListItem= to =toListItem=

- We can convert =createNewListItem= function to =toListItem= method
- Has to be done in one go

#+BEGIN_SRC javascript
const item = new ShoppingListItem(trimmedValue, quantityBox.value);

shoppingList.appendChild(createNewListItem(item));
#+END_SRC

#+BEGIN_SRC javascript
const item = new ShoppingListItem(trimmedValue, quantityBox.value);

shoppingList.appendChild(item.toListItem());
#+END_SRC

#+BEGIN_NOTES
We now know everything we need to know in order to convert the =createNewListItem= function in to a method on the =ShoppingListItem= object called =toListItem=.
#+END_NOTES

*** Steps

- Assign function to =ShoppingListItem.prototype.toListItem=
  - Remove the =item= parameter
  - Replace =item= in the body with =this=
  - Change the JSDoc
- Change everywhere that calls the code

#+BEGIN_NOTES
Here's what we're going to do -- and again, we need to do this in one step, it's not really possible to break this down in to smaller steps that will work individually.

We take the current function and rewrite the start so that instead of being a standalone function, it's a function that's assigned to the =toListItem= property on the =ShoppingListItem.prototype=.

We'll need to remove the =item= parameter from the function. And then in the body of the function we replace the references to =item= with references to =this=.

The JSDoc will need to be updated.

And then everywhere that calls the code will need to be updated as well.
#+END_NOTES

**** Exercise: Update the start of =createNewListItem=             :exercise:

- We assigned a function to a member earlier
  - The =details= method example
- Do the same thing, but re-write the =createNewListItem= definition
  - Assign to the correct prototype
  - Rename to =toListItem=
  - Remove the =item= parameter
  - Update the JSDoc

**** Solution: Update the start of =createNewListItem=

#+INCLUDE: "shopping-22.js" :lines "13-19" src javascript

#+BEGIN_NOTES
Here's the re-written code.

=createNewListItem= is now an anonymous function attached to the prototype for =ShoppingListItem=. And the new method is called =toListItem=.

Because it's a method that has access to the object, it no longer needs the =item= parameter to be passed in.

This means we can remove the =item= parameter from the JSDoc as well.
#+END_NOTES

**** Exercise: Update the body of =toListItem=                     :exercise:

- When there was an =item= parameter the code used it
  - =item.name=
  - =item.quantity=
- Now it's a method we can use =this=
- Update the code to use =this= instead of =item=

**** Solution: Update the body of =toListItem=

#+INCLUDE: "shopping-22.js" :lines "21-23" src javascript

#+INCLUDE: "shopping-22.js" :lines "38-44" src javascript

**** Exercise: Update the places the call the code                 :exercise:

- There are two places in the code that called =createNewListItem=
- Update them to call the =toListItem= method on the =item= variable

**** Solution: Update the places that call the code

#+INCLUDE: "shopping-22.js" :lines "62-78" src javascript

#+BEGIN_NOTES
This is the first place, in the =click= handler.
#+END_NOTES

**** Solution: Update the places that call the code

#+INCLUDE: "shopping-22.js" :lines "79-100" src javascript

#+BEGIN_NOTES
And this is the second, in the =keyup= handler
#+END_NOTES

**** Alternative, without a variable

#+BEGIN_SRC javascript
shoppingList.appendChild(new ShoppingListItem(
    trimmedValue, quantityBox.value).toListItem());
#+END_SRC

#+BEGIN_NOTES
And here's an alternate way of writing that without needing an intermediate variable.
#+END_NOTES

** Recap: Prototype and methods

- Prototype is the blueprint used when objects are constructed
- Access with =TypeName.prototype=
- Create a method by assigning a function to a property on the =prototype=

#+BEGIN_SRC javascript
SomeType.prototype.newMethod = function() {
  // Do something, "this" refers to the object instance
}
#+END_SRC

* Objects: That was old-style syntax

- How objects in Javascript originally worked
- Important because:
  1. There's a lot of code still out there that looks like that
  2. JSON is an extremely common format

#+BEGIN_NOTES
Everything that I've just shown you is the old-style way of creating and referring to objects.

Normally in this course we've been focused on the most modern way of writing code, and haven't paid too much attention to older ways of doing so.

Objects are different, for two main reasons.

The first is that there is a vast amount of code out there that uses the old way of doing things, and you will definitely see it in your jobs. So you need to be able to understand and work with it.

The second is that this way of writing structured data, using JSON, is *extremely* popular, even outside Javascript, so it's important that you get used to it.
#+END_NOTES

** Using new-style objects

- There is no change to how you use a new-style object

#+BEGIN_NOTES
You use a new-style object exactly the same way that you use one defined the way we've currently been doing. There's absolutely no difference.

The only difference is when you write a new-style object. The syntax is a bit different.
#+END_NOTES

** Setup: =shopping-class= directory

- Create a =poco/shopping-class= directory
- Check everything in =shopping= is saved
- Copy the files from =poco/shopping= in to =poco/shopping-class=
  - The HTML, CSS, and Javascript files only

#+BEGIN_NOTES
We're going to keep the files separate so you can easily refer back and see what the differences are.

So, in your =poco= directory create a new directory called =shopping-class=.

Make sure you've saved all the files in the =shopping= directory, then copy the HTML, CSS, and Javascript in to the =shopping-class= directory.
#+END_NOTES

** Defining a class, old vs new

#+BEGIN_SRC javascript
class ShoppingListItem {
  // Properties and methods go here
}
#+END_SRC

#+BEGIN_NOTES
With old-style objects you don't explicitly declare a class. You write a constructor function and go from there. Also, with old-style objects the name of the class is taken from the name of the function you use as the constructor.

New-style objects are different. You have a =class= keyword, that you must use, and you name the class, much like naming a function.

All of the code for the object is going to go inside those curly brackets.

To define a class you use the =class= keyword, the name of the new class,
and curly brackets.

This helps keep all the code together.

For example, in the current version of our code the constructor function for the =ShoppingListItem= is in with all the other code, making it difficult to see the relationships.
#+END_NOTES

** New style constructors

#+BEGIN_SRC javascript
/** @constructor */
function ShoppingListItem(name, quantity) {
  this.name = name;
  this.quantity = quantity;
}
#+END_SRC

#+BEGIN_SRC javascript
/**
 * Represents an item in the shopping list.
 */
class ShoppingListItem {
  /**
   * @param name {string} Name
   * @param quantity {string} Quantity
   */
  constructor(name, quantity) {
    this.name = name;
    this.quantity = quantity;
  }
}
#+END_SRC

#+BEGIN_NOTES
Lets remind ourselves what an old-style constructor looks like.

Our current one is at the top. I've had to remove most of the comments to save space, but apart from that this is identical to the code we've been writing.

Our old-style constructor function has an UpperCamelCase name that also names the class, takes two parameters for the information we're going to use to construct the object, and then assigns them to the object's members using the =this= variable.

Below that is what a new-style constructor looks like.

There are some similarities and differences to what we've already seen.

To talk about the similarities first:

- The constructor function still takes two parameters
- The constructor body is identical.

The differences:

- The function is *always* called =constructor=
- It's written inside the =class= block
- We don't need to use the =function= keyword

Also, our JSDoc is now a bit separated. We have some documentation that says what the class is for, immediately before the =class= keyword. And then the documentation for the constructor just describes the parameters that it takes.

Go ahead and update =shopping-class.js= to contain this code. When you've done that, delete the =ShoppingListItem= function.
#+END_NOTES

** Methods in new-style classes

#+BEGIN_SRC javascript
/** JSDoc here */
ShoppingListItem.prototype.toListItem = function() {
  // Method body here
}
#+END_SRC

#+BEGIN_SRC javascript
class ShoppingListItem {
  constructor(name, quantity) {
    // ...
  }

  /** JSDoc here */
  toListItem() {
    // Method body here
  }
}
#+END_SRC

#+BEGIN_NOTES
Above is how we've added a method to a class so far -- we attach a function to a property on the class' prototype, and then we can call it as a method. This function should have sensible JSDoc.

The new-style syntax is quite a bit cleaner. You just write the method name inside the =class= body, and put the code in, just like  a regular function.

The only difference is that you don't need to use the =function= keyword.

The JSDoc goes before the method in exactly the same way that it went before the function with the old-style classes.

It's worth saying that these two ways of writing the code have exactly the same effect -- the =prototype= is still modified using the second example. But the new style class syntax is cleaner and easier to follow. So that's what we use now.

Go ahead and change your code in =shopping-class= to use the new style syntax, and make sure it works.
#+END_NOTES

** Commit!

** Recap: New-style class syntax

#+BEGIN_SRC javascript
/** ... */
class Person {
  /** ... */
  constructor(first, last, interests) {
    this.name = {
      first: first,
      last: last
    };
    this.interests = interests;
  }

  /** ... */
  greet() {
    console.log(`Hello ${this.name.first}`);
  }
}
#+END_SRC

* Refactoring -- split in to multiple files

* Model - View - Controller

** Problem

- Goal: Functions should do one thing
- Problem: Current functions do lots of things
  - [View] Retrieves data from DOM
  - [Controller] Act on key presses
  - [Controller] Act on button clicks
  - [Model] Creates new list item
  - [Model] Remove item from list
  - [View] Display the list / update the DOM
- Also contain duplicate / similar code

** Basic outline

- 3 classes, =Model=, =View=, =Controller=
- =Model= contains data, and methods to change it
  - When data changes, tell's the =View= to update.
- =View= displays the list, widgets, and calls =Controller=
- =Controller= updates the model

** Skeleton code

*** Controller

- Creates the model

#+INCLUDE: "shopping-class-3.js" :lines "33-41" src javascript

*** Model

- Create a variable to contain the shopping list (array)
- Create the view

#+INCLUDE: "shopping-class-3.js" :lines "15-32" src javascript

*** View

- Save the model and controller in to variables

#+INCLUDE: "shopping-class-3.js" :lines "1-14" src javascript

*** Initialise the application

#+INCLUDE: "shopping-class-3.js" :lines "95-101" src javascript

** Now what?

- Build the application back up bit by bit
- Testing as we go

** Steps

- Displaying data
- Adding items
- Deleting items
- Clearing the list

** Displaying data

- Want to make sure that the view can show information from the model
- Model:
  - Create some dummy data
  - Provide a =getter= for the =items_= array
- View:
  - Provide a method to update the display

*** Exercise: Create some dummy data

- Find the code that creates the =items_= array
- Populate the array with =ShoppingListItem= instances
  - name: =First item=, quantity: =q1=
  - name: =Second item=, quantity: =q2=
  - name: =Third item=, quantity: =q3=

*** Solution: Create some dummy data

#+INCLUDE: "shopping-class-3.js" :lines "26-27" src javascript

#+INCLUDE: "shopping-class-4.js" :lines "38-43" src javascript

*** Provide a =getter= for the =items_= array

- A what?

*** =items_= is private

- Conventionally, =items_= is private
  - Not supposed to be accessed/changed outside =Model=
  - Indicated by the underscore (=_=)
  - Not enforced by Javascript

*** Getter turns a function in to a property

#+BEGIN_SRC javascript
// In Model
items() {
  return this.items_.slice();
}
#+END_SRC

#+BEGIN_SRC javascript
// In View
let length = this.model.items().length;
#+END_SRC

*** Getter turns a function in to a property

#+BEGIN_SRC javascript
// In Model
get items() {
  return this.items_.slice();
}
#+END_SRC

#+BEGIN_SRC javascript
// In View
let length = this.model.items.length;
#+END_SRC

#+BEGIN_NOTES
This is an example of what we call syntactic s
#+END_NOTES
** Adding items

** Deleting items

** Clearing the list

** Benefits

- Encapsulation
- Decoupling

#+BEGIN_NOTES
There are some big benefits to this approach.

Firstly, our code is now nicely separated in to different parts
according to what they do.

The code in the View class only deals with the things that the
user can see.

The code in the Model class only deals with the structure of the
data.

The code in the Controller is called in response to events and
knows how to forward changes on to the Model.

We call this Encapsulation -- each class knows about the things it
needs to know about.

Their responsibilities are also decoupled.  The Model has no idea
how the data is going to be displayed -- it just tells the View
to display it.

We could have a completely different View class, that shows the
data in a different way, and we wouldn't need to change the code
in the Controller or the Model at all.

Also, our View has no idea what the rules are for whether or not
an item should be added to the list. The only logic it contains
is the to decide if a button should be enabled or not. We could
add additional logic in the Controller, and the View would not need
to change.

We say that everything is decoupled.
#+END_NOTES

** Problems


* Parsing quantities
* Re-order items in the list
* Drag-drop items in the list
* Javascript syntax followup work
* Event listeners and =this=
* Advanced: Using validity check to prevent invalid input
** TODO: Problem
** Things to check
- Should have a value (=required=)

