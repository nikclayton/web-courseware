#+Title: Powercoders Basel Coursework, DOM Shopping List Exercise
#+SETUPFILE: "../../include/settings.org"

* TODO Building a shopping list

#+BEGIN_NOTES
So far everything that we've been learning has been a bit abstract.

That's OK, but it's time to put the pieces together and start
building something more concrete, where we can see definite
progress towards an end-goal.

So we're going to build a web based shopping list, bit by bit.

Along the way we'll discover new things that we need to learn,
and incorporate that in to what we build.
#+END_NOTES

* TODO Features

- Box to enter an item
- Button to add the item to a list
- The list itself
- Each list item has a button to delete the item

#+BEGIN_NOTES
To start with, our app is going to be very simple.

It's going to need a box where the user can type in the name of
the item they want to add to the list. Add a button that the
user can click in order to add the thing to the list.

It's going to need to be able to show the list of things the user
has entered.

And each list item is going to need a button that allows the user
to delete the thing from the list.

At the moment we're not going to worry too much about how it
looks, so we're going to keep styling to a minimum. We want to
get the core functionality working properly first.
#+END_NOTES

* TODO Goal

#+BEGIN_CENTER
[[file:initial-wireframe.png]]
#+END_CENTER

#+BEGIN_NOTES
I used a sketch tool to throw together a quick wireframe of what
the app would look like initially, to make it a bit more concrete.

This is a very common approach -- the UI designer might come to you
with some sketches of different ideas, asking how difficult it is to
build their idea.

[Wireframe is: https://wireframe.cc/Lfqgye]
#+END_NOTES
* TODO What do / don't we know?

#+REVEAL_HTML: <div class="leftcol">
- We know
  - Paragraphs, lists
  - Listening for clicks
  - Adding DOM nodes
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here's the things we've already covered. From that little demo,
who can tell me things we're going to need to learn?
#+END_NOTES

* TODO What do / don't we know?

#+REVEAL_HTML: <div class="leftcol">
- We know
  - Paragraphs, lists
  - Listening for clicks
  - Adding DOM nodes
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- We don't know
  - Input boxes
  - Buttons
  - Removing DOM nodes
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
I think we're going to need to figure out

- input boxes
- buttons
- removing DOM nodes (so we can delete items from the list)

Everything else is stuff we've already done.
#+END_NOTES

* TODO Set up

- Create a =poco/shopping= directory
- Create =index.html=
  - Heading "My shopping list"
  - Empty unordered list
- Link to empty =style.css= and =shopping.js= files

#+BEGIN_NOTES
We'll set up the infrastructure for our project.

Create a new directory in your =poco= directory called =shopping=.

In there, create an =index.html= file. It should have a level 1 heading
with the text =My shopping list=, and an empty unordered list -- the =ul=
element should be there, but it shouldn't have an listitems.

Make sure this HTML file links to two empty files, =style.css= and
=shopping.hs=.
#+END_NOTES

* TODO Set up HTML

#+INCLUDE: "shopping-1.html" src html

#+BEGIN_NOTES
Put this text in your HTML file, and make sure it works.

There's nothing special about this -- it's just a skeleton file
that contains all the normal structure for an HTML page.

I've added comments that indicate where the things we're going
to need to learn are going to go, and we'll fill these in through
the class.

Add all of these files to your repository and make a commit
with a sensible commit message.

[Wait]
#+END_NOTES

* TODO Input boxes

- MDN documentation: [[[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/text][mdn html input type=text]]]
- Questions:
  - What element name and attributes should we use?
  - What property contains the typed in value?
  - How do you set a placeholder value?
  - What is the =label= element used for?

#+BEGIN_NOTES
We're going to start by focusing on the UI things that we don't know.

To do that, I want you to look at the Mozilla Developer Network
pages for =html input= element. Specifically, the one where the
=type= attribute is set to =text=.

Have a read through that page and keep these questions in mind as
you're reading, as I'll be asking questions in about 10 minutes...

[Wait]
#+END_NOTES

** Answers

*** What element name should be used?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: input-example
#+BEGIN_SRC html-chrome
<input type="text">
#+END_SRC

- The =input= element
- Specialised based on =type= attribute
  - =text=, =color=, =password=, ...
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[7c0c47a9b351fbd177ba3deda8826d7d3733ff60]: input-example
[[file:input-example.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We use the =input= element, generally, to get input from the
user.

This element has a =type= attribute that is used to say exactly
what form the input should take. When we want to get a line of
text we set the =type= attribute to =text=, but there are others.

For example, if we set =type= to password then the text the user
typed in would automatically be hidden.
#+END_NOTES

*** What property contains the typed in value?

#+BEGIN_SRC html
<input type="text" id="an-input">
#+END_SRC

#+BEGIN_SRC javascript
let el = document.getElementById("an-input");
el.value
#+END_SRC

#+BEGIN_NOTES
The =input= element has a property called =value=. This property
contains whatever text is in the element.
#+END_NOTES

*** How do you set a placeholder value?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: input-placeholder-example
#+BEGIN_SRC html-chrome
<input type="text" placeholder="Enter item">
#+END_SRC

- Use the =placeholder= attribute
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[d9899abd0468e79cd8a8a2d7e572f08d27a398eb]: input-placeholder-example
[[file:input-placeholder-example.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Simply enough -- there is a =placeholder= attribute. It's
value is used as the text to display in the input box if
the user hasn't entered anything.
#+END_NOTES

*** What is the =label= element used for?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: input-label-example
#+BEGIN_SRC html-chrome
<label for="item">Enter a new item:</label>
<input type="text" id="item" placeholder="Enter item">
#+END_SRC

- Associates a caption with the input
  - Clicking the label selects the input
  - Screenreaders and accessibility
- =label= =for= attribute points to =input= =id= attribute
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[51c3c50c098813ac2911a013d14aebcc6fb504ab]: input-label-example
[[file:input-label-example.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
The =label= element lets us associated a label with this specific
input element.

We could have used a =p=, but the =label= has a special attribute
that allows us to say exactly which input element the label is for.

If our input element has an =id= attribute, we set the label's
=for= attribute to the same value. Now, if the user clicks the
label the cursor will move in to the input element. And if they
have accessibility issues -- maybe they're using a screenreader --
then their tools will be able do a better job.
#+END_NOTES

** Add =label= and =input= elements

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "shopping-2.html" :lines "11-18" src html -n 11

- Edit =shopping.html=
- Add these elements to the page
- Don't forget to add and commit
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :exports results
    <div>
      <label for="item">Enter a new item:</label>
      <input type="text" id="item" placeholder="Type something to buy">
    </div>
#+END_SRC

#+RESULTS:
[[file:add-label-and-input-elements.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
So, now that we know all of that you can go ahead and add these
elements to your page. Here's the HTML to use, just as a
reminder.

When it's working don't forget to add and commit the change.
#+END_NOTES
** Checking that we can read the value                             :exercise:

- Type something in the box

#+BEGIN_SRC javascript
let el = document.getElementById('item');
el.value
#+END_SRC

- Do you see what you typed?

#+BEGIN_NOTES
We already saw that the input widget has a =value= property that
contains whatever is entered in to the box.

We're going to need this information later.

So lets make sure that our understanding is correct.

Load the page in your browser, and open the developer tools.

Then type something -- it doesn't matter what -- in to input
box.

Then, in the console, type this Javascript. All this does is
find the =input= element in the page and display its =value=
property.

If everything's working then you should see what you typed in
to the box in the console.

[Wait]
#+END_NOTES
** Can we write the value?                                         :exercise:

#+BEGIN_SRC javascript
el.value = 'hello';  // <-- What happens?
#+END_SRC

#+BEGIN_NOTES
Try this out in the console. What happens?

[Wait]

That's cool -- we can change the value in the box by writing
to the property.

This is just like changing the value of the =className= property
to change the =class= attribute value that we did earlier.
#+END_NOTES

* TODO Buttons                                                     :exercise:

- MDN documentation: [[[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button][mdn html button]]]
- Questions:
   - What element name and attributes should we use?
   - Can we make buttons look pretty?

#+BEGIN_NOTES
Now we know how to provide somewhere for the user to enter
information we need to give them a button that they can click
which will add the entered item to the shopping list.

Again, I want you to look at the MDN pages for buttons. Do that
search, and read the page keeping these questions in mind. I'll
be asking questions again in about 10 minutes...

[Wait]
#+END_NOTES

** Answers

*** What element name should be used?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: button-example
#+BEGIN_SRC html-chrome
<button>Click me!</button>
#+END_SRC

- The =button= element
- At the moment we don't need attributes
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[16d52427a726393a450c01eb6c3f4dab10dcc94f]: button-example
[[file:button-example.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Creating buttons is pretty easy. We just use the =button= element,
without any special attributes.

The content of the element becomes the text shown on the button.
#+END_NOTES

*** Can we make the buttons look pretty?

#+REVEAL_HTML: <div class="leftcol">
#+NAME: button-style-example
#+BEGIN_SRC html-chrome
<button
  style="
    border: 0;
    line-height: 2.5;
    padding: 0 20px;
    font-size: 1rem;
    text-align: center;
    color: #fff;
    text-shadow: 1px 1px 1px #000;
    border-radius: 10px;
    background-color: rgba(220, 0, 0, 1);
    background-image: linear-gradient(to top left,
                                      rgba(0, 0, 0, .2),
                                      rgba(0, 0, 0, .2) 30%,
                                      rgba(0, 0, 0, 0));
    box-shadow: inset 2px 2px 3px rgba(255, 255, 255, .6),
                inset -2px -2px 3px rgba(0, 0, 0, .6);
    text-shadow: 1px 1px 1px #000;">Click me!</button>
#+END_SRC

- =style= attribute is only for demo purposes, do not do this
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[fa4fa39c37eb9a955e44abfb77dc0627fad23741]: button-style-example
[[file:button-style-example.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Yes we can. There are lots of opportunities for styling buttons.

This is a somewhat extreme example.
#+END_NOTES

** Add a =button= element to your page                             :exercise:

- Add a =button= element after the =input= element
  - Inside the =div=
- Make sure it shows up
- Add and commit

#+BEGIN_NOTES
So lets add that =button= element to the page. Place it after
the =input= element, and inside the =div=.

The text on the button can be anything you want.

Once you've done that and it's showing up, add and commit.

[Wait]
#+END_NOTES

*** Solution: Add a =button= element

  #+REVEAL_HTML: <div class="leftcol">
  #+INCLUDE: "shopping-3.html" :lines "11-19" src html -n 11
  #+REVEAL_HTML: </div>

  #+REVEAL_HTML: <div class="rightcol">
  #+BEGIN_SRC html-chrome :exports results
      <div>
	<label for="item">Enter a new item:</label>
	<input type="text" id="item" placeholder="Type something to buy">
	<button>Add item</button>
      </div>
  #+END_SRC

  #+RESULTS[fa65ef25afcb970a28ca6144c0c8bbe9cbf8a9e8]:
  [[file:solution-add-a-button-element.png]]

  #+REVEAL_HTML: </div>

 #+BEGIN_NOTES
 So lets add that =button= element to the page. Place it after
 the =input= element, and inside the =div=.

 The text on the button can be anything you want.

 Once you've done that and it's showing up, add and commit.

 [Wait]
 #+END_NOTES

* Widgets / controls
  :PROPERTIES:
  :TOPICS:   widget
  :END:

#+BEGIN_NOTES
The general term for things like the input box, buttons, and
other things that you can add to forms -- like checkboxes, drop-down
lists, radio buttons, and more -- is a *widget*. The term *control*
is also used.

So you might hear me talk about the *input widget* or the *input
control*, or the *button widget*.

You'll see these terms come up a lot in documentation as well.
#+END_NOTES

* TODO Responding to button clicks                                 :exercise:

- Use an event listener, exactly as before

#+BEGIN_SRC javascript
document.addEventListener('DOMContentLoaded', function(event) {
  document.querySelector('button').addEventListener('click', function(event) {
      console.log('The button was clicked');
  });
});
#+END_SRC

#+BEGIN_NOTES
Our button is on the page, but it's not doing anything yet.

We need to write some Javascript that will run when the button is
clicked that will do something.

To listen for button clicks we use an event listener exactly as we've
done in the past.

I know =querySelector= here is new. We're going to talk about that
in a moment.

For now, make sure that =shopping.html= is loaded, open the console,
type this, and click the button a few times to make sure it works.

[Wait]

Does everyone see how this works? Did you get the message in the
console when the button was clicked?
#+END_NOTES

*** =querySelector()=

#+BEGIN_SRC javascript
  document.querySelector('button').addEventListener('click', function(event) {
      console.log('The button was clicked');
  });
#+END_SRC

- Finds the *first* element that matches the CSS selector string
- Much more flexible than =getElementById()=

#+BEGIN_NOTES
So far we've been using =getElementById= to find elements based on their
=id= attribute.

Here I'm using the =querySelector= method. This method has a single
parameter which is a string which should look like a CSS selector.

Remember, the selector is the part in a CSS rule that's *before* the
curly-brackets and all the style rules.

If more than one element matches the selector only the first matching
element is returned.

#+END_NOTES

*** =querySelector()= examples

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html
<p id="first">...</p>

<h1 class="warning">...</h1>

<p class="warning">...</p>

<ul>
  <li>First li</li>
  <li>Second li</li>
</li>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
document.querySelector('#first');
  // <p id="first">
  // Identical to getElementById('first');

document.querySelector('.warning');
  // <h1 class="warning">

document.querySelector('p.warning');
  // <p class="warning">

document.querySelector('ul li:nth-of-type(2)').innerText;
  // "Second li"

document.querySelector('p');
  // <p id="first">
  // Finds the first matching element
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here are some examples.

On the left we have some HTML. On the right, some calls to
=querySelector()=.

In the Javascript, the call in line 1 returns the first =p= element,
also on line 1 of the HTML. This is because the =p= element has
an =id= of "first", and remember that the =#= sign is how you specify
an ID in CSS.

The call on line 5 returns the =h1= element. Although there are two
elements -- the =h1= and the =p= that have the =warning= class,
=querySelector= returns the *first* one.

The call on line 8 specifically finds the =p= element because the
selector is more specific.

And on line 11 this selector finds the second =li= element of the
first =ul= element. And then retrieve's its =innerText= property.
#+END_NOTES

* Log the value in the input box                                   :exercise:

- Modify the click listener
  - Retrieve the input widget's value
  - Log it using =console.log=

#+BEGIN_NOTES
We can use =console.log= to verify that we've got the value
correctly before moving on to the next part of the problem.
#+END_NOTES

** Solution: Button click listener

#+BEGIN_SRC javascript
  // With a variable.
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      let inputBox = document.queryElementById('item');
      console.log(inputBox.value);
    });
  });
#+END_SRC

#+BEGIN_SRC javascript
  // With chaining.
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      console.log(document.queryElementById('item').value);
    });
  });
#+END_SRC

* TODO Adding list items

#+BEGIN_SRC html
<ul>
  <!-- List items go here -->
</ul>
#+END_SRC

#+BEGIN_SRC html
<li><span>Eggs</span> <button>Delete</button></li>
#+END_SRC

#+BEGIN_NOTES
Now that we can do something when the user clicks the button, and
we can see what text they added, we need to figure out how we're
going to add an item to the list.

In our HTML file our list starts out like the example at the top.
It's just the =ul= element with no children.

What we want is to create a new entry in the list for each item.
Each entry is going to need to contain the text that the user
typed in, and a button to delete the item from the list.

In other words, it's going to look like the HTML at the bottom.
Except "Eggs" is going to be replaced by whatever the user typed in.

This means we need to write a function that can take whatever's in the
=input=, create a new =li=, create a =span=, set the text of the
=span=, add a button.

Before we do that, let's make sure that our understanding of what
the DOM tree for this is going to look like is correct.
#+END_NOTES

** List item graph                                                 :exercise:

#+BEGIN_SRC html
<li><span>Eggs</span> <button>Delete</button></li>
#+END_SRC

- Draw the DOM tree for this HTML

#+BEGIN_NOTES
This is what we're going to add to the =ul= element every time
the button is clicked.

Go ahead and draw out the tree for these elements.

[Wait]
#+END_NOTES
*** Solution: List item graph
#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html
<li><span>Eggs</span> <button>Delete</button></li>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file list-item-graph.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
digraph G {
  node [shape="hexagon"];

  li -> span
  li -> button

  span -> span_content;
  span_content [label="Eggs" shape=none];
  button -> button_content;
  button_content [label="Delete" shape=none];
}
#+END_SRC

#+RESULTS:
[[file:list-item-graph.svg]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Did everybody's tree look like this?

[Wait]

For anyone's that didn't.

We start with the =li= element -- that's the first node.

We see that this has a child element called =span=, so we add
that to the tree.

Then we see that it has some content, so we add that as well.

Then the =span= ends, and a new =button= element starts. This is
also a child of the =li= element. And that has some text content
too, so we add that as its own node.
#+END_NOTES

** Exercise: Write a function that creates this tree

#+REVEAL_HTML: <div class="leftcol">
[[file:list-item-graph.svg]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  // Fill this in
}
#+END_SRC
#+REVEAL_HTML: </div>

** Exercise (hint): Write a function that creates this tree

#+REVEAL_HTML: <div class="leftcol">
[[file:list-item-graph.svg]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  // Create an li node

  // Create a span node

  // Set the span's .innerText property

  // Create a button node

  // Set the button's .innerText property

  // Append the span to the li node

  // Append the button node to the li node

  // Return the li node
}
#+END_SRC
#+REVEAL_HTML: </div>

** Solution: Write a function that creates this tree

#+NAME: createNewListItemNoDelete
#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  let listItem = document.createElement('li');

  let listText = document.createElement('span');
  listText.textContent = itemName;

  let deleteButton = document.createElement('button');
  deleteButton.textContent = 'Delete';

  listItem.appendChild(listText);
  listItem.appendChild(deleteButton);

  return listItem;
}
#+END_SRC

#+BEGIN_NOTES
Here's one possible solution.

There are 5 sections to this code:

1. Creating the =li=
2. Creating and populating the =span=
3. Creating and populating the =button=
4. Appending children to the =li=
5. Returning the value.

Steps 1, 2, and 3 can happen in any order.

I'm going to show you some variations of this function.
#+END_NOTES

** Solution: Write a function that creates this tree

#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  let listItem = document.createElement('li');
  let listText = document.createElement('span');
  let deleteButton = document.createElement('button');

  listText.textContent = itemName;
  deleteButton.textContent = 'Delete';

  listItem.appendChild(listText);
  listItem.appendChild(deleteButton);

  return listItem;
}
#+END_SRC

#+BEGIN_NOTES
This has exactly the same effect as the previous function. But
here the nodes are created before being modified. This is absoutely
fine.

My personal preference is to not do this -- I generally prefer it if a
variable is declared as close to where it will be used as possible,
but different people have different opinions about this.
#+END_NOTES

** Solution: Create and append

#+BEGIN_SRC javascript
  function createNewListItem(itemName) {
    let listItem = document.createElement('li');

    let listText = document.createElement('span');
    listText.textContent = itemName;
    listItem.appendChild(listText);

    let deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';
    listItem.appendChild(deleteButton);

    return listItem;
  }
#+END_SRC

#+BEGIN_NOTES
This also has the same effect, but we append the nodes to the
list item as soon as we're done with them.

This is also a perfectly fine way to do things.
#+END_NOTES

* TODO Adding list items when the button is clicked                :exercise:

#+BEGIN_CENTER
This is our current click listener
#+END_CENTER

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      let inputBox = document.queryElementById('item');
      console.log(inputBox.value);
    });
  });
#+END_SRC

- Call =createNewListItem= to generate the =li= node
- Find the =ul= element and use =appendChild= to add the =li= node

#+BEGIN_NOTES
This is the click listener that we wrote earlier. Yours might have
slightly different variable names, but it should work -- when the
button is clicked it should log whatever is in the input widget.

Modify this =click= listener so that it calls =createNewListItem=
with the input widget's value to create the new =li= element.

Then find the =ul= element and use =appendChild= to add the =li= node.

[Wait for everyone to do this]
#+END_NOTES

*** TODO Solution: Adding list items when the button is clicked
#+BEGIN_SRC javascript
  // Variables
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      let inputBox = document.getElementById('item');
      let li = createNewListItem(inputBox.value);
      document.querySelector('ul').appendChild(li);
    });
  });
#+END_SRC

#+BEGIN_SRC javascript
  // Chaining
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      document.querySelector('ul').appendChild(
        createNewListItem(document.getElementById('item').value));
    });
  });
#+END_SRC

#+BEGIN_NOTES
Here's what one solution looks like.

We call =createNewListItem()=, passing it =inputBox.value=, so it
receives whatever text the user typed in.

This returns an =li= elemnt, which we save in the =li= variable.

On the next line we find the =ul= element and append our new =li=
element to the end.

[Questions?]

This alternative version here does the same thing, but chains
things together instead of using intermediate variables.
#+END_NOTES

* TODO The =Delete= button

#+BEGIN_SRC javascript :noweb yes
<<createNewListItemNoDelete>>
#+END_SRC

#+BEGIN_NOTES
Now that adding items to the list works we need to figure out how
we're going to delete them.

Deleting a list item is the same thing as deleting (or removing) it
from the DOM tree.

This is the code that I wrote that creates and returns a new list
item. We talked about this code a few slides back -- your code
might look slightly different, but the end result is the same.

The important bit for the delete button is finding the place in
the code where the button is created. In my code that's right here,
lines 7 and 8.

Go ahead and find that spot in your code.

Because we're going to make a change right there.

Let me know when you've found your equivalent code.
#+END_NOTES

** TODO Exercise: Checking we can detect the click                 :exercise:

#+BEGIN_SRC javascript
function createNewListItem(itemName) {
  let listItem = document.createElement('li');

  let listText = document.createElement('span');
  listText.textContent = itemName;

  let deleteButton = document.createElement('button');
  deleteButton.textContent = 'Delete';

  // Add a click handler that logs the click here
  // ...

  listItem.appendChild(listText);
  listItem.appendChild(deleteButton);

  return listItem;
}
#+END_SRC

#+BEGIN_NOTES
As always, let's make sure we can detect the click before we do
anything more complicated.

We're always trying to make the simplest change that can work, and then
build upon it.

So, change your =createNewListItem= function and add a click listener
after the delete button has been created.

This is my code, so I'd put the new code where the comment is. Your
code might create the elements in a slightly different order, but
as long as you create the handler after the button is created you'll
be OK.

This click listener is going to be just like the one we made for the
"Add Item" button a while back -- it does has to listen for the
=click= event and use =console.log= to send a message to the console.

[Wait]
#+END_NOTES

** TODO Solution: Checking we can detect the click
#+NAME: createNewListItemLogClick
#+BEGIN_SRC javascript
  function createNewListItem(itemName) {
    let listItem = document.createElement('li');

    let listText = document.createElement('span');
    listText.textContent = itemName;

    let deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';

    deleteButton.addEventListener('click', function(event) {
      console.log('Delete button clicked');
    });

    listItem.appendChild(listText);
    listItem.appendChild(deleteButton);

    return listItem;
  }
#+END_SRC

#+BEGIN_NOTES
Here's my solution. There's nothing special here that we haven't
done before.

I add an event listener for the =click= event to the delete
button, and when it's clicked I used =console.log= to confirm
that the listener was working.

That's the new code on lines 10, 11, and 12. Everything else is
the same.
#+END_NOTES
** TODO Removing DOM nodes                                         :exercise:
   :PROPERTIES:
   :REQUIREMENTS: dom
   :TOPICS:   dom-remove
   :END:

 - [[[https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove][MDN remove element]]] / [[[https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove][MDN delete element]]]

#+BEGIN_NOTES
Now that we know we can detect the click and run an event listener we
need to find out how we delete the current list item from the tree.

For that we can use the documentation again. Try one of these
searches in Google, and read the documentation that comes up.

See if you can figure out what *one line of code* we need to write
in the click event listener to delete the listitem when the
button is clicked.

[Wait]
#+END_NOTES

** Solution: Removing DOM nodes
#+BEGIN_SRC javascript
element.remove();
#+END_SRC

#+BEGIN_NOTES
The general way to remove an element from the DOM tree is to
call its =remove()= method.  If you do this then the element,
and anything that it contains, will be deleted.
#+END_NOTES

*** =remove()= and the DOM

#+BEGIN_SRC html
  <ul>
    <li><span>Eggs</span> <button>Delete</button></li>
    <li><span>Milk</span> <button>Delete</button></li>
    <li><span>Bread</span> <button>Delete</button></li>
  </ul>
#+END_SRC

#+BEGIN_NOTES
Imagine our list has three list items in it, for "Eggs", "Milk",
and "Bread", like this.

#+END_NOTES

*** =remove()= and the DOM

 #+BEGIN_SRC dot :file list-item-graph2.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
 digraph G {
   node [shape="hexagon"];

   ul -> {li1, li2, li3};
   li1 [label="li"];
   li1 -> span1
   li1 -> button1

   span1 [label="span"];
   span1 -> span_content1;
   span_content1 [label="Eggs" shape=none];
   button1 [label="button"];
   button1 -> button_content1;
   button_content1 [label="Delete" shape=none];

   li2 [label="li"];
   li2 -> span2
   li2 -> button2

   span2 [label="span"];
   span2 -> span_content2;
   span_content2 [label="Milk" shape=none];
   button2 [label="button"];
   button2 -> button_content2;
   button_content2 [label="Delete" shape=none];

   li3 [label="li"];
   li3 -> span3
   li3 -> button3

   span3 [label="span"];
   span3 -> span_content3;
   span_content3 [label="Bread" shape=none];
   button3 [label="button"];
   button3 -> button_content3;
   button_content3 [label="Delete" shape=none];
 }
 #+END_SRC

 #+RESULTS:
 [[file:list-item-graph2.svg]]

#+BEGIN_NOTES
This is what the DOM tree for that looks like.

Does this make sense to everyone so far?

[Wait]
#+END_NOTES

*** Finding the second list item

#+BEGIN_SRC javascript
let secondLi = document.querySelector('li:nth-child(2)');
#+END_SRC

 #+BEGIN_SRC dot :file list-item-graph3.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
 digraph G {
   node [shape="hexagon"];

   ul -> {li1, li2, li3};
   li1 [label="li"];
   li1 -> span1
   li1 -> button1

   span1 [label="span"];
   span1 -> span_content1;
   span_content1 [label="Eggs" shape=none];
   button1 [label="button"];
   button1 -> button_content1;
   button_content1 [label="Delete" shape=none];

   subgraph cluster_li2 {
     li2 [label="li"];
   }
   li2 -> span2
   li2 -> button2

   span2 [label="span"];
   span2 -> span_content2;
   span_content2 [label="Milk" shape=none];
   button2 [label="button"];
   button2 -> button_content2;
   button_content2 [label="Delete" shape=none];

   li3 [label="li"];
   li3 -> span3
   li3 -> button3

   span3 [label="span"];
   span3 -> span_content3;
   span_content3 [label="Bread" shape=none];
   button3 [label="button"];
   button3 -> button_content3;
   button_content3 [label="Delete" shape=none];
 }
 #+END_SRC

 #+RESULTS:
 [[file:list-item-graph3.svg]]

*** Removing the second list item

#+BEGIN_SRC javascript
let secondLi = document.querySelector('li:nth-child(2)');
secondLi.remove();
#+END_SRC

 #+BEGIN_SRC dot :file list-item-graph4.svg :cmdline -Tsvg -Gstylesheet=../../graphviz.css
 digraph G {
   node [shape="hexagon"];

   ul -> li1;
   ul -> li2 [style=invis];
   ul -> li3;

   li1 [label="li"];
   li1 -> span1;
   li1 -> button1;

   span1 [label="span"];
   span1 -> span_content1;
   span_content1 [label="Eggs" shape=none];
   button1 [label="button"];
   button1 -> button_content1;
   button_content1 [label="Delete" shape=none];

   li2 [label="li" style=invis];

   li2 -> span2 [style=invis];
   li2 -> button2 [style=invis];

   span2 [label="span" style=invis];
   span2 -> span_content2 [style=invis];
   span_content2 [label="Milk" style=invis shape=none];
   button2 [label="button" style=invis];
   button2 -> button_content2 [style=invis];
   button_content2 [label="Delete" style=invis shape=none];

   li3 [label="li"];
   li3 -> span3
   li3 -> button3

   span3 [label="span"];
   span3 -> span_content3;
   span_content3 [label="Bread" shape=none];
   button3 [label="button"];
   button3 -> button_content3;
   button_content3 [label="Delete" shape=none];
 }
 #+END_SRC

 #+RESULTS:
 [[file:list-item-graph4.svg]]


*** TODO Exercise: Remove the listitem when the delete button is clicked :exercise:

#+BEGIN_SRC javascript :noweb yes
<<createNewListItemLogClick>>
#+END_SRC

#+BEGIN_NOTES

#+END_NOTES
*** TODO Solution: Remove the listitem when the delete button is clicked
#+NAME: createNewListItemDelete
#+BEGIN_SRC javascript
  function createNewListItem(itemName) {
    let listItem = document.createElement('li');

    let listText = document.createElement('span');
    listText.textContent = itemName;

    let deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';

    deleteButton.addEventListener('click', function(event) {
      listItem.remove();
    });

    listItem.appendChild(listText);
    listItem.appendChild(deleteButton);

    return listItem;
  }
#+END_SRC

#+BEGIN_NOTES
Here we simply call the =remove= method on the =listItem=.
#+END_NOTES

* TODO Recap: What have we learned?

#+REVEAL_HTML: <div class="leftcol">
- Widgets
  - =input=
    - Different types exist, ~type=...~
    - Retrieving the value
  - =button=
    - Reacting to clicks
  - =label=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- =document.querySelector('...')=
  - More flexible way to select elements
- =element.remove()=
  - To remove elements from the DOM
#+REVEAL_HTML: </div>

* Play

- Play around with the shopping list
- Identify things we could change to make it easier for users

* TODO UX followup work

- Press =ENTER= to add an item
- Clear the input widget after adding an item
- Setting the input focus
- Prevent empty items from being added

#+BEGIN_NOTES
So, there's good news and bad news.

The good news is that our CEO is very happy with our work, and
thinks that our shopping list app could make a fortune.

The bad news is that we've done some user experience tests with
early adopters, and they've identified a number of things that
they'd like us to change about the app.

They are:

- At the moment they have to click the button to add an item. They'd
  like to press the Enter key as well

- After they've added an item it's still in the input widget. So they
  have to delete whatever they typed in last before entering a new
  item

- Some of them use the keyboard a lot, and they keep having to use
  the mouse to click in the input box before they can type there

- It's really easy to add empty items to the list

Lets get on and fix those problems.
#+END_NOTES

* Press ENTER to add an item

- Need to click the button to add the item
- Natural to press ENTER to add to the list
- How?

** MDN key events                                                  :exercise:

- Search MDN for information about keyboard events
- Look for information about keys being released

#+BEGIN_NOTES
Given the events we've been dealing with so far, you're probably not
surprised to know that events also fire when the user presses and
releases keys.

Search MDN for information about keyboard events, look particularly
for anything that can tell you when a key has been released by
the user.

[Wait]

What did you find?
#+END_NOTES

** TODO =keyup= event properties

#+BEGIN_CENTER
[[https://developer.mozilla.org/en-US/docs/Web/Events/keyup]]
#+END_CENTER

#+BEGIN_SRC javascript
document.addEventListener('DOMContentLoaded', function(event) {
  ...
});
#+END_SRC

#+BEGIN_NOTES
So far our event listeners have only been interested in whether
or not the event occurred. There's nothing else about the event
that's interesting to them.

Things are different for the =keyup= event. Here, we don't just
want to know that a key was released, we want to know which key
was released -- specifically, was it the ENTER key?

All of our event listeners have taken an =event= parameter, but
we haven't used it.

This parameter is where the browser tells us extra things about
the event so that we can make decisions about it.

The documentation for each event tells us what properties the
event parameter has for this type of event, and what they mean.

Looking through these there are a number of things we haven't
covered yet, including event bubbling and cancellation. Don't worry
about those.

I'm more interested in these ones here -- from =char= on down.
These all sound like they'll tell us more information about
the key that was released.

The =key= property looks interesting, based on its description.
Reading that, it sounds like regular keys will have a =key=
value like the key itself, so if you press =a= then the value
will the string =a=, =b= is =b=, and so on.

This note here about =Key values= is also interesting. This
strongly suggests that special keys, like =Enter=, are
represented specially, so lets look at that doc for more
information.

[[https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values][Key values]]

So this document has lots of tables. It looks like the first
column is the value of that =key= property, and then there are
more details.

Looking at the scroll bar on the right tells me that this is
a huge document, so I'm going to just search for =Enter= and
see if anything turns up.

[Search for Enter]

And straightaway, we can see that if the user presses the
Enter key we should get a =key= value of the string =Enter=. I
can tell that it's a string because it's surrounded by double
quotes.

#+END_NOTES

** Exercise: Listening for =keyup= and inspecting =event.key=      :exercise:
#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    // Add code here that listen for 'keyup' on the 'input' element
    // and logs the event.key property.
  });
#+END_SRC

#+BEGIN_NOTES
Lets go and check that our understanding is correct, by writing an
input event listener that listens for =keyup= events on the input
widget and logs the results.

Do this, and let me know when it's done, and you have confirmed
which string is used to repesent the ENTER key.

[Wait]
#+END_NOTES

** Solution: Listening for =keyup= and inspecting =event.key=
#+NAME: EventKeyLog
#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      console.log(event.key);
    });
  });
#+END_SRC

#+BEGIN_NOTES
Here's a solution -- the new event listener here simply logs the
=key= property of the =event= argument so we can take a look at it.

What special string is used if the user presses the ENTER key?

[Wait]

Are there strings for any other special keys?

[Wait]

=Control=, =Shift=, =Alt=, =AltGraph=, =CapsLock=
#+END_NOTES

** How do we use this?

#+BEGIN_NOTES
Now we know that we can tell if the user pressed the ENTER key in
the input widget.

At the moment we're just logging the key that was pressed. We need
to be able to run some code only if the key that was pressed is
ENTER.

How do we do that?
#+END_NOTES
** Making a decision: using =if= statements
   :PROPERTIES:
   :REQUIREMENTS: js-control-flow
   :TOPICS:   js-if
   :END:

#+BEGIN_SRC javascript
if (expression) {
  // Code that only runs if 'expression' is true
  //
  // We call this the "body" of the "if" block.
}
#+END_SRC

#+BEGIN_NOTES
The answer to that is an =if= statement.

We haven't seen these yet.

Remember when we first talked about the flow of control. Initially
control in the program flows down, line by line by line.

Then we introduced functions, which allows the flow to jump to a
different function, run the code that's in that function, and then
jump back to carry on where it left off.

=if= statements change the flow so that some code -- the code inside
the =if= block -- runs only if the expression inside the parentheses
is true.

Notice how the =if= block uses curly brackets -- just like functions --
to enclose the code that might run.
#+END_NOTES
** True and false values in Javascript?

#+REVEAL_HTML: <div class="leftcol">
- False values
  - =false=
  - =undefined=
  - =null=
  - =NaN=
  - =0= (number zero)
  - =''= (empty string)
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- True values
  - Everything else
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Looked a little bit at these earlier in the week.

TODO: Look back to when that was and what was discussed

On the left hand side is every value that Javascript considers to be
false. If the result of an expression evalutes to false and the
expression is used in an =if= condition, the body of the =if= will not
run.
#+END_NOTES
** Comparison operators, numbers

#+BEGIN_SRC javascript
let a = 10;
let b = 20;

a === b;   // false, === means "is equal to?"
a !== b;   // true,  !== means "is not equal to?"
a <   b;   // true,  <   means "is less than?"
a >   b;   // false, >   means "is greater than?"
a <=  b;   // true,  <=  means "is less than or equal to?"
a >=  b;   // false, >=  means "is greater than or equal to?"
#+END_SRC

#+BEGIN_NOTES
Javascript supports numerous operators that are used to compare two
or more values.

Here are the six most common, and what they return.

Try all of these in the console, and make sure you get the same
result.

[Wait]
#+END_NOTES

** Comparison operators, strings
#+NAME: string-comparison-operators
#+BEGIN_SRC javascript
let c = 'This is a string';
let d = 'This is also a string';

c === d;   // false, === means "is equal to?"
c !== d;   // true,  !== means "is not equal to?"
c <   d;   // true,  <   means "is less than?"
c >   d;   // false, >   means "is greater than?"
c <=  d;   // true,  <=  means "is less than or equal to?"
c >=  d;   // false, >=  means "is greater than or equal to?"
#+END_SRC

#+BEGIN_NOTES
You can use these same operators to compare strings. Try these out
in the console.

[Wait]
#+END_NOTES
** What does =<= and =>= mean for strings?

- Dictionary order

#+BEGIN_SRC javascript
// let c = 'This is a string';
// let d = 'This is also a string';

c < d;   // true

let e = 'Another string example';
let f = 'Another example string';

e < f;   // false, 'e' comes before 's'
#+END_SRC

#+BEGIN_NOTES
Strings are compared in dictionary order. Imagine that you had to put
the string in a dictionary. Any word, or string that would occur first
in the dictionary is *less than* any word or string that would appear
after.

Here, strings =e= and =f= are different from the first letter of the
second word. Since the =e= in =example= is before the =s= in =string=,
string =f= is less then string =e=, and the comparison is false.
#+END_NOTES

** Expressions can mix variables and values

#+BEGIN_SRC javascript
// let a = 10;
// let c = 'This is a string';

a > 5;                      // true
a <= 10;                    // true

c === 'This is a string';   // true
#+END_SRC

#+BEGIN_NOTES
Of course expressions can mix variables and values. Here are some
examples of that.

Try these out too.

[Wait]
#+END_NOTES
** Warning: ~==~ and ~!=~

- Do not use ~==~ and ~!=~

#+BEGIN_SRC javascript
let g = 10;
let h = '10';

g === h;   // false, comparing numbers and strings
g ==  h;   // true, Javascript converts h to a number first (DANGER)

g + 1 == h + 1;  // false (DANGER)
#+END_SRC

#+BEGIN_NOTES
Javascript has two other equality operators, the double-equals, and the
bang-equals.

You will probably see them in older code.

You should not use them.

Rembeer how values have types -- a number, or a string say.
Triple-equals returns true only if the values are the same and the
types are the same.  In this first comparison here it returns false
because the types don't match.

Single-equals and bang-equals don't do this. If the types don't match it
tries to convert them. So on this line here the result is true, because
it convers the string one-zero to the number ten first, and that is
equal.

This can lead to very strange behaviour. For example, if you have two
values that are identical according to double-equals, and add 1 to both
values you think that the results would be the same.

But they're not, because the plus-sign in Javascript does different
things depending on whether the value is a number or a string.

This can lead to subtle bugs, so always use triple-equals and
bang-equals-equals.
#+END_NOTES

** Reminder: =if= statement syntax

#+BEGIN_SRC javascript
if (expression) {
  // Code that only runs if 'expression' is true
  //
  // We call this the "body" of the "if" block.
}
#+END_SRC

#+BEGIN_NOTES
So as a quick reminder after all that, this is the structure of an
=if= statement.

We have the =if= keyword, an expression in parentheses, and then the
code to run if the expression is true inside curly brackets.
#+END_NOTES

** Exercise: Only log the key if it's =Enter=                      :exercise:

#+BEGIN_SRC javascript :noweb yes
<<EventKeyLog>>
#+END_SRC

#+BEGIN_NOTES
Here's our current logging code.

Change this so that the key is only logged if it's =Enter=

[Wait]
#+END_NOTES

*** Exercise (hint): Only log the key if it's =Enter=

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      if (/* What goes here? */) {
        console.log(event.key);
      }
    });
  });
#+END_SRC

** Solution: Only log the key if it's =Enter=
   :PROPERTIES:
   :REQUIREMENTS: webstorm
   :END:

#+NAME: EnterKeyLog
#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      if (event.key === 'Enter') {
        console.log(event.key);
      }
    });
  });
#+END_SRC

#+BEGIN_NOTES
If this is working then you should see that the log message only
appears when you press the Enter key.

[Demo this in WebStorm to show the control flow changing]
#+END_NOTES
** Exercise: Adding the item if the ENTER key is released          :exercise:
   :PROPERTIES:
   :END:
#+BEGIN_SRC javascript :noweb yes
<<EnterKeyLog>>
#+END_SRC

#+BEGIN_NOTES
So, back to our code. And the last thing we need to do here is to
replace the logging code with code that creates the new list item
and appends it to the list, exactly as the code for clicking the
button does.

Off you go.

[Wait]
#+END_NOTES
** Solution: Adding the item if the ENTER key is released
#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // ...
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      if (event.key === 'Enter') {
        let inputBox = document.getElementById('item');
        let li = createNewListItem(inputBox.value);
        document.querySelector('ul').appendChild(li);
      }
    });
  });
#+END_SRC

#+BEGIN_NOTES
And here's that final part of the function.

We listen for the keyup event, and check to see if it's the Enter
key here.

If it is then this block will run, and this is the same code that we
used to create a new list item and add it to the list.
#+END_NOTES
** Recap: What have we learned?
#+REVEAL_HTML: <div class="leftcol">
- Events fire for keypresses
  - =keyup=
  - =keydown=
  - =keypress=
- The =event= parameter
  - Holds event-specific information
  - MDN documentation has info
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Decisions with =if=
  - Expressions, true/false values
- Different comparison operators
- Don't use ~==~ and ~!=~
#+REVEAL_HTML: </div>
** Add and commit the changes
* Clear the input widget after adding an item
** Problems
- The user has to delete the text in the input widget
- And if they double-click, or press =Enter= twice then the item is added twice
- Fix this by clearing the =input= widget after appending the list item
- We've already seen how

** Exercise: Clear the input widget                                :exercise:

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // Existing code that adds to the list

      // <-- new code goes here
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      // Existing code that adds to the list

      // <-- new code goes here
    });
  });
#+END_SRC

** Solution: Clear the input widget

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // Existing code that adds to the list

      inputBox.value = '';
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      // Existing code that adds to the list

      inputBox.value = '';
    });
  });
#+END_SRC

** Add and commit the changes
* Setting the input focus
  :PROPERTIES:
  :TOPICS:   focus scope
  :END:
** Focus means "Where do your keystrokes go?"

#+BEGIN_NOTES
On a form with multiple controls, like this (an input widget and a
button), where do you keystrokes go?

For example, you can press SPACE to click the button. Or you can
press SPACE to put a space in the input widget. How does the system
decide what happens when SPACE is pressed?

We say that there is the *focus*. Only one widget at a time has
the focus. It's where your clicks and keystrokes go.
#+END_NOTES

** The focus moves with TAB key                                    :exercise:

#+BEGIN_NOTES
Click on the input widget.

You should see a blue highlight around it -- the colour might change
depending on your system.

This highlight means that the input widget has the focus.

Press the TAB key. The focus should have shifted to the button.

[Wait]

Press the TAB key again. Where has the focus gone now?

[Wait]
#+END_NOTES

** Javascript has methods to set the focus

- [[https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus][MDN element focus]]

#+BEGIN_NOTES
Javascript provides methods to set the focus to a given element.

Do this search to read up on how to do it.
#+END_NOTES

** Exercise: Give the input widget the focus after adding an item  :exercise:

- No code hint this time. See how you do!

#+BEGIN_NOTES
[Wait]
#+END_NOTES
** Solution: Give the input widget the focus

#+BEGIN_SRC javascript
  document.addEventListener('DOMContentLoaded', function(event) {
    document.querySelector('button').addEventListener('click', function(event) {
      // Existing code that adds to the list and clears the box.

      inputBox.focus();
    });

    document.querySelector('input').addEventListener('keyup', function(event) {
      // Existing code that adds to the list
    });

    let inputBox = document.getElementById('item');
    inputBox.focus();
  });
#+END_SRC

#+BEGIN_NOTES
Did your changes look like this?

[Wait]

We had to add this in two places.

The first is in the event listener for the button click. When the user
clicks the button the focus moves to the button, so we have to send
it back to the input widget.

We *don't* have to do it when the user presses ENTER in the input
widget, because the focus doesn't move at that point -- it stays
in the widget.

I found that when the page is loaded nothing has the focus. So I've
explicitly set the focus to the input widget when the DOM content
had loaded as well.

[Questions? Any problems?]
#+END_NOTES

** Add and commit the changes

* A quick refactoring

#+INCLUDE: "shopping-3.js" :lines "26-45" src javascript

#+BEGIN_NOTES
This is my code at this point (just for the event listeners, this
isn't the code that creates the list item).

Your code should look similar. I've used method chaining, you might
not have, but the general structure of the code should be the same.

I'm going to do a quick refactoring of this.

I don't like that the input widget has to be found three different
times. It clutters up the code a bit, and makes it a little harder
to focus on what's going on.

And the shopping list also has to found twice, so lets remove that
duplication.

It also gives me the chance to explain *scope* to you, so let's do
that.
#+END_NOTES

** Refactored: variables at higher scopes

#+INCLUDE: "shopping-4.js" :lines "26-47" src javascript -n

#+BEGIN_NOTES
This is the refactored code.

On lines two and three I declare and initialise two variables, one
for the inputBox, one for the shopping list.

Then I use these throughout the rest of function.

So lets talk about *scope* for a second.

When we declare variables in Javascript we say that they have a
*scope* (you might also hear the word *visibility* used).

Very roughly, Javascript uses these curly brackets to indicate where
scopes start and end.

And because we can have curly bracket sections inside curly bracket
sections, we say that they are nested inside each other.

This is very similar to the way that HTML elements are nested inside
one another.

You can think of this as creating different *levels* of scope. Each
new curly bracket pair in the nested set increases the scope level by
one.

The rule is that a variable is visible in its scope, and any scopes
that are nested inside it.

I'll use this code to explain, and then we'll do a couple more examples.

At the very top level is the outermost, or *global* scope. Anything at
this scope is visible to everything else.

In this code example we don't have any variables at the global scope.

Line 1 introduces a curly bracket, so we know a new scope has been
created. Let's call this the L1 scope.

We define two variables in the L1 scope.

Line 5 uses the =inputBox= variable. We're in L2 scope and the
variable was defined in L1, so this is fine.

Line 5 also introduces a curly bracket, so everything from there on in
is at L2 scope.

Line 6 has another one -- the if() body -- so L3 scope starts there.
That uses =shoppingList= and =inputBox=, both L1 scope, so visible.

Line 9 has a closing curly brace, so we jump up one scope level, and
we're back to L2 scope.

On line 11 I can use the =inputBox= variable instead of calling
=querySelector= again.

Lines 13 through 18 are very similar. Importantly, when the L2 scope
is created in line 13, and the L3 scope in line 14, these are
*different* from the L2 and L3 scopes from earlier

This is one of the reasons why we're careful to indent code -- the
indentation also helps to show the scopes, and prevent mistakes.
#+END_NOTES

** Refactored: variables at higher scopes

#+INCLUDE: "scope.html" src javascript -n

#+BEGIN_NOTES
Here's a somewhat contrived example that maybe helps.

In our script element we start in global scope. That's where
the =a= variable is defined, so it's in global scope.

Our =scope= function creates an L1 scope. The =b= and =c=
variables are in this scope.

The =if= statement creates an L2 scope. Crucially, inside
this scope we create a new =c= variable. This means that that
=c= variable from line 6 is temporarily hidden, and replaced with
this new =c= variable.

We exit the L2 scope on line 12, back to the L1 scope.

The log on line 14 shows the *original* version of =c=, not the
one from line 10.

Finally, the log statement on line 17 generates an error. We're
back in global scope here, and =b= was defined in an L1 scope,
so it's not visible.

Is that -- somewhat -- clear?
#+END_NOTES

** Quick note on the backticks, =`=
   :PROPERTIES:
   :TOPICS:   backticks
   :END:

#+BEGIN_SRC javascript
let a = '[a:g]';
let b = '[b:1]';
let c = '[c:1]';

console.log(a + ' ' + b + ' ' + c); // "[a:g] [b:1] [c:1]"
console.log(`${a} ${b} ${c}`);      // "[a:g] [b:1] [c:1]"
#+END_SRC

#+BEGIN_NOTES
When you want to include a variable's value in a string we've
been doing string concatenation with the plus sign, as in the first
example.

If you use backticks, as in the second example, you can put the
value of the variable in the string by using this syntax with a
dollar sign, an opening curly, the name of the variabe, and a
closign curly.

As you can see, it can be quite a bit easier to read.
#+END_NOTES

* Prevent empty items from being added
- Pressing Enter or clicking the button adds an item
  - Even if it's the empty string

#+BEGIN_NOTES
Now that we're refactored the code slightly lets move on to the
next problem -- prevening empty items from being added.

This is the current problem.

How should we solve it?

[Wait]
#+END_NOTES

** Rules
- If the input widget is empty
  - Pressing =Enter= in the input widget should do nothing
  - The button should be disabled / clicks ignored
** Multiple parts to this problem
- How do we say that input is required?
- How do we disable the button?

* Using =if= to require input                                      :exercise:

#+INCLUDE: "shopping-4.js" :lines "26-47" src javascript -n

#+BEGIN_NOTES
Here's our code again.

We already use an =if= statement here (line 12) to check to see
if the value of the =event.key= property is correct.

How can we use extra =if= statements to see if the =inputBox=
=value= is not the empty string?

[Wait]
#+END_NOTES

** (hint) Which comparison operator to use?

#+BEGIN_SRC javascript :noweb yes
<<string-comparison-operators>>
#+END_SRC

** Solution: Using =if= to require input

#+BEGIN_SRC javascript
if (inputBox.value !== '') {
  // Code to add the listitem goes here
}
#+END_SRC

#+BEGIN_NOTES
We can wrap our code in this =if= statement. The code inside the
body of the =if= will only run if =inputBox.value= is not the empty
string.

If you haven't already done that, do that, and make sure it works.

[Wait]
#+END_NOTES

** Solution: Using =if= to require input

#+INCLUDE: "shopping-5.js" :lines "26-49" src javascript -n

#+BEGIN_NOTES
Here's the new code, with the additional =if= statements starting
on line 6 and 14.

Everyone OK with this change? It makes sense?

[Wait]

OK, so add this change to your file, and commit as normal.

[Wait]

Now that we've done that, there's a problem with this code.
Can anyone tell me what it is?
#+END_NOTES

** Problem: Only looks at empty strings

#+BEGIN_SRC javascript
if (inputBox.value !== '') {
  // Code goes here
}
#+END_SRC

- Only looks at completely empty strings
- What if the user has typed in one space?
- Or three spaces? Or 15?

#+BEGIN_NOTES
This is a very specific check -- it only looks to see if the string
is completely empty.

If the user has typed in a space, or lots of spaces, the string
will no longer be empty.

So the test will pass and the user will have entered what looks like
an empty shopping list item. We'll know it's not really empty, but
it still looks like a problem to them.

So we'll have to fix that.
#+END_NOTES

** Dealing with whitespace                                         :exercise:

- [[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String][MDN string]]]
- Review the available string methods
- Are there any that deal with whitespace?

#+BEGIN_NOTES
Lets see if we can figure out how to deal with this.

Find the MDN documentation for strings by doing this search.

On that page you'll see long section called "Methods". Review that
section, looking for methods that deal with whitespace.

Are there any methods that would let us deal with potential whitespace
in the string?
#+END_NOTES

** The =trim= method                                               :exercise:

#+BEGIN_QUOTE
Trims whitespace from the beginning and end of the string.
#+END_QUOTE

#+BEGIN_NOTES
In case it's not clear, 'trim' means remove.

So this takes the string, and removes any whitespace that appears
at the beginning or end of the string

On the general string page is a link to the more detailed page for
the =trim= method. Follow that link (the top of the page should say
"String.prototype.trim()". There you'll see some more examples and
a console you can play around with.

Use that to get familiar with the method, then figure out what we
should change in our code to use it to make the check work properly.

Make that change to your code, and check that empty items aren't being
added to the list any more.

[Wait]
#+END_NOTES

** Solution: Using =if= and =trim= to require input

#+INCLUDE: "shopping-6.js" :lines "26-49" src javascript -n

#+BEGIN_NOTES
Here's what I came up with.

I use =trim()= in both of the =if= expressions so that the input
string is trimmed of all whitespace.

That's here on line 6 and on line 14.

But I also make sure that the input is trimmed when it's added to
the list, here on line 7 and on line 16. That's probably worth a
refactor later, but it will do for the moment.

Everyone OK with this so far?

[Wait]
#+END_NOTES

** Add and commit the changes

* Disabling the button                                             :exercise:

- [[[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button][MDN button disable]]]

#+BEGIN_NOTES
With this change in place pressing the Enter key or clicking the
button won't do anything while the input box is empty or only
contains whitespace.

This is good, but we can go a step further.

At the moment the button still looks active when there's nothing
that can be added.

This is a visual clue to the user the button can be clicked, so
they're going to be surprised when clicking the button does
nothing.

You know the drill by now -- go and look for an MDN article that
mentions =button= and =disable=, and see if you can figure out
how to mark a button as being disabled.

[Wait]
#+END_NOTES

** Solution: Disabling the button                                  :exercise:

#+BEGIN_SRC javascript
let button = document.querySelector('button');
button.disabled = true;  // Disable the button
button.disabled = false; // Enable the button
#+END_SRC

#+BEGIN_NOTES
Buttons have a =disabled= value that can be set. When it's
=true= the button appears to be disabled.

When it's set to =false= the button is enabled again.

Load your shopping list page in to the browser, and open the console.

Try these commands. Notice what happens visually to the button when
you disable it. Try clicking on it when it's disabled and see what
it does.

Then enable it, watch the visuals change, and try clicking on it
again.

[Wait]
#+END_NOTES

** Where should we put this code?

#+INCLUDE: "shopping-6.js" :lines "26-49" src javascript -n

#+BEGIN_NOTES
Now that we know how to disable the button, we need to think about
where the code should go.

Here's my current code again. Where in this should we put the code
that's going to control if the button is enabled or disabled?

[Wait]

We need to control the button's visibility every time the user
presses a key.

There are two possibilities -- either the input is empty, or its
not.

If it's empty we should disable the button, and if it's not empty
we should enable the button.

We already have one =if= block for if the input is not empty. So
we can add new code there.

We'll need another =if= block for the case where the input is not
empty.

And we need to find the button.

So go ahead and add code here, immediately after my line 14 that
enables the button.

And add another =if= statement after line 19 that disables the
button if the input is empty.

And you'll need a variable for the button.
#+END_NOTES

** Solution: Disabling the button, variables

#+INCLUDE: "shopping-7.js" :lines "26-30" src javascript -n 26

#+BEGIN_NOTES
I've had to split the code over three slides to show it all.

The first part is the top of the =DOMContentLoaded= listener.

All I've done here is added a third variable, =addItemButton=,
and found the first button in the DOM.

Make sense?

[Wait]
#+END_NOTES

** Solution: Disabling the button, input widget

#+INCLUDE: "shopping-7.js" :lines "40-56" src javascript -n 40

#+BEGIN_NOTES
Jumping ahead to my line 40, and the =keyup= listener for the input
widget I've made two changes.

The first is line 3 of this code. The =if= statement immediately
before means that this code will only run if the input widget is
*not* empty.

So we know that the button should be enabled here. And to enable
the button you set its =disabled= property to =false=.

The second change is lines 10-12. We need to deal with the case
where the input box *is* empty, so I have a second =if= statement
here to deal with that.

Those of you with more programming experience are probably wondering
why I didn't use an =else= clause here. I'm coming to that in a bit,
don't worry.
#+END_NOTES

** Solution: Disabling the button, button widget

#+INCLUDE: "shopping-7.js" :lines "31-39" src javascript -n 31

#+BEGIN_NOTES
Finally, and jumping back up the code, I've been a bit sneaky.

Earlier, I didn't tell you that when the button is clicked to add
an item to the list it should disable itself. This is because
one of the things the button does when it's clicked is empty
out the input wideget (here, on line 34).

But there's no =keyup= event fired when that happens, so the
button has to know to disable itself.

Do you have this bug in your code? Does your button disable itself
after it's clicked?

[Wait]

Fix your code so that it disables the button in all cases, then
add and commit your changes.

[Wait]
#+END_NOTES

* Recap: What have we learned
#+REVEAL_HTML: <div class="leftcol">
- =.focus()= method
- Variable scopes
- Strings with backticks =`=
- String methods
  - =.trim()=
- =.disabled= property
#+REVEAL_HTML: </div>

* Refactoring: =const=

#+BEGIN_NOTES
I mentioned that I wanted to refactor this code, and there are a
few things I want to do and introduce you to.
#+END_NOTES

** Recap: =let=

- =let= declares a variable with a value that can change

#+BEGIN_SRC javascript
let a = 10;
a;            // 10
a = 20;
a;            // 20
let b;        // Variable without initial value
b;            // undefined
b = 30;
b;            // 30
#+END_SRC

#+BEGIN_NOTES
We're familiar with the =let= keyword.

We use it to declare a variable, and optionally give it a value.

We can later change the value in the variable, and use the new
value.

We can also declare a variable that starts out with the
=undefined= value, and then give it a value later.

This is great when the value might legitimately change in the
future.

But what do you do if you know the value should never change?
#+END_NOTES

** Introducing =const=

- =const= declares a variable with a value that can't change
  - We call this a *constant*

#+BEGIN_SRC javascript
const c = 15;
c;            // 15;
c = 20;       // Uncaught TypeError: Assignment to constant
              // variable.

const d;      // Uncaught SyntaxError: Missing initializer
              // in const declaration.
#+END_SRC

#+BEGIN_NOTES
When we know that the value should never change we should use the
=const= keyword instead.

This does a couple of useful things.

First, if the value shouldn't change, and you have a bug in the code
that tries to change the value then Javascript will tell you when that
code runs.

This is much better than if the code silently succeeded by mistake.

Second, it helps communicate your intent to the next programmer
that comes along. Now they know that this variable is not supposed
to change in value.

Third, it allows other tools to spot problems even before the code
runs. WebStorm, for example, will analyse the code and tell you
that you've tried to assign a value to a constant variable as you
are writing the code, which is very helpful in preventing bugs in
the first place.
#+END_NOTES

** Replacing =let= with =const=

- =Edit= > =Find= > =Replace...=
- Replace =let= with =const=

*** Replacing =let= with =const=

#+INCLUDE: "shopping-8.js" :lines "7-25" src javascript

*** Replacing =let= with =const=

#+INCLUDE: "shopping-8.js" :lines "26-30" src javascript

* Refactoring: =else=

#+BEGIN_SRC javascript
if (expression) {
  // Body of the if-statement
}
#+END_SRC

#+BEGIN_NOTES
This is the =if= statement that we've been using so far. We
have the =if= keyword, an expression in parentheses, and then
the body surrounded by curly brackets.

The code in the body is only executed if the expression is true.

But what if we want to do something else if the expression is false?
#+END_NOTES

** The =else= keyword

#+BEGIN_SRC javascript
if (expression) {
  // Code run if expression is true
} else {
  // Code run if expression is false
}
#+END_SRC

#+BEGIN_NOTES
We can use the =else= keyword. This starts immediately after the
closing curly bracket of the =if= statement, and is the keyword,
followed by its own curly brackets, with the code to be run
inside them.

Does this make sense to everyone?

[Wait]
#+END_NOTES

** Exercise: Using the =else= keyword

#+BEGIN_SRC javascript -n
function elseTest(num) {
  if (num < 10) {
    console.log('less than 10');
  } else {
    console.log('bigger than 10');
  }
}
#+END_SRC

#+BEGIN_SRC javascript
elseTest(9);
elseTest(11);
#+END_SRC

#+BEGIN_NOTES
Try this exercise. In the Chrome console type this function, and
then test it with these two arguments.

What's printed?

[Wait]
#+END_NOTES

*** Exercise: Using the =else= keyword                             :exercise:

#+BEGIN_SRC javascript -n
function elseTest(num) {
  if (num < 10) {
    console.log('less than 10');
  } else {
    console.log('bigger than 10');
  }
}
#+END_SRC

#+BEGIN_SRC javascript
elseTest(9);
elseTest(11);
#+END_SRC

#+BEGIN_SRC javascript
elseTest(10);
#+END_SRC

#+BEGIN_NOTES
Now try it with =10= as the argument.

What's printed?

[Wait]

Do you see why?

[Wait]

There are three possible answers to this question, but we've only
covered two of them.
#+END_NOTES

*** Exercise: Using the =else= keyword                             :exercise:

#+BEGIN_SRC javascript -n
function elseTest(num) {
  if (num < 10) {
    console.log('less than 10');
  } else if (num > 10) {
    console.log('bigger than 10');
  } else {
    console.log('same as 10');
  }
}
#+END_SRC

#+BEGIN_SRC javascript
elseTest(9);
elseTest(11);
elseTest(10);
#+END_SRC

#+BEGIN_NOTES
We can have a chain of if/else clauses that test various things

Look at the syntax on line 4 -- as well as the =else= keyword we have
a new =if= statement that checks to see if the number is larger than
10. Finally, on line 6 we have a final =else= that covers all the
other cases.

Try this.

[Wait]
#+END_NOTES

** Exercise: Refactoring with the =else= keyword                   :exercise:

#+INCLUDE: "shopping-7.js" :lines "40-53" src javascript -n 40

#+BEGIN_NOTES
So, lets refactor this bit of code here.

Instead of the two different =if= blocks on line 1 and line 9, replace
the line 9 one with an =else= clause.

Do that, and make sure that program still works as expected.

[Wait]
#+END_NOTES

** Solution: Refactoring with the =else= keyword

#+INCLUDE: "shopping-9.js" :lines "40-51" src javascript -n

#+BEGIN_NOTES
Here's the solution. How did everyone get on with it?

[Wait]

OK, go ahead and add and the commit your changes.

[Wait]

Now, I still don't like this code very much. There are a number of
red flags for it that stand out to me.

I don't expect you to notice any problems -- this is a matter of
taste and experience. But I'm going to walk you through them, and
then refactor them out one by one.

Those problems are:

- Repeated calls to inputBox.value.trim()

Now, we only do this twice in this function, but it's clear that
every time we need the value from the input box we should trim
it.

To make this very clear I'd like to create a constant that contains
the trimmed value from the input box, and use that instead. That
should help make the code a bit clearer as well.

- There are =false= and =true keywords inside an =if= body.

This is a big red flag. =if= statemtents work by evaluting the
expression inside the parentheses to either a true or a false
value.

When you see a literal =true= or =false= inside the body of the
=if= statement, as we have here, that's an indicator that maybe
this =if= block isn't needed, and the value can be assigned
directly.

Don't worry if that's not very clear yet, I'm going to give some
examples.

- Too much nesting.

This bit of code has 3 levels of nesting. There's one for the
outermost function, and then we have two =if= statements nested
inside each other, for three levels in total.

That's not super excessive. But in general, the more levels
of nesting you have the more complicated the code is to understand.
It makes it more difficult for you to glance at it and see what
it's going.

If we can reduce the amount of nesting then we can make the code
simpler and easier to read.

And the simpler and easier to read it is the less chance there
are any bugs.
#+END_NOTES

* Refactoring: Hoisting duplicate code in to a variable

#+INCLUDE: "shopping-10.js" :lines "40-53" src javascript -n 40

#+BEGIN_NOTES
Here I've created a new constant variable called =trimmedValue=
and set it to the trimmed copy of whatever's in the input widget.

Then I use this constant in two places, once in the =if= statement,
and once in the call to =createNewListItem=.

Does this make sense to everyone?

[Wait]

OK, make this change to your code, check that it works, then
add and commit.

[Wait]

Now, lets look at these =true= and =false= values inside the
=if= block.
#+END_NOTES

* Refactoring: =false= and =true= inside the =if= block

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC javascript
if (expression) {
  // Body
}
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
let x = 10;
let y = x === 9;
y;                  // false
y = x < 20;
y;                  // true
#+END_SRC
#+REVEAL_HTML: </div>

- Expression must evaluate to either =true= or =false=

#+BEGIN_NOTES
Remember the structure of an =if= block.

In particular, the code inside the parentheses immediately
after the =if= keyword is an expression that must evaluate
to either a true or false value.

We can take the result of an expression and assign it to
a variable.
#+END_NOTES

** Refactoring: =false= and =true= inside the =if= block

#+BEGIN_SRC javascript
const isEmpty = inputBox.value.trim() === '';
#+END_SRC

#+BEGIN_NOTES
This means we could write something like this. If the trimmed
value is the empty string then =isEmpty= will be true.

And if the trimmedValue is not empty then =isEmpty= will be
false.

Does that make sense?

[Wait]
#+END_NOTES


** Refactoring: =false= and =true= inside the =if= block

#+BEGIN_SRC javascript
const isEmpty = inputBox.value.trim() === '';
#+END_SRC

#+BEGIN_SRC javascript
addItemButton.disabled = inputBox.value.trim() === '';
#+END_SRC

#+BEGIN_NOTES
But this is also exactly how we want the value for the
=disabled= property to be calculated.

So there's no need to create a new variable, we can set
the value directly.
#+END_NOTES

** Refactoring: =false= and =true= inside the =if= block

#+INCLUDE: "shopping-11.js" :lines "40-53" src javascript -n 40

#+BEGIN_NOTES
This is what that looks like.

This is not obviously better than just using the literal
=true= and =false= values, right?

Our code is now longer on line 44 and 50, and it's also
duplicated.

Wasn't I just talking about hoisting duplicated code in to
a variable so that the value can be re-used?

Yes I was.

The reason for this step is that it lets us see that this bit of code
in both branches of the =if / else= block is identical. Check, lines
44 and 50 are the same.

Since they're the same, they don't need to be inside the =if / else=
block at all.

And if we remove line 50 to outside the =else= block then we don't
need the =else= either.

Before I show you the resulting code, does that make sense?

[Wait]
#+END_NOTES


** Refactoring: =false= and =true= inside the =if= block

#+INCLUDE: "shopping-12.js" :lines "40-52" src javascript -n 40

#+BEGIN_NOTES
On line 42 I've set the =disabled= property on the =addItemButton=.

This allows me to remove that code from inside the =if= block, and
completely remove the =else= block.

This code does exactly the same thing as the previous code, but it's
a little but shorter and a little bit clearer.
#+END_NOTES

* Refactoring: Nesting

#+INCLUDE: "shopping-12.js" :lines "40-52" src javascript -n 40

#+BEGIN_NOTES
This is our current code. It's definitely better, but I still don't
like the nesting.

This is definitely a matter of taste, but I'd prefer it if we didn't
have =if= blocks inside =if= blocks we can help it.

We can refactor those, but first we need to talk about how we return
from a function.
#+END_NOTES

** Flow of control

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_CENTER
Normal flow of control
#+END_CENTER
#+BEGIN_SRC javascript
function foo() {
  // Do something

  // Do something else
}

// Some code
// ...

foo();

// Some more code
// ...
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_CENTER
Flow of control with an =if=
#+END_CENTER
#+BEGIN_SRC javascript
function foo() {
  // Do something

  if (expression) {
    // Only happens when
    // expression === true
  }

  // Do something else
}

// Some code
// ...

foo();

// Some more code
// ...
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here are two main types of flow of control we've seen so far.

On the left is without an =if= statement. Our code runs, and
we call a function. Control flow jumps in to the function, runs
all the way through, and then jumps back out of the function to
where it left off.

On the right is control flow with an =if= statement. It's very
similar, but in the function there's a chance that some of the
code might not run if the expression is false.
#+END_NOTES

** Returning early from a function

#+REVEAL_HTML: <div class="leftcol">
- =return= keyword allows early return from a function
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC javascript
function foo() {
  // Do something

  if (expression) {
    // Only happens when
    // expression === true
    return;
  }

  // Do something else
}

// Some code
// ...

foo();

// Some more code
// ...
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We can use a new keyword, called =return=, to return earlier than
normal from a function.

In this example, if the expression in the =if= statement is true
then the code in the body of the =if= statement will be run, and
then the function stops and control returns to where it was called
from. The code under "// Do something else" is never run in this
case.
#+END_NOTES

** Solution: Returning early from a function

#+INCLUDE: "shopping-13.js" :lines "44-59" src javascript -n 40

#+BEGIN_NOTES
Here's what our function looks like using =if= statements and
returning early.

We still have two =if= statements, but they're no longer nested
inside one another, making the code a bit simpler in my opinion.

The trade off is that function is now a bit longer.

This is a pretty good pattern to follow when writing functions.

Specifically:

- Start with a block of code defines any variables or constants
that you need.

- Then have a block of code that checks to see if the function should
do any work, or if it should return early.

- Finally, have the code that actually does what the function is
supposed to do.

This clearly separates out the different responsibilities of the
function, and reduces the amount of nesting and duplicated code.

Does this make sense? Any questions?

[Wait]

OK, go ahead and make the equivalent change to your =keyup=
handler, test it, add and commit.

[Wait]
#+END_NOTES

** Solution: Returning early from a function

#+INCLUDE: "shopping-13.js" :lines "31-43" src javascript -n 31

#+BEGIN_NOTES
And we can make a very similar change to the click handler for
the button.

Again, we save the trimmed value in to a constant, and perform
an early return if the value is empty.

Any questions on this?

[Wait]

OK, go ahead and make the equivalent change to your =click=
handler, test it, add and commit.

[Wait]
#+END_NOTES

* Refactoring: Before and after
  :PROPERTIES:
  :HTML_CONTAINER_CLASS: smaller
  :END:

#+INCLUDE: "shopping-7.js" :lines "31-55" src javascript

#+REVEAL: split

#+INCLUDE: "shopping-13.js" :lines "31-61" src javascript

* Refactoring: Recap

- =const= to declare constant variables
- =if (...) { ... } else if (...) { ... } else { ... }= blocks
- Returning early from functions
  - =return= keyword
- Refactoring to remove nesting


* TODO UI followup work

#+REVEAL_HTML: <div class="leftcol">
- Choose a colour palette
- Header image
- Styling input elements
  - Red border when the input is empty?
- Different fonts and font-sizes
  - A font that looks like handwriting for the list?
- Using icons
  - Font Awesome, trash can icon for delete button
  - Shopping cart icon for "Add item"

#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Time for a change of pace.

We've been doing a lot Javascript, and it's been a while since
we touched CSS.

So now you've got some time to add some CSS
#+END_NOTES

* TODO Functionality followup work
- Adding a "Delete all" button
- Adding quantities
- Parsing quantities
- Reordering items in the list
- Drag/drop items in the list

* Add a "Delete all" button (or "Clear list")

#+REVEAL_HTML: <div class="leftcol">
- We know
 - How to create a button
 - How to listen for button clicks
 - How to find an element
  - =document.querySelector()=
 - How to delete an element
  - =el.remove()=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- We don't know
 - How to find all elements of a type
 - How to delete all elements of a type
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We want to be able to add a button called "Clear list".

When it's clicked we'll delete all of the list items that have been
added, so the list is empty.

We already know most of how to do this. We can create the button and
listen for clicks on it, and we can find individual elements. But
finding more than one element, or deleting more than element is new.

So lets learn how to do that.
#+END_NOTES

** =document.querySelectorAll()=

- =.querySelector(...);= returns first element
- =.querySelectorAll(...);= returns all elements
- As a =NodeList=

** =NodeList=?

- A collection of nodes in the DOM tree
- Organised as a list of things
- A bit like an array

** Array?
** Non-array variables

#+BEGIN_SRC javascript
let x = 10;
let y = 'This is a string';
let z = document.querySelector('body');
#+END_SRC

#+BEGIN_NOTES
Before we can progress much further though we need to expand our
understanding of Javascript variables and what they can contain.

So far we've been looking at variables as though they contain a
single thing.

That thing might be a number, or a string, or an element, but it's
always been just one thing.
#+END_NOTES

** Arrays of numbers

#+BEGIN_SRC javascript
let a = [1, 2, 3];

a[0];  // 1  (index 0)
a[1];  // 2  (index 1)
a[2];  // 3  (index 2)
a[3];  // undefined
a;     // [1, 2, 3]
#+END_SRC

#+BEGIN_NOTES
Here's how we declare and use an array.

Just like with regular variables we use =let= to declare them, and
we give them a name.

However, because the array variable can contain multiple values
we have to write those values inside square brackets, and separate them
with spaces.

This creates the array with three different values.

We say that each value is at a different *index* in array.

*Indicies* start counting at 0. So the first value in the array is at
index 0, the second value is at index 1, and so on.

To find out what value is in the array at a particular index we write the
name of the array variable, and then we put the index number that we are
interested in inside square brackets.

There should be no spaces between the name of the variable and the square
brackets.

If we try and use an index value that does not contain a value then we get
back the special =undefined= value that we've seen before.

We can also use the whole array, by giving its name. We use this if we want
to pass an array as a parameter to a function, for example.
#+END_NOTES

** Arrays of strings

#+BEGIN_SRC javascript
let b = ['Hello', 'Powercoders'];

b[0];  // "Hello";
b[1];  // "Powercoders";
#+END_SRC

#+BEGIN_NOTES
Values in an array don't have to be numbers, they can be strings to, as in
this example.

Using the index numbers to find out what values are at each index is
identical.
#+END_NOTES

** Arrays of mixed types

#+BEGIN_SRC javascript
let c = [100, 'Basel'];

c[0];  // 100
c[1];  // "Basel"
#+END_SRC

#+BEGIN_NOTES
And you can mix the types of the values in a single array. Here we have an
array where the first element in the array is a number and the second is a
string.
#+END_NOTES

** Index values can be expressions

#+BEGIN_SRC javascript
// let c = [100, 'Basel'];

let x = 1;
c[x];      // "Basel"
c[x - 1];  // 100
#+END_SRC

#+BEGIN_NOTES
Array index values don't have to be numbers -- they can be expressions that
evaluate to numbers as well.

In this example =x= is 1, so if we use that as the index value we get the
second element in the array.

If we substract 1 from x we get 0, which is why the second example returns
the first element in the array (remember, indices always start at 0).
#+END_NOTES

** Arrays have a =length= property

#+BEGIN_SRC javascript
// let c = [100, 'Basel'];

c.length;  // 2

c[c.length - 1];  // "Basel"
#+END_SRC

#+BEGIN_NOTES
Arrays are also objects, which means that they have properties and methods.

The only property we typically care about for an array is the =length=
property. This tells us how long the array is -- how many elements it
contains.

This is always one larger than the last index in the array. So you can use
the length property to find the value of the last element in the array like
this.
#+END_NOTES

** Single-element arrays

#+BEGIN_SRC javascript
let d = [1];

d.length;  // 1
#+END_SRC

#+BEGIN_NOTES
Even if an array is going to start with only a single element you must
still put the element inside square brackets, like this.
#+END_NOTES

** Empty arrays

#+BEGIN_SRC javascript
let e = [];

e.length;  // 0
#+END_SRC

#+BEGIN_NOTES
And it's possible to have completely empty arrays, with no elements. We
declare them like this.
#+END_NOTES

** Modifying arrays

#+BEGIN_SRC javascript
// let e = [];

e[0] = 1;
e[1] = 2;
e;         // [1, 2]
e[0] = 3;
e;         // [3, 2]
e.length;  // 2

e.length = 0;
e;         // []
e.length = 3;
e;         // [undefined, undefined, undefined]
#+END_SRC

#+BEGIN_NOTES
Assigning a value to an array is the same as assigning a value to a
variable, you use the equals sign.

However, you must specify the index in the array that you're assigning
in to.

If you assign in to an index that doesn't already exist, as in the first
two examples, then it's automatically created for you.

If you assign to an index that does exist then the value at that index is
replaced with the new value.

And if you change the length then the array shrinks or grows based on the
new length.
#+END_NOTES

** (some) Array methods

- =push=
- =pop=
- =shift=
- =unshift=
- =join=
- =foreach=
- Check MDN for more

#+BEGIN_NOTES
As objects arrays also have some useful methods, including =push=, =pop=,
=shift=, =unshift=, =join=, and =foreach=.

This isn't a complete list by the way, for that you can check out MDN.

#+END_NOTES
*** =push=

- Adds a new element to the end of the array
- Returns the new length

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.push(0);  // 4
x;          // [1, 2, 3, 0];
#+END_SRC

*** =pop=

- Removes the last element from the end of the array
- Returns the element removed

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.pop();    // 3
x;          // [1, 2]
#+END_SRC

*** =shift=

- Removes the first element from the array
- Returns the element removed

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.shift();  // 1;
x;          // [2, 3]
#+END_SRC

*** =unshift=

- Adds one or more elements to the front of the array
- Returns the new length

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.unshift(4, 5);  // 5
x;                // [4, 5, 1, 2, 3]
#+END_SRC

*** =join=

- Converts elements to strings
- Returns new string, joining the elements

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.join(' ');   // "1 2 3"
x.join(',');   // "1,2,3"
x.join(', ');  // "1, 2, 3"

[1, 2, 3].join(' ');  // "1 2 3"
#+END_SRC

*** =join=

#+BEGIN_SRC javascript
let x = ['Hello', 'Powercoders', 'Basel'];

x.join('');     // "HelloPowercodersBasel"
x.join(' ');    // "Hello Powercoders Basel"
x.join(' - ');  // "Hello - Powercoders - Basel"
#+END_SRC

*** =forEach=

- Calls a function once for each element

#+BEGIN_SRC javascript
let x = [1, 2, 3];

x.forEach(function(el) {
  console.log(el + 2);
});

// 3
// 4
// 5
#+END_SRC

** Iterables

- =forEach= *iterates* over the array

#+BEGIN_QUOTE
Iterate: To say or do again and again
#+END_QUOTE

#+BEGIN_QUOTE
Iterable: Something we can iterate over
#+END_QUOTE

#+BEGIN_NOTES
=forEach= is an important example here.

We say that it *iterates* over the array. Our function is called again
and again while there are elements in the array.

This means that our array is an example of an *iterable* -- something that
we can iterate over.
#+END_NOTES

** =NodeList= is not an array...

- ... but it is an *iterable*
- So we can iterate over it with =forEach=
- And we can remove elements with =.remove()=

** Exercise: Removing nodes

- Open the shopping list in the browser
- Add some items
- Open the console
- Find all the list items using =querySelectorAll()=
- Iterate over them using =forEach()=
- Call the =remove()= method in the function

** Solution: Removing nodes

#+BEGIN_SRC javascript
let items = document.querySelectorAll('li');
li.forEach(function(el) {
  el.remove();
});
#+END_SRC

** Adding a "Clear list" button

*** Exercise: Add a button

- Add a button next to the "Add item" button
- Set the =id= to =clear=
- Give the existing button an =id= of =add=

*** Solution: Add a button

#+INCLUDE: "shopping-15.html" :lines "14-21" src html

*** Exercise: Click listener to delete the listitems

- Add a =const= variable, store the "Clear list" button
- Add a click event listener that
 - Finds all the =li= elements
 - Removes them
 - Disables the "Clear list" button

*** Solution: Click listener to delete the listitems

#+INCLUDE: "shopping-15.js" :lines "31-37" src javascript

#+INCLUDE: "shopping-15.js" :lines "68-76" src javascript

*** Exercise: Enable the button when items are added

- Find both places in the code where items are added
- Modify both of them to enable =clearListButton=

*** Solution: Enable the button when items are added

#+INCLUDE: "shopping-15.js" :lines "37-51" src javascript

*** Solution: Enable the button when items are added

#+INCLUDE: "shopping-15.js" :lines "51-68" src javascript

*** Exercise: Disable the button when the page is loaded

- Disable the button when =DOMContentReady= fires

*** Solution: Disable the button when the page is loaded

#+INCLUDE: "shopping-15.js" :lines "76-80" src javascript

*** Conditionally disable the button when clicking delete item

- Deleting an item might need to disable the button
- If there are still items in the list then leave it enabled
- Otherwise, delete it
- Find the =deleteButton= click handler code
- Modify it to disable the button if there are no =li= elements

*** Hint: Conditionally disable the button when clicking delete item

- How do you find all the =li= elements?
- What property can you check to see if any elements were found?

*** Big hint

- How do you find all the =li= elements?

#+BEGIN_SRC javascript
const listItems = document.querySelectorAll('li');
#+END_SRC

- What property can you check to see if any elements were found?

#+BEGIN_SRC javascript
listItems.length;
#+END_SRC

*** Solution: Conditionally disable the button when clicking delete item

#+BEGIN_SRC javascript
deleteButton.addEventListener('click', function(event) {
  listItem.remove();

  const clearListButton = document.querySelector('button#clear');
  const listItems = document.querySelectorAll('li');

  if (listItems.length === 0) {
    clearListButton.disabled = true;
  } else {
    clearListButton.disabled = false;
  }
});
#+END_SRC

*** Refactor: Remove the =if= statement

#+BEGIN_SRC javascript
deleteButton.addEventListener('click', function(event) {
  listItem.remove();

  const clearListButton = document.querySelector('button#clear');
  const listItems = document.querySelectorAll('li');

  clearListButton.disabled = listItems.length === 0;
});
#+END_SRC

*** Refactor: Remove the variables

#+INCLUDE: "shopping-15.js" :lines "19-25" src javascript

** TODO Alternative: Using =.firstChild=                           :noexport:

#+BEGIN_SRC javascript
// el == the ul element
while (el.firstChild) {
  el.removeChild(el.firstChild);
}
#+END_SRC

* Add quantities

* Parsing quantities

* Re-order items in the list

* Drag-drop items in the list

* Javascript syntax followup work

* TODO JSDoc comments
  :PROPERTIES:
  :TOPICS:   jsdoc
  :END:

** Good practice to comment functions
   :PROPERTIES:
   :REQUIREMENTS: webstorm
   :END:

- Programming is about communication
  - Good comments cover *what*, and *why*
  - The code describes *how*
- Javascript does not have a single standard for comments
  - =JSDoc= is a widely adopted standard
  - IDEs understand JSDoc and do useful things with it

** Sample JSDoc

#+BEGIN_SRC javascript
/**
 * Creates and returns an 'li' element for inclusion in shopping list.
 *
 * @param {string} itemName Name of the item to add to the list
 * @returns {HTMLElement} li element
 */
#+END_SRC

- =/**=
- Function description
- Optionally, more detail about the function
  - Design decisions, links to documents, specifications, etc
- 0-n =@param= entries that describe each parameter
- 0-1 =@return= entry for the return value

#+BEGIN_NOTES
JSDoc comments all start with =/**= (slash, star, star). If you type
that before a function WebStorm will automatically prefill some of
the rest of the material.

The next line starts with a description of the function. Typically
you would try and keep this short -- keep it one line if possible.

If your "brief" description is longer than a line it's an indicator
that the function might be doing too much and needs breaking up in
to smaller functions.

If necessary you can include more information in new paragraphs after
the brief description. Here you can go in to more detail -- maybe
there's a specification you're trying to follow, or a design doc
that describes what the function needs to do. This would be a good
place to link to that information.

If the function takes any parameters then you describe them with
=@param= entries.

Each =@param= entry consists of the type of the parameter that the
function expects, in curly brackets. Here, our function expects that
the =itemName= parameter contains a string.

After that is the name of the parameter. And then a brief description
of what the parameter is for.

Finally, if the function returns a value then there is an =@return=
block that explains the value. This is like an =@param= block, only
without the "name" part -- it goes straight from the type in curly
brackets to the description.
#+END_NOTES

** Exercise: Add this JSdoc
#+BEGIN_SRC javascript
/**
 * Creates and returns an 'li' element for inclusion in shopping list.
 *
 * @param {string} itemName Name of the item to add to the list
 * @returns {HTMLElement} li element
 */
#+END_SRC

- Add this immediately before your =createNewListItem= function.
- Go to a place where the function is called, and press =Ctrl-Q=
- =File= > =Settings= > =Editor= > =General= > =Show quick documentation on mouse move=
- What do you think?
** TODO Followup material on comments and commenting style
- [[https://google.github.io/styleguide/jsguide.html#jsdoc][Google Javascript Style Guide]]
- Add more
* Event listeners and =this=
* Advanced: Using validity check to prevent invalid input
** TODO: Problem
** Things to check
- Should have a value (=required=)
