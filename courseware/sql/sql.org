#+TITLE: Databases and SQL
#+SETUPFILE: "../include/settings.org"
#+PROPERTY: :header-args:sql-mode :product sqlite
#+PROPERTY: :header-args:sql-mode+ :session powercoders

* A database is...

- Somewhere we can store data...
  - ... and easily retrieve data...
  - ... and add to the data...
  - ... and delete data

* That's very generic

- For example, the filesytem is a database
  - So that definition is not very helpful
- In addition, databases normally have
  - A special language used to search the data
- Different programs to manage databases exist

* Structured Query Language (SQL)

- Most of the time that language is SQL
  - General pronounced "sequel"
- Other query languages do exist

* Goals for this part of the course

- Install a database program
- Create a database with data in it
- Learn how to query the data to answer questions

* Introduction to SQLite

- We're using *SQLite*
- Small, fast, reliable, full-featured database
- Easy to install and manage
- Other databases include MySQL, Postgres, Oracle, SQL Server
  - More complex to install and manage
  - Very similar features to SQLite

** Installation

- https://sqlite.org/download.html
- Find the "Precompiled binaries" section for your operating system
  - FInd the =sqlite-tools-....zip= file
  - Download that

** Installation (Windows)

#+BEGIN_NOTES
[Demo this by projecting someone's laptop]
#+END_NOTES

** Installation (OS X)

#+BEGIN_NOTES
[Demo this by projecting someone's laptop]
#+END_NOTES

** Installation (Linux)

#+BEGIN_NOTES
[Demo this by projecting someone's laptop]
#+END_NOTES

* Using SQLite

- We do everything in the shell
- Run =sqlite3=

#+BEGIN_SRC shell
% sqlite3
SQLite version 3.27.1 2019-02-08 13:17:39
Enter ".help" for usage hints
Connected to a transient in-memory database
Use ".open FILENAME" to reopen on a persistent database.
sqlite>
#+END_SRC

#+BEGIN_NOTES
When we run the =sqlite3= comand we get something that's similar to the shell, or the Chrome console. There's a prompt (=sqlite>=) and it's waiting for us to type commands.

The message about the "transient in-memory database" is important. This means that anything we do will not be saved -- any data that we create will not be stored in to a database file.

We'll fix that shortly.
#+END_NOTES

** SQL vs SQLIte commands

- Two types of input to SQLite. Either:
  - SQL statements
  - Commands to SQLite
- All SQLite commands start with a =.=
  - =.help=
  - =.open ...=
  - =.exit= etc
- SQL statements are everything else

#+BEGIN_NOTES
When we're typing things in to SQLite we're typing one of two different types of things.

The first is commands that tell SQLite to do something -- for example, to show the help information, or to open a particular database, or to exit the programme.

This commands are *not* SQL, and they are specific to SQLite. Other databases that you use will have equivalent commands, but they might be called something different.

In SQLite all these commands start with a dot.

Everything else is SQL.
#+END_NOTES

** Exit SQLite

#+BEGIN_SRC sqlite
sqlite> .exit
#+END_SRC

#+BEGIN_NOTES
Right now, exit from SQLite by type =.exit=. You should be returned to your normal shell prompt.
#+END_NOTES

* Creating a database

- We're going to use a sample database called *Chinook*
- Represents a digital music store
- Records information about
  - Tracks
  - Albums
  - Artists
  - Invoices
  - Customers

** Download the database

- Open a shell
- Make sure you are in your home directory
  - *DO NOT* do this in the =poco= directory or any subdirectories
- Download the database from GitHub

#+BEGIN_SRC shell
% git clone https://github.com/lerocha/chinook-database.git
#+END_SRC

** Open the database

- Previous step created a directory called =chinook-database=
- Change to the correct directory

#+BEGIN_SRC shell
% cd chinook-database
% cd ChinookDatabase
% cd DataSources
#+END_SRC

- Open the database

#+BEGIN_SRC shell
% sqlite3 Chinook_Sqlite.sqlite
SQLite version 3.27.1 2019-02-08 13:17:19
Enter ".help" for usage hints.
sqlite>
#+END_SRC

* Database essentials

- Data is stored in one or more *tables*
  - Each table has a name
- Each record in the database is a *row* in the table
  - Each album, track, artist, customer, etc is a new row
- Each piece of data is a *column*
  - Each column has a *name*
  - Each column has a *type*
  - Different types of numbers and strings
- Just like a spreadsheet
  - Column names are A, B, C, D, etc

* First SQL query

#+BEGIN_EXAMPLE
sqlite> SELECT name, milliseconds FROM track LIMIT 10;
For Those About To Rock (We Salute You)|343719
Balls to the Wall|342562
Fast As a Shark|230619
Restless and Wild|252051
Princess of the Dawn|375418
Put The Finger On You|205662
Let's Get It Up|233926
Inject The Venom|210834
Snowballed|203102
Evil Walks|263497
#+END_EXAMPLE

- You might get different results

** Changing SQLite display defaults

 - With the database open type:

 #+BEGIN_SRC sqlite
 sqlite> .mode column
 sqlite> .header on
 #+END_SRC

** Re-run the previous query

- Press the =Up= arrow to find the query

#+BEGIN_EXAMPLE
sqlite> SELECT name, milliseconds FROM track LIMIT 10;
Name                                     Milliseconds
---------------------------------------  ------------
For Those About To Rock (We Salute You)  343719
Balls to the Wall                        342562
Fast As a Shark                          230619
Restless and Wild                        252051
Princess of the Dawn                     375418
Put The Finger On You                    205662
Let's Get It Up                          233926
Inject The Venom                         210834
Snowballed                               203102
Evil Walks                               263497
#+END_EXAMPLE

** What have we done?

- Entered and executed a SQL *statement*
- SQL statements always end with a =;=
- This is a =SELECT= statement
  - Also called a *query*

** =SELECT= statements

#+BEGIN_EXAMPLE
SELECT [columns] FROM [table];
#+END_EXAMPLE

- This is the simplest =SELECT=
- =SELECT= lets us find information in the database
- We list the columns we want, and the table we want them from

** =SELECT= statements

- The =track= table has columns called =name= and =milliseonds=

#+BEGIN_EXAMPLE
sqlite> SELECT name, milliseconds FROM track LIMIT 10;
#+END_EXAMPLE

- Normally =SELECT= returns everything
- =track= table has thousands of rows
- =LIMIT 10= says "Just return the first 10"

** Exercise: Change the query to return the first 20 rows

#+REVEAL: split

#+BEGIN_SRC sql
SELECT name, milliseconds FROM track LIMIT 20;
#+END_SRC

* Formatting queries

#+BEGIN_SRC sql
SELECT name, milliseconds
  FROM track
 LIMIT 10;
#+END_SRC

#+BEGIN_NOTES
The database doesn't care how the query is written -- you can use newlines, any number of spaces, and so on.

Also, you can write words like =SELECT= and =FROM= in upper or lower case.

This is exactly the same query as last time, just formatted differently.

I'm going to use this format from now on in the slides to make them easier to read, but you can continue to type them on one line if you want.

This is also a very common way to write queries in online documentation, so you'll probably see this a lot.
#+END_NOTES

* Filtering data

- SQL is about finding the specific information you want
- So far, =SELECT= returns *everything*
- We can ask for records (*rows*) with columns that contain specific data
- We use a =WHERE= clause for this

** Finding a specific row

#+BEGIN_SRC sql
SELECT name, milliseconds
  FROM track
 WHERE name = 'Let There Be Rock';
#+END_SRC

#+BEGIN_NOTES
In this example we want to find the single row where the track has this specific name.

This expression is similar to Javascript.

However, Javascript uses triple- (or double-) equals to check for equality. SQL only uses a single equals sign.
#+END_NOTES

** What if  the same name exists more than once?

#+BEGIN_SRC sql
SELECT name, milliseconds
  FROM track
 WHERE name = 'Iron Maiden';
#+END_SRC

- Should return 5 rows with different =milliseconds= values

** Text searching with wildcards

#+BEGIN_SRC sql
SELECT name, milliseconds
  FROM track
 WHERE name LIKE '%stairway%';
#+END_SRC

- =LIKE= is a comparison operator
- Right hand side is a pattern
- =%= is a like =*= for filenames
  - Means "match anything"
- So this is
  1. Find all rows in the table called =track=...
  2. ... with a name containing =stairway=...
  3. ... and return the values of the =name= and =milliseconds= columns

*** Exercise: Try searching for other tracks

#+BEGIN_SRC sql
SELECT name, milliseconds
  FROM track
 WHERE name LIKE '%PUT_SOMETHING_HERE%';
#+END_SRC

- What happens if you leave off the first =%=?
- What happens if you leave off the second =%=?

** Other comparisons work as you expect

#+BEGIN_SRC sql
SELECT name, milliseconds
  FROM track
 WHERE milliseconds > 500000
 LIMIT 10;
#+END_SRC

- =<=, =>=, ~<=~, ~>=~,
- =LIMIT= always comes last

** Query structure

#+BEGIN_SRC sql
SELECT [columns]     -- What to return
  FROM [table]       -- Where to find it
 WHERE [expression]  -- (optional) How to filter it
 LIMIT [number];     -- (optional) How many rows to return
#+END_SRC

- This is the structure we've learned so far
- =--= is how you write comments in SQL

** Complex expressions with =AND=

#+BEGIN_SRC sql-mode
SELECT name, milliseconds
  FROM track
 WHERE name LIKE '%stairway%'
   AND milliseconds > 500000;
#+END_SRC

* Calculating new column values

#+BEGIN_SRC sql-mode
SELECT UPPER(name), milliseconds / 1000
  FROM track
 WHERE name LIKE '%stairway%'
   AND milliseconds > 500000;
#+END_SRC

#+BEGIN_EXAMPLE
UPPER(name)         milliseconds / 1000
------------------  -------------------
STAIRWAY TO HEAVEN  529
STAIRWAY TO HEAVEN  657
#+END_EXAMPLE

#+BEGIN_NOTES
Values in columns can be operated on to create new columns.

In this example we use the =UPPER= function to convert the value in the =name= column to uppercase, and we divide the value in the =milliseconds= column by 1,000 to get the value in seconds.

Notice how, in the output, the column names show the operation that was performed.
#+END_NOTES

** Why isn't this =529.658= ?

- The original value for the first result is 529,658 milliseconds
- Divided by 1,000 that's 529.658
- Why do we get 529?

*** Integer division

- The =milliseconds= column has a type
  - =INTEGER=
- =1000= also has a type, =INTEGER=
- If we divide one =INTEGER= by another =INTEGER=, the result is always an =INTEGER=
- We have to force one of the values to be a floating point value

*** Forcing a float, one way

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql-mode
SELECT UPPER(name), milliseconds / 1000.0
  FROM track
 WHERE name LIKE '%stairway%'
   AND milliseconds > 500000;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
UPPER(name)                     milliseconds / 1000.0
------------------------------  ---------------------
STAIRWAY TO HEAVEN              529.658
STAIRWAY TO HEAVEN              657.293
#+END_EXAMPLE
#+REVEAL_HTML: </div>

*** Forcing a float, second way

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql-mode
SELECT UPPER(name), CAST(milliseconds AS FLOAT) / 1000
  FROM track
 WHERE name LIKE '%stairway%'
   AND milliseconds > 500000;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
UPPER(name)                     CAST(milliseconds AS FLOAT) / 1000
------------------------------  ----------------------------------
Stairway To Heaven              529.658
Stairway To Heaven              657.293
#+END_EXAMPLE
#+REVEAL_HTML: </div>

** Renaming columns with =AS=

#+BEGIN_SRC sql-mode
SELECT UPPER(name) AS name,
       milliseconds / 1000 AS seconds
  FROM track
 WHERE name LIKE '%stairway%'
   AND milliseconds > 500000;
#+END_SRC

#+BEGIN_EXAMPLE
name                seconds
------------------  -------------------
STAIRWAY TO HEAVEN  529
STAIRWAY TO HEAVEN  657
#+END_EXAMPLE

*** Using a column again

#+BEGIN_SRC sql-mode
SELECT UPPER(name) AS name,
       milliseconds,
       milliseconds / 1000 AS seconds
  FROM track
 WHERE name LIKE '%stairway%'
   AND milliseconds > 500000;
#+END_SRC


#+BEGIN_EXAMPLE
name                            Milliseconds  seconds
------------------------------  ------------  ----------
STAIRWAY TO HEAVEN              529658        529
STAIRWAY TO HEAVEN              657293        657
#+END_EXAMPLE

** Using renamed columns in the =WHERE= clause

#+BEGIN_SRC sql-mode
SELECT UPPER(name) AS name,
       milliseconds / 1000 AS seconds
  FROM track
 WHERE name LIKE '%stairway%'
   AND seconds > 500;
#+END_SRC

#+BEGIN_EXAMPLE
name                seconds
------------------  -------------------
STAIRWAY TO HEAVEN  529
STAIRWAY TO HEAVEN  657
#+END_EXAMPLE

#+BEGIN_NOTES
You can use the renamed column in the =WHERE= clause.

This is identical to the example on the previous slide, except that instead of using =milliseconds= we use =duration=, and check to see if it's larger than 500 instead of 500,000.
#+END_NOTES

* Changing the sort order

- The order in which results are returned is not guaranteed
- If you want a particular order you must include it in the query
- We use =ORDER BY=
  - *Important:* This is two words
  - *Not* =ORDER_BY=

** Using =ORDER BY=

#+BEGIN_SRC sql
  SELECT name,
         milliseconds / 1000 AS seconds
    FROM track
ORDER BY seconds
   LIMIT 10;
#+END_SRC

#+BEGIN_EXAMPLE
Name                      seconds
------------------------  ----------
É Uma Partida De Futebol  1
Now Sports                4
A Statistic               6
Oprah                     6
Commercial 1              7
The Real Problem          11
Commercial 2              21
Bossa                     29
Casinha Feliz             32
Mateus Enter              33
#+END_EXAMPLE

#+BEGIN_NOTES
This gives us the first 10 shortest songs. This is because the default behaviour for =ORDER BY= is to sort them in to ascending order, so the smallest comes first, then the next smallest, and so on.
#+END_NOTES

** Using =ORDER BY ... DESC=

#+BEGIN_SRC sql
  SELECT name,
         milliseconds / 1000 AS seconds
    FROM track
ORDER BY seconds DESC
   LIMIT 10;
#+END_SRC

#+BEGIN_EXAMPLE
Name                    seconds
----------------------  ----------
Occupation / Precipice  5286
Through a Looking Glas  5088
Greetings from Earth,   2960
Battlestar Galactica,   2956
The Man With Nine Live  2956
Battlestar Galactica,   2952
Murder On the Rising S  2935
Battlestar Galactica,   2927
Take the Celestra       2927
Fire In Space           2926
#+END_EXAMPLE

#+BEGIN_NOTES
Here we've used the =DESC= keyword, so now we get the tracks sorted by seconds in descending order, with the longest track first, then the next longest, and so on.
#+END_NOTES

** Using =ORDER BY= with =WHERE= clauses

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql-mode
  SELECT name,
         milliseconds / 1000 AS seconds
    FROM track
   WHERE seconds > 500
     AND seconds < 510
ORDER BY seconds DESC
   LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
Name           seconds
-------------  ----------
The Alchemist  509
Kashmir        508
Paschendale    508
How Many More  508
The Thin Line  506
Rain Song      505
Some Kind Of   505
Where The Riv  505
Title Song     505
Miserere mei,  501
#+END_EXAMPLE
#+REVEAL_HTML: </div>

** Using multiple =ORDER BY= clauses

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql-mode
  SELECT name,
         milliseconds / 1000 AS seconds
    FROM track
   WHERE seconds > 500
     AND seconds < 510
ORDER BY seconds DESC,
         name ASC
   LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
Name           seconds
-------------  ----------
The Alchemist  509
How Many More  508
Kashmir        508
Paschendale    508
The Thin Line  506
Rain Song      505
Some Kind Of   505
Title Song     505
Where The Riv  505
Miserere mei,  501
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We can order by multiple columns.

Here, we find all the tracks we're interested in and sort them by seconds order.

When we have rows that have the same seconds, like =508= or =505= in this example, we then sort them by name, in ascending order.

The =ASC= for the name ordering is redundant, because that's the default, but including it can make it really obvious to the reader what's going on.
#+END_NOTES

** The order of =ORDER BY= clauses is important

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
  SELECT name,
         milliseconds / 1000 AS seconds
    FROM track
   WHERE seconds > 500
     AND seconds < 510
ORDER BY name ASC,
         seconds DESC
   LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
Name                 seconds
-------------------  ----------
How Many More Times  508
Kashmir              508
Miserere mei, Deus   501
Paschendale          508
Rain Song            505
Some Kind Of Monste  505
The Alchemist        509
The Thin Line Betwe  506
Title Song           505
Where The River Goe  505
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
This is the same query, but we've swapped the order of =ORDER BY= clauses, so we sort by name first.

If you look at the results you can see that they are now in name order. Since we don't have any songs that have the same name the seconds sorting doesn't make any sense.
#+END_NOTES

** The order of =ORDER BY= clauses is important

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
  SELECT name,
         milliseconds / 1000 AS seconds
    FROM track
   WHERE name LIKE '%iron%'
ORDER BY name ASC,
         seconds DESC
   LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
Name              seconds
----------------  ----------
09 - Iron Maiden  216
Iron Maiden       494
Iron Maiden       351
Iron Maiden       324
Iron Maiden       261
Iron Maiden       235
Iron Man          172
Iron Man/Childre  552
Ironic            229
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
If we change the query to find songs with =iron= in the name we get a clearer view. Now all the songs called =Iron Maiden= are together, and within that they're sorted by seconds, with the longest songs coming first.
#+END_NOTES


** Query structure

#+BEGIN_SRC sql
  SELECT [columns]     -- What to return
    FROM [table]       -- Where to find it
   WHERE [expression]  -- (optional) How to filter it
ORDER BY [columns]     -- (optional) How to sort it
   LIMIT [number];     -- (optional) How many rows to return
#+END_SRC

* Creating new data

- All the queries so far show how to fetch existing data
- We can also write queries that create new data for us

* Counting rows with =COUNT=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT COUNT(name)
  FROM track;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
count(name)
-----------
3503
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
This is the =COUNT= function. Given a column it tells you how many rows exist
where that column is not =NULL=.

Here, we can see that our database contains information about 3,503 songs.
#+END_NOTES

** Renaming the count column

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT COUNT(name) AS cnt
  FROM track;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
cnt
-----------
3503
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We can rename this column in the output using =AS= the same way that we renamed other columns.
#+END_NOTES

** Finding duplicate names with =COUNT=

- We know we have songs with duplicate names
  - Earlier queries showed many songs called =Iron Maiden=
- How do we find out the names of all the songs that are duplicated?

*** First attempt, list the =name= column in the query

#+BEGIN_SRC sql
SELECT COUNT(name) AS cnt,
       name
  FROM track;
#+END_SRC

#+BEGIN_EXAMPLE
cnt          Name
-----------  ---------------------------------------
3503         For Those About To Rock (We Salute You)
#+END_EXAMPLE

#+BEGIN_NOTES
OK, so that's not the right answer. We've only got one row back, but we want multiple rows, showing how many of each name we have.

*Note*: In some database systems this query will show you an error instead of showing you result like this.
#+END_NOTES

*** Grouping columns

- We say we want to *group* the results.
- All the songs with the same name belong in the same group
- Then count the songs in that group
- Then repeat for the next name, and so on

#+BEGIN_SRC sql
.width 3 40
#+END_SRC


*** Using =GROUP BY=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
  SELECT COUNT(name) as cnt,
         name
    FROM track
GROUP BY name
   LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
cnt  Name
---  ----------------------------------------
1    "40"
1    "?"
1    "Eine Kleine Nachtmusik" Serenade In G,
1    #1 Zero
1    #9 Dream
1    'Round Midnight
1    (Anesthesia) Pulling Teeth
1    (Da Le) Yaleo
1    (I Can't Help) Falling In Love With You
1    (Oh) Pretty Woman
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Our new syntax is here, the =GROUP BY= just after the =FROM= keyword.

This looks like it's working, it's just that the results happen to show all the tracks that only occur once.
#+END_NOTES

*** Exercise: Use =ORDER BY=

- Use the =ORDER BY= clause in the last example
- Try and show the =cnt= column in *descending* order

*** Solution: Use =ORDER BY=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
  SELECT COUNT(name) as cnt,
         name
    FROM track
GROUP BY name
ORDER BY cnt DESC
   LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
cnt  Name
---  ----------------------------------------
5    2 Minutes To Midnight
5    Hallowed Be Thy Name
5    Iron Maiden
5    The Number Of The Beast
5    The Trooper
5    Wrathchild
4    Fear Of The Dark
4    Running Free
4    Sanctuary
4    The Evil That Men Do
#+END_EXAMPLE
#+REVEAL_HTML: </div>

*** Exercise: Use =WHERE=

- This shows all the songs
- Is =Iron Maiden= the only song with =iron= in the title with multiple copies?
- Use a =WHERE= clause in the query to only search for songs with =iron= in the title

*** Solution: Use =WHERE=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
  SELECT COUNT(name) as cnt,
         name
    FROM track
   WHERE name LIKE '%iron%'
GROUP BY name
ORDER BY cnt DESC
   LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
cnt  Name
---  ----------------------------------------
5    Iron Maiden
1    09 - Iron Maiden
1    Iron Man
1    Iron Man/Children of the Grave
1    Ironic
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Looks like we actually have six copies of =Iron Maiden=, it's just that one of them has a different title.
#+END_NOTES

*** Query structure

#+BEGIN_SRC sql
  SELECT [columns]     -- What to return
    FROM [table]       -- Where to find it
   WHERE [expression]  -- (optional) How to filter it
GROUP BY [columns]     -- Grouping, required if using COUNT()
ORDER BY [columns]     -- (optional) How to sort it
   LIMIT [number];     -- (optional) How many rows to return
#+END_SRC

* Filtering duplicates with =COUNT=

- Suppose we want to find all tracks that are duplicated three or more times
- Change the last query, and adjust the =WHERE= clause
  - Only find things where =cnt= is greater than 2
- What happens?

** Solution: Filtering duplicates with =COUNT=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
  SELECT COUNT(name) as cnt,
         name
    FROM track
   WHERE cnt > 2
GROUP BY name
ORDER BY cnt DESC
   LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
Error: misuse of aggregate: count()
#+END_EXAMPLE
#+REVEAL_HTML: </div>

** Two types of filtering

- First type: Choosing what to count
  - E.g. =name LIKE '%iron%'=
  - Uses a =WHERE= clause
- Second type: Choosing what to include in the grouping
  - E.g., =cnt > 2=
  - Uses a =HAVING= clause

** Using =HAVING=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
  SELECT COUNT(name) as cnt,
         name
    FROM track
GROUP BY name
  HAVING cnt > 2
ORDER BY cnt DESC
   LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
cnt  Name
---  ----------------------------------------
5    2 Minutes To Midnight
5    Hallowed Be Thy Name
5    Iron Maiden
5    The Number Of The Beast
5    The Trooper
5    Wrathchild
4    Fear Of The Dark
4    Running Free
4    Sanctuary
4    The Evil That Men Do
#+END_EXAMPLE
#+REVEAL_HTML: </div>

** Exercise: Using =WHERE= with =HAVING=                           :exercise:

- Find all tracks...
- ... with the word 'the' in the title
- ... count them all ...
- ... group by the name ...
- ... ignore any where the count is < 3
- ... display count and name, most popular first

** Solution: Using =WHERE= with =HAVING=

#+REVEAL_HTML: <div class="leftcol">
- Find all tracks...
- ... with the word 'the' in the title
- ... count them all ...
- ... group by the name ...
- ... ignore any where the count is < 3
- ... display =cnt= and =name=, most popular first
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC sql
  SELECT COUNT(name) AS cnt,
         name
    FROM track
   WHERE name LIKE '%the%'
GROUP BY name
  HAVING cnt > 2
ORDER BY cnt DESC
#+END_SRC
#+REVEAL_HTML: </div>

* Query pipeline                                                   :noexport:

#+BEGIN_NOTES
Not exporting this because I prefer the query pipeline graph below. Might use it later though.
#+END_NOTES

#+BEGIN_SRC dot :file query-pipeline-1.svg :cmdline -Tsvg -Gstylesheet=../graphviz.css
  digraph G {
    rankdir = LR;
    graph [compound=true];
    node [shape=record, fontname="Consolas", fontsize=20];

    subgraph col1 {
      select [label="SELECT|SELECT COUNT(name) AS cnt,\l\ \ \ \ \ \ \  name\l \ \ FROM track\l"];
      select_results [label="name|Balls to the Wall\lFast As a Shark\lRestless and Wild\lPrincess of the Dawn\l...\l|3,503 rows"];
      where [label="WHERE|WHERE name LIKE '%the%'"];
      where_results [label="name|Balls to the Wall\lPrincess of the Dawn\lPut The Finger On You\lInject The Venom\l...\l|543 rows"];
      group_by [label="count/group|COUNT(name) AS cnt\l...\lGROUP BY name\l"];
      having [label="HAVING|HAVING cnt &gt; 2"];
    }

    subgraph col2 {
      group_by [label="count/group|COUNT(name) AS cnt\l...\lGROUP BY name\l"];
      having [label="HAVING|HAVING cnt &gt; 2"];
      group_by_results [label="cnt, name\l|5, The Number Of The Beast\l5, The Trooper\l4, Fear Of The Dark\l4, The Evil That Men Do\l...\l|506 rows"];
      having_results [label="cnt, name\l|5, The Number Of The Beast\l5, The Trooper\l4, Fear Of The Dark\l4, The Evil That Men Do\l...\l|7 rows"];
}
    select -> select_results -> where -> where_results;
    where_results -> group_by [constraint=false];
    group_by -> group_by_results -> having -> having_results;

    // Next edge is invisible, but pulls the count/group node to the top
    // of its column.
    select:n -> group_by:n [style=invis];

    {rank=same; select, select_results, where, where_results }
    {rank=same; group_by, group_by_results, having, having_results }

  }
#+END_SRC

#+RESULTS:
[[file:query-pipeline-1.svg]]

* Query pipeline

#+BEGIN_SRC dot :file query-pipeline-1.svg :cmdline -Tsvg -Gstylesheet=../graphviz.css
  digraph G {
    rankdir = LR;
    graph [compound=true];
    node [shape=record, fontname="Consolas", fontsize=20];

    subgraph col1 {
      select [label="SELECT|SELECT COUNT(name) AS cnt,\l\ \ \ \ \ \ \  name\l \ \ FROM track\l"];
      select_results [label="name|Balls to the Wall\lFast As a Shark\lRestless and Wild\lPrincess of the Dawn\l...\l|3,503 rows"];
    }

    subgraph col2 {
      where [label="WHERE|WHERE name LIKE '%the%'"];
      where_results [label="name|Balls to the Wall\lPrincess of the Dawn\lPut The Finger On You\lInject The Venom\l...\l|543 rows"];
    }
    subgraph col3 {
      group_by [label="count/group|COUNT(name) AS cnt\l...\lGROUP BY name\l"];
      group_by_results [label="cnt, name\l|5, The Number Of The Beast\l5, The Trooper\l4, Fear Of The Dark\l4, The Evil That Men Do\l...\l|506 rows"];
    }

    subgraph col4 {
      having [label="HAVING|HAVING cnt &gt; 2"];
      having_results [label="cnt, name\l|5, The Number Of The Beast\l5, The Trooper\l4, Fear Of The Dark\l4, The Evil That Men Do\l...\l|7 rows"];
    }

    select -> select_results;
    select_results:e -> where:w;

    where -> where_results;
    where_results:e -> group_by:w;
    group_by -> group_by_results;
    group_by_results:e -> having:w;
    having -> having_results;

    // Next edge is invisible, but pulls the count/group node to the top
    // of its column.
    select:n -> where:n [style=invis];
    select:n -> having:n [style=invis];

    {rank=same; select, select_results }
    {rank=same; where, where_results }
    {rank=same; group_by, group_by_results }
    {rank=same; having, having_results }
  }
#+END_SRC

#+RESULTS:
[[file:query-pipeline-1.svg]]

#+BEGIN_NOTES
Here's a way to visualise what's going on that might help. This is *not* exactly what the database is doing when it runs our query, but it's a useful mental model to have.

Think of our query as a pipe, with data flowing through the pipe. At various points in the pipe we apply filters or other controls to restrict the amount of data coming through the pipe, until eventually we get exactly the data we want at the end of the pipe.

This idea of data flowing through a pipe with various stages is very common in computer science, so we generally refer to these things as pipelines.

Here's the pipeline for the most recent query.

Start at the top left box.

This is the =SELECT= statement from our query. At this point any aggregation functions (like =COUNT=) are ignored, and the query gathers up the data from all the non-aggregated columns.

This data goes in to the table that will hold the resuls. This is the box immediately below the =SELECT= query. At this point it contains 3,503 rows, because that's how many rows of tracks exist in the =track= table. The =SELECT= statement only asks for information about one non-aggregated column, =name=, so that's the single column in the =results= table.

This data then flows to the =WHERE= box. Here, a filter is applied, and all the rows in the results table that do not contain the word =the= somewhere in the nae are removed.

This changes our =results= table, which is now 543 rows long.

The data flows to the count/group operation. This is the aggregation operation. This takes the data in the =results= table and groups it by the values in the =name= column. It creates a new column, =cnt=, and puts the number of times each name occurs in to the =cnt= column.

This has the effect of reducing the number of rows -- any name that appeared more than once now only appears once. There are only a few of these, so the total number of rows is now 506.

Then the data flows to the =HAVING= stage. This checks the value in the new =cnt= column, and filters out any rows that do not match. This removes many of the rows that previously existed, leaving just 7 rows remaining in the =results= table.

And that's what's printed in the SQLite shell.

Notice how this explains why we can't use a =WHERE= clause with an aggregated column (i.e., the =cnt= column created by the =COUNT()= function -- at the time the =WHERE= stage runs the =cnt= column doesn't exist yet, so it can't be filtered on.
#+END_NOTES

* Other aggregation functions

- =COUNT()= is not the only aggregation function
- Others include (not a complete list):
  - =AVG()= for averages
  - =SUM()= to calculate totals
  - =MIN()= and =MAX()= to find smallest/largest values

** Averages

 #+REVEAL_HTML: <div class="leftcol">
 #+BEGIN_SRC sql
 SELECT AVG(milliseconds) AS mean_duration
   FROM track;
 #+END_SRC
 #+REVEAL_HTML: </div>

 #+REVEAL_HTML: <div class="rightcol">
 #+BEGIN_EXAMPLE
 mean_duration
 ----------------
 393599.212103911
 #+END_EXAMPLE
 #+REVEAL_HTML: </div>

*** Exercise: Group the results by composer

 - What's the average duration of all songs...
   - ... by composer ...
   - ... in seconds?
 - The =composer= column contains the name

*** Solution: Group the results by composer

 #+REVEAL_HTML: <div class="leftcol">
 #+BEGIN_SRC sql
   SELECT AVG(milliseconds) / 1000 AS mean_duration,
          composer
     FROM track
 GROUP BY composer
    LIMIT 10;
 #+END_SRC
 #+REVEAL_HTML: </div>

 #+REVEAL_HTML: <div class="rightcol">
 #+BEGIN_EXAMPLE
 mean_duration     composer
 ----------------  ----------------------------
 711.493507157464
 235.179666666667  A. F. Iommi, W. Ward, T. But
 276.871           A. Jamal
 397.531           A.Bouchard/J.Bouchard/S.Pear
 206.994           A.Isbell/A.Jones/O.Redding
 306.657375        AC/DC
 198.064           Aaron Copland
 266.936           Aaron Goldberg
 244.767           Ace Frehley
 299.102           Acyi Marques/Arlindo Bruz/Br
 #+END_EXAMPLE
 #+REVEAL_HTML: </div>

 #+BEGIN_NOTES
 That's interesting -- we have some tracks where the composer column is empty. We'll look at that again later.
 #+END_NOTES

** Calculating totals with =SUM()=

- Use =SUM()= to add up all the values in a column.

*** Exercise: Total time

- What's the total time taken up by all the tracks?

*** Solution: Total time

#+BEGIN_SRC sql
SELECT SUM(milliseconds) / 1000 as total_seconds
  FROM track;
#+END_SRC

*** Exercise: Total time by composer

- Who are the top-ten composers by total duration in the database?

*** Solution: Total time by composer

#+BEGIN_SRC sql
  SELECT SUM(milliseconds) / 1000 as total_seconds,
         composer
    FROM track
GROUP BY composer
   LIMIT 10;
#+END_SRC

** Finding the minimum and maximum values

- Use =MIN()= and =MAX()= to find the smallest and largest values

*** Exercise: Shortest songs

- What are the names of the 10 shortest songs?

*** Solution: Shortest songs

#+BEGIN_SRC sql
  SELECT MIN(milliseconds),
         name
    FROM track
GROUP BY name
ORDER BY milliseconds
   LIMIT 10;
#+END_SRC

*** Exercise: Longest songs

- What are the names of the 10 longest songs, and who wrote them?

*** Solution: Longest songs

#+BEGIN_SRC sql
  SELECT MAX(milliseconds),
         name,
         composer
    FROM track
GROUP BY name
ORDER BY milliseconds
   LIMIT 10;
#+END_SRC

* Handling empty values

- Recall that Javascript has the idea of the *empty* value
  - Javascript calls it =null=
- SQL has the same concept
  - Column can not have no value
  - If it's empty it contains the =NULL= value

** Exercise: List the first 10 track names with no composer

- ?

** Solution: List the first 10 track names with no composer

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT name
  FROM track
 WHERE composer IS NULL;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
Name
-----------------
Balls to the Wall
Desafinado
Garota De Ipanema
Samba De Uma Nota
Por Causa De Você
Ligia
Fotografia
Dindi (Dindi)
Se Todos Fossem I
Falando De Amor
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
There's a couple of new things here.

The first is that we don't need to list a column in the first part of the query in order to be able to use it in the =WHERE= clause.

Here we check to see what the value of the =composer= column is, but we don't bother displaying it.

In every example so far we've also shown the values in the columns we've filtered on -- but we don't have to if it's not necessary.

The second is the idea of a column containing a NULL value. This is very similar to the idea of =null= in Javascript -- it's a special value that meaans "There is no value here".

In Javascript we can use triple-equals to see if a value is null. In SQL you don't use the equals sign, you use the special phrase =IS NULL=, exactly as shown here.
#+END_NOTES

** =COUNT= and =NULL=

- Some functions treat =NULL= values specially
- For example, =COUNT= ignores =NULL= values

#+REVEAL_HTML: <br clear=all>

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT COUNT(composer)
  FROM track;
#+END_SRC

#+BEGIN_EXAMPLE
count(composer)
---------------
2525
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC sql
SELECT COUNT(*)
  FROM track;
#+END_SRC

#+BEGIN_EXAMPLE
count(*)
----------
3503
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
If we use =COUNT(composer)= it returns a count of all the rows that have a non-NULL value in the =composer= column. There are 2,525.

If we use the special =COUNT(*)= syntax then we count all the rows that have at least one non-NULL value in a column (any column). This gives us the total number of rows in the table.
#+END_NOTES

* The relational model

- Databases normally have more than one table
- Power comes from being able to *relate* information in one table to information in another table
- Hence *Relational Database*

** Understanding relationships, the schema

- Each table has a definition
  - Name of each column
  - The types
  - How the data is related to other tables
  - And more
- This is called the table's *schema*

** Investigating the schema for =track=

#+BEGIN_SRC sql
sqlite> .schema track
#+END_SRC

#+REVEAL: split

#+BEGIN_SRC sql
CREATE TABLE [Track]
(
    [TrackId] INTEGER  NOT NULL,
    [Name] NVARCHAR(200)  NOT NULL,
    [AlbumId] INTEGER,
    [MediaTypeId] INTEGER  NOT NULL,
    [GenreId] INTEGER,
    [Composer] NVARCHAR(220),
    [Milliseconds] INTEGER  NOT NULL,
    [Bytes] INTEGER,
    [UnitPrice] NUMERIC(10,2)  NOT NULL,
    CONSTRAINT [PK_Track] PRIMARY KEY  ([TrackId]),
    FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId])
                ON DELETE NO ACTION ON UPDATE NO ACTION,
    FOREIGN KEY ([GenreId]) REFERENCES [Genre] ([GenreId])
                ON DELETE NO ACTION ON UPDATE NO ACTION,
    FOREIGN KEY ([MediaTypeId]) REFERENCES [MediaType] ([MediaTypeId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE UNIQUE INDEX [IPK_Track] ON [Track]([TrackId]);
CREATE INDEX [IFK_TrackAlbumId] ON [Track] ([AlbumId]);
CREATE INDEX [IFK_TrackGenreId] ON [Track] ([GenreId]);
CREATE INDEX [IFK_TrackMediaTypeId] ON [Track] ([MediaTypeId]);
#+END_SRC

#+BEGIN_NOTES
Here is the schema. Let's look at some things of note.

First, the schema is shown using the syntax for creating a new table. So far we've only looked at the =SELECT= statement. As we can see, there is also a =CREATE= statement, and we can use that to create a table.

Notice the names in square brackets? Those are the table and column names.

The square brackets are how SQLite quotes these values -- it doesn't put them inside quotes, it uses the backets. It's incredibly bad practice to give a column or table a name with a space in it, but if you did, you'd write the name in square brackets. Here it's not necessary, but SQLite is being cautious.

We can see all the columns in the table. We've been using =name= and =milliseconds= and =composer= so far. If we look at those we can see what their types are.

=VARCHAR= and related terms is how a lot of databases say that something is a string. It's a "variable number of characters". The number in brackets is the maximum number of characters that can be stored in this column.

See the =NOT NULL= in various places.  Some columns are allowed to have NULL as the value for their row -- for example, =Composer= is allowed to be NULL because there might not be one.

Other columns are not allowed to be NULL, like =Name=, or =Milliseconds=.

What's very interesting is these lines that say =FOREIGN KEY=. Lets dig in to that some more.
#+END_NOTES

* Database keys

- Each row in a table must be unique
- You can not have two rows that are identical
- Typically, one row is the row's *key*
  - A unique identifier for that row
- We can't use the track name, since some songs have the same name
- Very common to use a column called =id= or *tablename* + =Id= for this
- The =track= table key is called =TrackId=

** Checking the keys

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT trackid,
  FROM track
 WHERE name = 'Iron Maiden';
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
TrackId
----------
1222
1297
1320
1366
2148
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here are the track IDs for the 5 songs called 'Iron Maiden'.
#+END_NOTES

** Querying a key

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT name,
       composer,
       milliseconds
  FROM track
 WHERE trackid = 1222;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
Name         Composer              Milliseconds
-----------  --------------------  ------------
Iron Maiden  Steve Harris          324623
#+END_EXAMPLE
#+REVEAL_HTML: </div>

** Keys are how we relate one table to another

- Suppose we have a key value, e.g., 1222
- If we put that value in another table...
- ... we say that it is a *foreign key* in that table
- This allows that table to know about our record

** Keys are how we relate one table to another

#+BEGIN_SRC sql
CREATE TABLE [Track]
(
    [TrackId] INTEGER  NOT NULL,
    ...
    [AlbumId] INTEGER,
    ...
    FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId])
                ON DELETE NO ACTION ON UPDATE NO ACTION,
    ...
);
#+END_SRC

#+BEGIN_NOTES
Here's a snippet of the schema for the =track= table again.

Notice how the =track= table contains a column called =AlbumId=.

And later on this is referred to as a foreign key in the =Album= table.

Lets go take a look at the =Album= table...
#+END_NOTES

** The =Album= table schema

#+BEGIN_SRC sql
sqlite> .schema Album
CREATE TABLE [Album]
(
    [AlbumId] INTEGER  NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    CONSTRAINT [PK_Album] PRIMARY KEY  ([AlbumId]),
    FOREIGN KEY ([ArtistId]) REFERENCES [Artist] ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE UNIQUE INDEX [IPK_Album] ON [Album]([AlbumId]);
CREATE INDEX [IFK_AlbumArtistId] ON [Album] ([ArtistId]);
#+END_SRC

#+BEGIN_NOTES
So, our Album table has some interesting things in it. Each album has a unique ID, in the column called =albumid=, and an album =title=. There's also a reference to the =artistid=, and we can see that that's a foreign key in the =artist= table.

Let's put that to one side for a moment, and figure out how we can see which album track 1222 belongs to.
#+END_NOTES

** Querying a key

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT name,
       composer,
       milliseconds
  FROM track
 WHERE trackid = 1222;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
Name         Composer              Milliseconds
-----------  --------------------  ------------
Iron Maiden  Steve Harris          324623
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Remember, this some of the information from our =track= table, and we looked it up based on the track's ID.

Lets find out the ID of the album that this track is part of.
#+END_NOTES

** Finding the album ID for a track

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT albumid
  FROM track
 WHERE trackid = 1222;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
AlbumId
----------
95
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Remenber, our track has the ID 1222, so we use that in this query.

This tells us that information about the album that this track is part of is in the album with the ID 95.

So lets go find some information about that album.
#+END_NOTES

** Finding album info from the key

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT title
  FROM album
 WHERE albumid = 95;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
Title
---------------
A Real Dead One
#+END_EXAMPLE
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <br clear="all">

- Important -- the column is =title=, not =name=

** Relationship diagram

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC dot :file query-diagram-1.svg :cmdline -Tsvg -Gstylesheet=../graphviz.css
  digraph G {
    rankdir = LR;
    node [shape=record,
	  fontname="Consolas",
	  fontsize="20",
	  labelfontname="Consolas",
	  labelfontsize="24"];

    subgraph cluster_track {
      penwidth=0;  // style=invis hides the label
      label="Table: Track";
      track [label="TrackId|Name|<f0> AlbumId|Milliseconds|..."];
    }

    subgraph cluster_album {
      penwidth=0;
      label="Table: Album";
      album [label="<f0> AlbumId|Title|ArtistId"];
    }

    track:f0 -> album:f0;
  }
#+END_SRC

#+RESULTS:
[[file:query-diagram-1.svg]]

#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Our tracks are related to albums
- The =Album= column =AlbumId= *Primary Key* ...
- ... is a *foreign key* in =Track=
- With a many-to-one relationship
  - *Many* tracks can be related *to*
  - *One* album
#+REVEAL_HTML: </div>

** Find all the tracks on album 95

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
SELECT trackid,
       name
  FROM track
 WHERE albumid = 95;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
TrackId     Name
----------  -----------------------
1212        The Number Of The Beast
1213        The Trooper
1214        Prowler
1215        Transylvania
1216        Remember Tomorrow
1217        Where Eagles Dare
1218        Sanctuary
1219        Running Free
1220        Run To The Hilss
1221        2 Minutes To Midnight
1222        Iron Maiden
1223        Hallowed Be Thy Name
#+END_EXAMPLE
#+REVEAL_HTML: </div>

** Relationship diagram

#+BEGIN_SRC dot :file query-diagram-2.svg :cmdline -Tsvg -Gstylesheet=../graphviz.css
  digraph G {
    rankdir = LR;
    node [shape=plaintext,
	  fontname="Consolas",
	  fontsize="20",
	  labelfontname="Consolas",
	  labelfontsize="24"];

    track [label=<<table><TR><td><b>TrackId</b></td>
<td><b>Name</b></td>
<td><b>AlbumId</b></td>
</TR>
<TR><TD>1212</TD>
<TD>The Number Of The Beast</TD>
<TD PORT="p1">95</TD>
</TR>
<TR><TD>1213</TD>
<TD>The Trooper</TD>
<TD PORT="p2">95</TD>
</TR>
<TR><TD>1214</TD>
<TD>Prowler</TD>
<TD PORT="p3">95</TD>
</TR>
<TR><TD>1215</TD>
<TD>Transylvania</TD>
<TD PORT="p4">95</TD>
</TR>
<TR><TD>1216</TD>
<TD>Remember Tomorrow</TD>
<TD PORT="p5">95</TD>
</TR>
<TR><TD>1217</TD>
<TD>Where Eagles Dare</TD>
<TD PORT="p6">95</TD>
</TR>
<TR><TD>1218</TD>
<TD>Sanctuary</TD>
<TD PORT="p7">95</TD>
</TR>
<TR><TD>1219</TD>
<TD>Running Free</TD>
<TD PORT="p8">95</TD>
</TR>
<TR><TD>1220</TD>
<TD>Run To The Hilss</TD>
<TD PORT="p9">95</TD>
</TR>
<TR><TD>1221</TD>
<TD>2 Minutes To Midnight</TD>
<TD PORT="p10">95</TD>
</TR>
<TR><TD>1222</TD>
<TD>Iron Maiden</TD>
<TD PORT="p11">95</TD>
</TR>
<TR><TD>1223</TD>
<TD>Hallowed Be Thy Name</TD>
<TD PORT="p12">95</TD>
</TR>
</table>>];

    album [label=<<table><TR><Td><b>AlbumId</b></Td>
<Td><b>Title</b></Td>
<Td><b>ArtistId</b></Td>
</TR>
<tr><td colspan="3">...</td></tr>
<TR><TD PORT="t1">95</TD>
<TD>A Real Dead One</TD>
<TD>90</TD>
</TR><tr><td colspan="3">...</td></tr></table>>];

    track:p1 -> album:t1;
    track:p2 -> album:t1;
    track:p3 -> album:t1;
    track:p4 -> album:t1;
    track:p5 -> album:t1;
    track:p6 -> album:t1;
    track:p7 -> album:t1;
    track:p8 -> album:t1;
    track:p9 -> album:t1;
    track:p10 -> album:t1;
    track:p11 -> album:t1;
    track:p12 -> album:t1;
  }
#+END_SRC

#+RESULTS:
[[file:query-diagram-2.svg]]

#+BEGIN_NOTES
Here's what the contents of the tables look like.

On the left is the =track= table. This isn't all the columns, just =trackid=, =name=, and =albumid=.

We can see that all of these tracks have the same =albumid= value. This points us to the row in =album= that has an =albumid= column with this value.

We say that these tables are *related*, or *correlated*.

Wouldn't it be great if we could somehow link these two tables in some way...?of

#+END_NOTES

* Joins: What we want

#+BEGIN_EXAMPLE
Name                     Title            Composer
-----------------------  ---------------  --------------------
The Number Of The Beast  A Real Dead One  Steve Harris
The Trooper              A Real Dead One  Steve Harris
Prowler                  A Real Dead One  Steve Harris
Transylvania             A Real Dead One  Steve Harris
Remember Tomorrow        A Real Dead One  Paul Di'Anno/Steve H
Where Eagles Dare        A Real Dead One  Steve Harris
Sanctuary                A Real Dead One  David Murray/Paul Di
Running Free             A Real Dead One  Paul Di'Anno/Steve H
Run To The Hilss         A Real Dead One  Steve Harris
2 Minutes To Midnight    A Real Dead One  Adrian Smith/Bruce D
Iron Maiden              A Real Dead One  Steve Harris
Hallowed Be Thy Name     A Real Dead One  Steve Harris
#+END_EXAMPLE

#+BEGIN_NOTES
Here's an example set of results.

We've got three columns. The first one, =Name=, and the last one, =Composer=, contain information from the =track= table.

But the middle column contains information from the =Album= table.

The information is *related* to the track -- the track and the album both have a column called =AlbumId= that contains the same value.
#+END_NOTES

** Joins: What we want, explanation

- Query two tables at once, =track= and =album=
- Every time we have a row in =track=
  - Find the equivalent row in =album=, based on =AlbumId=
  - Look up the =Title= column
  - Include its value in the output
- We say we are *joining* the tables, on the =AlbumId= column

#+BEGIN_NOTES
So far all our queries have only queried one table at a time.

This time we want to process two tables. One table
#+END_NOTES

** Joins: Left table and right table

[[file:query-diagram-2.svg]]

#+BEGIN_NOTES
Going back to this diagram for a moment, notice how we have a table on the left, and a table on the right.

We want *all* the rows from the table on the left, and the values of any matching rows from the table on the right.
#+END_NOTES

** Joins: SQL

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
     SELECT track.name,
	    album.title,
	    track.composer
       FROM track
  LEFT JOIN album ON track.albumid = album.albumid
      WHERE track.albumid = 95;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- =SELECT= column names include the table name
- =LEFT JOIN= specifies the table on the right
- =ON= says how the left and right table are related
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here's what the SQL looks like. The differences to what we're used to so far are:

- In the =SELECT= columns we have to include the name of the table before the name of the column, separated by a dot (=.=)

- After the =FROM= (which is unchanged) we have to include the name of the table we're joining against. This is a =LEFT JOIN=, so we have to specify that, followed by the name of the table (=album= in this case).

- We have to say how the two table are related. Here, they are related through the =albumid= column in both tables. When the values in that column are the same then the rows are related.
#+END_NOTES

** Average length of song per album

#+BEGIN_SRC sql
   SELECT AVG(track.milliseconds) / 1000,
          album.title
     FROM track
LEFT JOIN album ON track.albumid = album.albumid
 GROUP BY album.title
    LIMIT 10;
#+END_SRC

** Shortest song on an album

#+BEGIN_SRC sql
     SELECT MIN(track.milliseconds) / 1000 AS sec,
	    track.name,
	    album.albumid,
	    album.title
       FROM track
  LEFT JOIN album ON track.albumid = album.albumid
   GROUP BY track.albumid
      LIMIT 10;
#+END_SRC

** Longest song on an album

#+BEGIN_SRC sql
select min(track.milliseconds) / 1000 as sec, track.name, album.albumid, album.title from track left join album on track.albumid = album.albumid group by track.albumid limit 10;
#+END_SRC

** How many tracks are on each album

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC sql
     SELECT COUNT(track.name) AS cnt,
	    album.title
       FROM track
  LEFT JOIN album ON track.albumid = album.albumid
   GROUP BY album.title
      LIMIT 10;
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_EXAMPLE
cnt         Title
----------  --------------------
9           ...And Justice For A
12          20th Century Masters
1           A Copland Celebratio
11          A Matter of Life and
12          A Real Dead One
11          A Real Live One
1           A Soprano Inspired
15          A TempestadeTempesta
17          A-Sides
15          Ace Of Spades
#+END_EXAMPLE
#+REVEAL_HTML: </div>

* What else can we join on?

#+BEGIN_SRC sql
sqlite> .schema track
CREATE TABLE [Track]
(
    [TrackId] INTEGER  NOT NULL,
    [Name] NVARCHAR(200)  NOT NULL,
    [AlbumId] INTEGER,
    [MediaTypeId] INTEGER  NOT NULL,
    [GenreId] INTEGER,
    [Composer] NVARCHAR(220),
    [Milliseconds] INTEGER  NOT NULL,
    [Bytes] INTEGER,
    [UnitPrice] NUMERIC(10,2)  NOT NULL,
    CONSTRAINT [PK_Track] PRIMARY KEY  ([TrackId]),
    FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId])
                ON DELETE NO ACTION ON UPDATE NO ACTION,
    FOREIGN KEY ([GenreId]) REFERENCES [Genre] ([GenreId])
                ON DELETE NO ACTION ON UPDATE NO ACTION,
    FOREIGN KEY ([MediaTypeId]) REFERENCES [MediaType] ([MediaTypeId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
#+END_SRC

#+BEGIN_NOTES
As well as =AlbumId= we have two other foreign keys here, =GenreId= and =MediaTypeId=.

Lets go and investigate those.

#+BEGIN_EXAMPLE
.schema genre
select distinct name from genre;

.schema mediatype
select distinct name from mediatype;
#+END_EXAMPLE
#+END_NOTES

** Joining on multiple tables

#+BEGIN_SRC sql
   SELECT track.name,
          genre.name,
          album.title
     FROM track
LEFT JOIN genre
       ON track.genreid = genre.genreid
LEFT JOIN album
       ON track.albumid = album.albumid
    LIMIT 10;
#+END_SRC


* Exercises

- How many tracks do we have in each genre?
  - Which genre do we have the most tracks of?
  - Which genre do we have the least tracks of?
- Which album has the largest number of genres?
- Which album has the smallest number of genres?

** How many tracks in each genre

#+BEGIN_SRC sql
     SELECT COUNT(genre.name) AS cnt,
	    genre.name
       FROM genre
  LEFT JOIN track
	 ON track.genreid = genre.genreid
   GROUP BY genre.name
   ORDER BY cnt desc
      LIMIT 10;
#+END_SRC

** Which album has the largest number of genres

*** Start with

#+BEGIN_SRC sql
     SELECT genre.name,
	    album.albumid,
	    album.title
       FROM track
  LEFT JOIN genre
         ON track.genreid = genre.genreid
  LEFT JOIN album
         ON track.albumid = album.albumid
      LIMIT 60;
#+END_SRC

*** Add counts / grouping

#+BEGIN_SRC sql
     SELECT COUNT(genre.name) AS cnt,
	    genre.name,
	    album.albumid,
	    album.title
       FROM track
  LEFT JOIN genre ON track.genreid = genre.genreid
  LEFT JOIN album ON track.albumid = album.albumid
   GROUP BY album.title, genre.name
   ORDER BY album.title
      LIMIT 60;
#+END_SRC
