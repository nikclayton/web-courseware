#+TITLE: More CSS
#+SETUPFILE: "../include/settings.org"

#+BEGIN_NOTES
Experiment with no practice time in the morning, give the material,
they have the slides to use it in the afternoon.
#+END_NOTES

* Recap

- Introduced CSS
  - Selectors and rules
  - =id= and =class= attributes
  - CSS colours
  - CSS fonts
  - The "cascade" effect
- Browser Inspector

#+BEGIN_NOTES
Let's just recap what we looked at yesterday.

We started by going over CSS syntax, including how to write CSS rules,
which say what something should look like, and how to write selectors,
which let us say which elements we want to be affected by the rules.

We discovered =id= and =class= attributes that all elements have,
making it easier to write CSS selectors that target particular
elements.

And we learned how CSS colours and fonts work, and the way that CSS
rules *cascade* to generate the final style.

Then we played with the browser inspector to experiment with these
things, and you worked on making your own pages look more stylish.

Today we're going to continue our in-depth look at CSS.

As with yesterday, the goal is not that you immediately understand
all of this stuff and can use it fluently.

But I want you to know that all of this stuff exists, so that when
the time comes, you know how to search for it, refresh your memory,
and read and understand the documentation.
#+END_NOTES

* TODO Box model
  :PROPERTIES:
  :TOPICS:   css-box-model
  :REQUIREMENTS: css-intro
  :END:

[[file:box-model.png]]

#+BEGIN_NOTES
So far we've been styling content on the page without paying much
attention to how the browser actually figures out where everything
on the page should go, how much space it should take up, and so on.

CSS does this by thinking of each and every element on the page as
a box.

The browser uses the CSS rules and the content in each element to
figure out how big a box the element needs. Then it uses this to
put all the boxes on the page in the right place based on how much
space they need, whether they should go on a line on their own, and
so on.

Each element's box is actually a series of boxes, one inside the
other.

The smallest box, and the one on the inside, is the *content* box.
This is the box that contains the content of the element, and all
the sizing information starts from this.  This box has a *width*
and a *height*.

Immediately outside the content box is some optional extra space,
called *padding*.

Around the padding is an optional *border*. So the padding specifies
the amount of space between the content and the border.

And outside the border is the element's *margin*. This is the space
between the element's border and other elements.

There are CSS properties for all these, so we can do some
experimentation now.

---
Based on material from [[https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Box_model][The box model (MDN)]].
#+END_NOTES

** Box model: Setup

- Create =scratch/box-model= directory
- Create =scratch/box-model/style.css=
- Create =scratch/box-model/box-model.html=

#+INCLUDE: "day5/box-model.html" src html

#+BEGIN_NOTES
Like yesterday we start with a basic HTML file and an empty
CSS file.
#+END_NOTES

** Add some HTML content

#+iNCLUDE: "day5/box-model-2.html" :lines "8-19" src html

** Add some HTML content

#+NAME: box-model-2
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day5/box-model-2.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS[e264ba4fa1d180136d5b1f773c76f3e1431eed89]: box-model-2
[[file:box-model-2.png]]

** Add and commit!

** Box model: Showing borders

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/style-3.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+NAME: box-model-3
#+BEGIN_SRC html-chrome :cache no :url (shell-quote-argument (expand-file-name "day5/box-model-3.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS[2a8d7516d0cf6ef5b3c49ca55f5a067b5db588e9]: box-model-3
[[file:box-model-3.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
The easiest way to see what the boxes look like is to turn on borders
for one or more elements.

Edit the CSS file to add the rule on the left, and you should see
the results on the right.

In this case we're using a new CSS selector, the *asterisk*, or
*star*. This is the *universal* selector in CSS -- it means "apply
these rules to each element".

So we're giving each element a 1 pixel solid border to show off the
edges of the element padding.

Does everyone see something like this?

[Wait]
#+END_NOTES

** Box model: Showing borders

#+REVEAL_HTML: <div class="leftcol">
[[file:box-model-3.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+ATTR_HTML: :width 50% :height 50%
[[file:box-model.png]]

- =p= elements have top / bottom margins
- So does =ul= and =body=
- =p=, =ul=, =li=, =body=, =html= expand to fill the full width
  - =em= doesn't
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here's the page again, and on the right I've put the image that
shows the box model components.

Lets pick this page apart.

First, remmeber how the first element in our page is always =html=.
Well, that element is matched by the =*= in our CSS selector, so
it gets a border, that's this one here.

[Indicate it]

Our next element is the =body= element, which also has a border,
whic is here.

[Indicate it]

Notice how there's space between the =html= body and the =body= border.

That might be *padding* on the =html= element, or it might be a
*margin* on the =body= element. We'll investigate that later.

Here are our two =p= elements with their border.

Notice how there's no blank space between the =p= content and the
border. That means they must have no padding. But there is blank
space between the borders of the =p= elements, so they must have a
margin.

And so does the =ul= element, you can see it at the top and bottom
of its border.

Even the =em= element in the first paragraph gets a border.

Notice how the =html=, =body=, =p=, =ul=, and =li= elements are all
wider than their content, and have expanded to fill the full width
of the page.

But the =em= element hasn't.

We talked about this a little bit back on day 1. Can anyone remember
why?

[Wait]

Do you remember we talked about block level elements, like =p=, and
inline elements, like =em=?

That's the difference. Normally, a block level element's content box
automatically expands to fill the full width available to it.

While an inline level element's content box is only wide enough to
contain its content.

We've seen that some of these elements have margins already. Lets
see what happens if we disable the margins.
#+END_NOTES

** Box Model: Margins

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/style-4.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+NAME: box-model-4
#+BEGIN_SRC html-chrome :cache no :url (shell-quote-argument (expand-file-name "day5/box-model-4.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS: box-model-4
[[file:box-model-4.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
This is what happens if we set all the margins to 0. Note that all the
blank space around the elements has disappeared.

The block-level elements still extend to the full width of the page
though.
#+END_NOTES

** Box model: Padding
#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/style-5.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+NAME: box-model-5
#+BEGIN_SRC html-chrome :cache no :url (shell-quote-argument (expand-file-name "day5/box-model-5.html")) :flags --window-size=320,400 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS: box-model-5
[[file:box-model-5.png]]

#+BEGIN_NOTES
This is what some additional padding looks like.

The padding is given to the =p= and =li= elements - half an em of
padding at the top of the element's content, and 1.5 ems at the
bottom of the element's content.

Notice how this has affected the borders -- per the box model,
happens between the content and the border.

By the way, this introduces another syntax for CSS selectors. When
you want one set of rules to apply to different selectors, you can
separate them with a comma, as I've done here.
#+END_NOTES

*** Multiple selectors

#+BEGIN_SRC css
/* Applies the rules to p elements AND li elements */
p, li {
  padding-top: .5em;
  padding-bottom: 1.5em;
}
#+END_SRC

#+BEGIN_SRC css
/* Applies the rules to li elements that are descendents
   of p elements */
p li {
  padding-top: .5em;
  padding-bottom: 1.5em;
}
#+END_SRC

#+BEGIN_NOTES
Don't get those two confused. These examples look very similar, but
they mean different things.

Is everyone OK with this?

[Wait]
#+END_NOTES

** Box model: Margins
#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/style-6.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+NAME: box-model-6
#+BEGIN_SRC html-chrome :cache no :url (shell-quote-argument (expand-file-name "day5/box-model-6.html")) :flags --window-size=380,400 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS: box-model-6
[[file:box-model-6.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
This CSS makes the margins more obvious.

I've increased the width of the border, and changed the colour,
so that it's black, but 50% opaque, so the background colour
shows through.

Both =p=, =em=, and =li= elements are now white text, with half an
em of padding (inside the border) and half an em of margin
(outside the border).

And =p= elements get a blue background, =li= elements get a
red background.

#+END_NOTES

** Box model: Margins

#+REVEAL_HTML: <div class="leftcol">
[[file:box-model-6.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- List bullets take on the text color
- =border= and =padding= share the =background-color=
- =margin= doesn't
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
There's a few things of note here.

First, the bullets on the list items have disappeared. That's
because, unless you style the bullets seperately, they take on
the same colour as the list item text. Since the text color
is white we have white bullets on a white background, and we
can't see them.

The second thing is the background colours. We can see that the
background colour property affects the content of the element. It also
affects the padding, because that is also blue (or red).

And the background colour also extends all the way to the border
-- remember, the border colour is black, but 50% transparent, and
we can see that it's darker blue and darker red around the =p=
and =li= elements, not grey, so it's picking up the background
colour for the element.

But the margins don't have colour -- the space we've said for the
margins uses the background colour of the parent element, not the
child element.

Make sense?

[Wait]
#+END_NOTES
** Box model: Margins

#+REVEAL_HTML: <div class="leftcol">
[[file:box-model-6.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- What's wrong with the margins?

#+BEGIN_SRC css
p, li, em {
  ...
  margin: .5em;
}
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Given that CSS, can anyone see what's odd about some of the margins
in this page?

[Wait]

[Hint (if necessary). How big should the gap between the paragraphs
and the list items be? How big is it actually?]

We've specified a margin of half an em all the way around these
elements.

So when two of them are next to each other you would expect the
total space between them to be 1em -- half an em from the bottom
margin of the first element, and half an em for the top margin
of the second element.

Yes?

[Wait]

But if we look at this screenshot, or you look at your page --
we know the border size is half an em, so we can clearly see that
the gaps here, between the paragraphs, and here, between the
list items, are half an em, and not the full em that we expect.

What's going on?
#+END_NOTES

*** Box model: Margin collapse

#+REVEAL_HTML: <div class="leftcol">
[[file:box-model-6.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Top and bottom margins are sometimes combined in to a single margin
- Called *margin collapse*
  - New margin size is the larger of the two
- Margins collapse for:
  - Adjacent sibling elements
    - Between the =p=, =p=, and =ul=
    - Between the =li=, =li=, and =li=
  - Parent and first / last child
  - Empty blocks
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
The answer is a feature of CSS called *margin collapse*.

This happens when you have two elements next to each other. If the
conditions are right, instead of the space between them being the
sum of their top and bottom margins, whichever margin value is
bigger is used, and the others are ignored.

There are three times this will happen.

The first is if you have elements that share the same parent. For
example, our =p=, =p=, and =ul= elements all have the =body= as
their parent. And the three =li= elements all have the =ul= as
their parent.

So their margins collapse. That's why the space between the two
=p= elements is only half an em and not one em, and the same for
the margins between the three =li= elements.

The second time is between margins of parent elements and their
first or last child elements. That doesn't apply in this example.

And the last is if the element's content is empty. That doesn't
apply in this example either.
#+END_NOTES

** Box model: Browser inspector

#+BEGIN_CENTER
Demo
#+END_CENTER

#+BEGIN_NOTES
Demo the browser inspector for looking at the box model.

Show how hovering over an element shows not just where the content is
but the extent of the element's box, including the margin, border, and
padding.

Show how the actual values are available in the box-model UI at the
middle-right of the inspector.

Demo margin collapse by changing the CSS for the li for box-model-6
and adding margin-top and margin-bottom setting them to different
values.
#+END_NOTES

** Box model properties: =height=
- Height of the content area
  - =height: auto;=
  - =height: 150px=
  - =height: 6em;=
  - =height: 50%;=
- Also =min-height= and =max-height=
*** =height= examples

#+REVEAL_HTML: <div class="leftcol">
#+NAME: height-example
#+BEGIN_SRC html
<style>
div {
  margin-bottom: 5px;
  border: 1px solid rgb(0, 0, 0);
}
#taller { height: 50px; }
#shorter { height: 25px; }
#parent { height: 100px; }
#child { height: 50%; }
</style>
<div id="taller">I'm 50 pixels tall.</div>
<div id="shorter">I'm 25 pixels tall.</div>
<div id="parent">
  <div id="child">
    I'm half the height of my parent.
  </div>
</div>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :exports results :noweb yes
<<height-example>>
#+END_SRC
#+REVEAL_HTML: </div>

** Box model properties: =width=
- Width of the content area
  - =width: auto;=
  - =width: 150px;=
  - =width: 6em;=
  - =width: 50%;=
- Also =min-width= and =max-width=

*** =width= examples

#+REVEAL_HTML: <div class="leftcol">
#+NAME: width-example
#+BEGIN_SRC html
<style>
div {
  border: 1px solid rgb(0, 0, 0);
  margin-bottom: 5px;
}
.px-width { width: 200px; }
.em-width { width: 5em; }
.pct-width { width: 50%; }
</style>
<div class="px-width">
  This is 200px wide
</div>
<div class="em-width">
  This is 5em wide
</div>
<div class="pct-width">
  This is 50% wide
</div>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :exports results :noweb yes
<<width-example>>
#+END_SRC

#+RESULTS[9484d84f7ad7fc699efbc7825ea9eb1460d3ae01]:
[[file:width-examples.png]]

#+REVEAL_HTML: </div>
** Box model properties: =padding=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC css
selector {
  padding-top: 1em;
  padding-right: 0;
  padding-bottom: .5em;
  padding-left: 10px;
}
#+END_SRC

#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC css
selector {
  padding: 1em;
} /* padding-{top, right, bottom, left}: 1em; */


selector {
  padding: 0 1em;
} /* padding-{top, bottom}: 0;     */
  /* padding-{left, right}: 1em;   */
  /* padding-{left, right}: 1em;   */

selector {
  padding: 1em 0 2em;
} /* padding-top: 1em;             */
  /* padding-{left, right}: 0;     */
  /* padding-bottom: 2em;          */

selector {
  padding: 1em 2em .5em 0;
} /* padding-top: 1em;             */
  /* padding-right: 2em;           */
  /* padding-bottom: .5em;         */
  /* padding-left: 0;              */
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We've been playing around with the =padding=, =border=, and =margin=
properties without digging in to exactly how you specify them.

Let's start with =padding=.

The most legible way to specify it is with four different properties
for the amount of padding you want on each of the four sides of the
element's box. These are padding top, right, bottom, and left.

You can also use a shortened form of the property, called just
=padding=.

If you use that and give it one value then it's used for all 4 sides.

If you give it two values then the first value is used for top and
bottom, and the second value is used for left and right.

If you give it three values then the first value is used for top,
the second is used for left and right, and the third is used for
bottom.

And if you give it 4 values then they set the top, right, bottom,
and left properties. I remember that by imagining a clock face, and
the minute hand sweeping around the face -- starting at the top, then
it points right at 3, to the bottom at 6, and left at 9.
#+END_NOTES

** Box model properties: =border=

- =border-width=
- =border-style=
- =border-color=

#+BEGIN_NOTES
The border properties are a bit more complicated.

Do you remember the =font= property from yesterday, and how that
was shorthand for =font-style=, =weight=, =family=, and so on?

The =border= property is similar. To control borders you can use
three different properties, and use =border= as the short version.

Those three properties let you set the border's width, style, and
colour. I'll introduce those first, and then we'll come back to
how the =border= shorthand works.
#+END_NOTES

*** =border-width=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC css
selector {
  border-top-width: 1px;
  border-right-width: 2px;
  border-bottom-width: .25em;
  border-left-width: 0;
}
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC css
selector {
  border-width: 1em;
} /* border-width-{top, right, bottom, left}: 1em; */


selector {
  border-width: 0 1em;
} /* border-width-{top, bottom}: 0;   */
  /* border-width-{left, right}: 1em; */

selector {
  border-width: 1em 0 2em;
} /* border-width-top: 1em;           */
  /* border-width-{left, right}: 0;   */
  /* border-width-bottom: 2em;        */

selector {
  border-width: 1em 2em .5em 0;
} /* border-width-top: 1em;           */
  /* border-width-right: 2em;         */
  /* border-width-bottom: .5em;       */
  /* border-width-left: 0;            */
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
=border-width= behaves identically to =padding= and =margin=.

There are individual properties to set the border widths on all four
sides of the element's box, or you can use the shorthand version.
#+END_NOTES

*** =border-style=

#+REVEAL_HTML: <div class="leftcol">
#+NAME: border-style
#+BEGIN_SRC html
<p style="border-style: none;">none</p>

<p style="border-style: dotted;">dotted</p>

<p style="border-style: dashed;">dashed</p>

<p style="border-style: solid;">solid</p>

<p style="border-style: double;">double</p>

<p style="border-style: groove;">groove</p>

<p style="border-style: ridge;">ridge</p>

<p style="border-style: inset;">inset</p>

<p style="border-style: outset;">outset</p>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :noweb yes :flags --window-size=320,400 --force-device-scale-factor=2 :exports results
<style>p {padding: .2em .5em;}</style>
<<border-style>>
#+END_SRC

#+RESULTS[c703302eda9188ca4b0650c5e44fea7e68aa3644]:
[[file:border-style.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
There are various predfined styles that you can use for borders, they
don't have to be solid lines.
#+END_NOTES

*** =border-style=

#+REVEAL_HTML: <div class="leftcol">
#+NAME: border-style-2
#+BEGIN_SRC html-chrome
<head>
  <style>
p {
  padding: .2em .5em;
  border-top-style: dashed;
  border-right-style: inset;
  border-bottom-style: solid;
  border-left-style: dotted;
}
  </style>
</head>
<body>
  <p>An ugly use of borders.</p>
</body>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[a1b7aedbe55e724195640e61d7ef2c7527541cb6]: border-style-2
[[file:border-style-2.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
You can specify different border styles for different sides of
the content box.
#+END_NOTES

*** =border-style=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC css
selector {
  border-top-style: solid;
  border-right-style: dotted;
  border-bottom-style: dashed;
  border-left-style: double;
}
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC css
selector {
  border-style: solid;
} /* border-style-{top, right, bottom, left}: solid; */


selector {
  border-style: solid dashed;
} /* border-style-{top, bottom}: solid;   */
  /* border-style-{left, right}: dashed;  */

selector {
  border-style: solid dashed double;
} /* border-style-top: solid;             */
  /* border-style-{left, right}: dashed;  */
  /* border-style-bottom: double;         */

selector {
  border-style: solid dashed double none;
} /* border-style-top: solid;             */
  /* border-style-right: dashed;          */
  /* border-style-bottom: double;         */
  /* border-style-left: none;             */
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Which of course means that you can use the same shorthand style as
for the other properties.
#+END_NOTES

*** =border-color=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC css
selector {
  border-top-color: gold;
  border-right-color: red;;
  border-bottom-color: black;
  border-left-color: blue;
}
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC css
selector {
  border-color: gold;
} /* border-color-{top, right, bottom, left}: gold; */


selector {
  border-color: gold red;
} /* border-color-{top, bottom}: gold;   */
  /* border-color-{left, right}: red;    */

selector {
  border-color: gold red black;
} /* border-color-top: gold;             */
  /* border-color-{left, right}: red;    */
  /* border-color-bottom: black;         */

selector {
  border-color: gold red black blue;
} /* border-color-top: gold;             */
  /* border-color-right: red;            */
  /* border-color-bottom: black;         */
  /* border-color-left: blue;            */
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
And, of course, the colour of the border can be set the same
way. Any CSS colour value can be used here. I've used named
colours in this example to make the slide easier to read, but
I still recommend you use =rgb()= and =rgba()= for specifying
colours.
#+END_NOTES

*** =border=

#+REVEAL_HTML: <div class="leftcol">
#+NAME: gold-border
#+BEGIN_SRC html-chrome
<p style="border: 1em dotted gold">A gold border</p>
#+END_SRC

#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[ea715cb298773a9bb6143d8b10602d7d314fc959]: gold-border
[[file:gold-border.png]]

#+REVEAL_HTML: </div>

** Box model properties: =margin=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC css
selector {
  margin-top: 1em;
  margin-right: 0;
  margin-bottom: .5em;
  margin-left: 10px;
}
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC css
selector {
  margin: 1em;
} /* margin-{top, right, bottom, left}: 1em; */


selector {
  margin: 0 1em;
} /* margin-{top, bottom}: 0;     */
  /* margin-{left, right}: 1em;   */

selector {
  margin: 1em 0 2em;
} /* margin-top: 1em;             */
  /* margin-{left, right}: 0;     */
  /* margin-bottom: 2em;          */


selector {
  margin: 1em 2em .5em 0;
} /* margin-top: 1em;             */
  /* margin-right: 2em;           */
  /* margin-bottom: .5em;         */
  /* margin-left: 0;              */
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
=margin= is specified in exactly the same way as =padding=.
You can either use four different margin properties, or
you can use the single =margin= property in its 1, 2, 3, or
4 value variant.
#+END_NOTES

** Box model properties: =box-sizing=
- Total height
  - content height...
  - plus padding-top plus padding-bottom...
  - plus border-top plus border-bottom
- Total width
  - content width...
  - plus padding-left plus padding-right...
  - plus border-left plus border-right
- This is =box-sizing: content-box;=
- Change with =box-sizing: border-box;=
#+BEGIN_NOTES
Normally the element's final width and height are calculated from
the inside out -- width and height are applied to the content,
then any padding and border sizes are added, to give the element's
final size.

This is the default behaviour.

You can change this with the =box-sizing= property. The default
value is =content-box=.

If you set this to =border-box= then the width and height properties
are applied to the border box of the element, then the padding,
and the content box is resized as necessary.
#+END_NOTES

*** =box-sizing= example

#+REVEAL_HTML: <div class="leftcol">
#+NAME: box-sizing-example
#+BEGIN_SRC html
<style>
div {
  border: .5em solid rgb(0, 0, 0);
  margin-bottom: 5px;
  width: 15em;
  padding: 1em;
}
div.content-box {
  box-sizing: content-box; /* default */
}
div.border-box {
  box-sizing: border-box;
}
</style>
<div class="content-box">
  15em + 1em + 1em + .5em + .5em = 18em.
</div>
<div class="border-box">
  15em only.
</div>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :exports results :noweb yes
<<box-sizing-example>>
#+END_SRC

#+RESULTS[dca6e9df4e00e782ee88737500b04c90dab7c292]:
[[file:box-sizing-example.png]]

#+REVEAL_HTML: </div>
* TODO Display: 3 types of CSS boxes

- =block=: Default for block-level elements
  - Stacks with other block boxes
  - Content before/after on a separate line
- =inline=: Default for inline-level elements
  - Content appears on same line
  - Content will break at end of line (not a box)
- =inline-block=: A mix of the two
  - Appears inline
  - Does not break across lines
- =display= property selects them

#+BEGIN_NOTES

#+END_NOTES

** =display=: Setup

- Create =scratch/display= directory
- Create =scratch/display/display.css=
- Create =scratch/display/display.html=

** =display= examples

#+NAME: display
#+INCLUDE: "day5/display.html" src html

** =display= examples

#+INCLUDE: "day5/display.css" src css

** =display= examples

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html-chrome :cache no :url (shell-quote-argument (expand-file-name "day5/display.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS[44c2847f952843c82775d810194c7296215b8a72]:
[[file:display-examples.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- =inline= is not a box
  - Content breaks at the end of the line.
- =block= is a box
  - Line break before and after content
  - Element box extends to end of line
- =inline-block= is a box
  - Does not break
  - Box matches content size
#+REVEAL_HTML: </div>

* =display= example: Breadcrumb navigation

- Create =scratch/display/breadcrumb.css=
- Create =scratch/display/breadcrumb.html=

** =breadcrumb.html=

 #+INCLUDE: "day5/display-2.html" src html

*** Result

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html-chrome :cache no :url (shell-quote-argument (expand-file-name "day5/display-2.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS:
[[file:result.png]]

** =breadcrumb.css=

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/display-3.css" :lines "6-9" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Edit =breadcrumb.html=
  - Add =link= element for =breadcrumb.css=
- Edit =breadcrumb.css=
  - Display =li= items inline
#+REVEAL_HTML: </div>

** =breadcrumb.css=

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/display-3.css" :lines "6-13" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Show =>= before each list item
#+REVEAL_HTML: </div>


** =breadcrumb.css=

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/display-3.css" :lines "6-17" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Show =>= before each list item
  - Except the first one
#+REVEAL_HTML: </div>

** =breadcrumb.css=

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/display-3.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Remove the left padding on =ul=
- Add a background colour
#+REVEAL_HTML: </div>

*** Results

#+REVEAL_HTML: <div class="leftcol">
#+NAME: display-3
#+BEGIN_SRC html-chrome :cache yes :url (shell-quote-argument (expand-file-name "day5/display-3.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS[3dff6790850a0396f3c7e5ffbef1fe04abca0789]: display-3
[[file:display-3.png]]

#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- The visual effect is the same
- The markup is better
  - This will be more important next week
#+REVEAL_HTML: </div>

* TODO CSS Positioning

#+BEGIN_NOTES
We've looked at how the box model works, and the difference between
block level elements, inline elements, and inline-block elements.

Now we need to take a deeper look at how elements are actually
positioned on the page. Then we can use CSS features to change how
this positioning happens.
#+END_NOTES

** Position: Setup

- Create =scratch/position= directory
- Create =scratch/position/style.css=
- Create =scratch/position/position.html=

#+INCLUDE: "day5/position-1.html" src html

** Add some HTML content

#+INCLUDE: "day5/position-2.html" :lines "8-19" src html

#+BEGIN_NOTES
There's nothing special here so far. All we've done is created a
heading and three paragraphs and given them some content and classes.

Because the classes don't currently exist this does nothing out of the
ordinary.

Make these changes, double check everything looks good.

[Wait]
#+END_NOTES

** Add some HTML content

#+NAME: position-2
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day5/position-2.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS[fce87eb4489f4368b6c594d8f6c433433e63a36c]: position-2
[[file:position-2.png]]

#+BEGIN_NOTES
You should have ended up with something that looks like this.

Everyone OK?
#+END_NOTES
** Add and commit!

** =position: static;=

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/position-3.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+NAME: position-3
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day5/position-3.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS[c4175d82fcd23d2c95032e05f168153165aabc5b]: position-3
[[file:position-3.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
As you may have guess from the class names we used there are a
few different types of positioning available.

The first of these is =static=. This is the default if an element
hasn't been given an explicit position.

This just means that the element is laid out in entirely the normal
way. Block level elements are stacked one under the other, while
inline elements don't break a line and appear exactly as we covered
earlier.

We can verify this by explicitly setting the position to =static= on
an existing element.

We have the =pos-static= class, so create the CSS file and add the
rule shown here. It sets the background colour just so we can be
certain that the rule is being applied. When you save and reload
you should see this result here.

Our paragraph has not moved at all.

Also, I've added a border to the =body= element, just to highlight
something interesting -- notice how the body element border is *not*
the edge of the page. There's a margin between the =body= and the
edge of the page. We're going to come back to that shortly...
#+END_NOTES

** =position: relative;=

#+INCLUDE: "day5/position-4.css" src css

#+BEGIN_NOTES
Lets set a relative position on one of the paragraphs. To make it
stand out some more I've given it a blue background and white text.

Make this change, save, and reload.

What do you see?

[Wait]
#+END_NOTES

** =position: relative;=

#+NAME: position-4
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day5/position-4.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS[7dc7ae7d3895dc41f674e94f9f541e19e331bda4]: position-4
[[file:position-4.png]]

#+BEGIN_NOTES
Our paragraph's position hasn't moved.

The problem here is that we've used relative positioning, but we
haven't told the element where to move to. Without that, it stays in
its normal place.

Notice also that the yellow and blue background colours show something
else -- our paragraphs are entirely contained within the =body=
element.
#+END_NOTES

** =position: relative;=

#+REVEAL_HTML: <div class="leftcol">
- Properties to adjust the element's position
  - =top=
  - =bottom=
  - =left=
  - =right=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+INCLUDE: "day5/position-5.css" src css
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
To control the position we use the =top=, =bottom=, =left=, and
=right= properties.

Confusingly, these operate in the opposite direction to their names.

In the example on the right this will push the top of the element
*down* by 20 pixels, and will move the left edge of the element *in to
the page* by 10 pixels.

Make this change to the styelesheet, and see what happens.

[Wait]
#+END_NOTES

** =position: relative;=

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/position-5.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+NAME: position-5
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day5/position-5.html")) :flags --window-size=320,320 --force-device-scale-factor=2 --hide-scrollbars :exports results
#+END_SRC

#+RESULTS[70dd0989d36928a9414cfa25a676ec4a73a0a46d]: position-5
[[file:position-5.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
We can see that the middle paragraph has been moved from its normal
location, pushed down 20 pixels and right 10 pixels.

Notice how the other paragraphs are not affected. In particular,
the third one *does not* move further down to accommodate the
middle one.

Also, look at the blue background -- it extends out *past* the =body=
element's border. Our paragraph is now partly in and partly outside.
#+END_NOTES

** =position: absolute;=
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: no-heading
   :END:

#+INCLUDE: "day5/position-6.css" src css

#+BEGIN_NOTES
Let's give the third paragraph an absolute position.

Make this change to the CSS, and reload the page.

[Wait]
#+END_NOTES

** =position: absolute;=

#+NAME: position-6
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day5/position-6.html")) :flags --hide-scrollbars --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS[7dc7ae7d3895dc41f674e94f9f541e19e331bda4]: position-6
[[file:position-6.png]]

#+BEGIN_NOTES
What's happened here.

Our first two paragraphs are unchanged -- the first one is =static=
and the second is =relative=, so they appear exactly as they did
before.

The third paragraph has been taken completely out of the normal document
flow. See how the final paragraph has moved up to use the space that
the absolutely positioned paragraph used to take.

This is different from the relative positioning.

Our absolutely positioned paragraph needs to go somewhere. Because
we did't tell it where to go, its default position is at the bottom
left of the =body= element. You can see that by comparing its position
to the =body= border.
#+END_NOTES

** =position: absolute;=
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: no-heading
   :END:

#+REVEAL_HTML: <div class="leftcol">
- Properties to adjust the element's position
  - =top=
  - =bottom=
  - =left=
  - =right=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+INCLUDE: "day5/position-7.css" src css
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Absolutely positioned elements use the same =top=, =bottom=, =left=,
and =right= properties to control their position as relatively
positioned elements do.

However, they mean something different.

With a relatively positioned element these mean "Figure out where
the element would normally go, then adjust its position by these
amounts".

With an absolutely positioned element these mean "Find the first
parent element with a non-static position. Put the element in its
top left corner, then adjust it using these properties."

Add these =top= and =left= properties and see what happens.

[Wait]
#+END_NOTES

** =position: absolute;=
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: no-heading
   :END:

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/position-7.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+NAME: position-7
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day5/position-7.html")) :flags --window-size=320,320 --force-device-scale-factor=2 --hide-scrollbars :exports results
#+END_SRC

#+RESULTS[8cd233f6bb29faf39ee0614c25dbf3267915e964]: position-7
[[file:position-7.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Our absolutely positioned paragraph has changed position.

Because we gave it =top= and =left= properties the browser has had to
figure out where to put it.

It's contained inside the =body= element, which has a static position,
so the browser checks the next parent element, the =html= element.
Since that doesn't have a position, and is the root element, the
paragraph is placed at the top left of the =html= element, and then
moved down and in based on the =top= and =left= properties.

That might be a bit confusing, so lets see what happens when one of
the parent elements *does* have a non-static position.
#+END_NOTES

** =position: absolute;=
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: no-heading
   :END:

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/position-8.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+NAME: position-8
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day5/position-8.html")) :flags --window-size=320,320 --force-device-scale-factor=2 --hide-scrollbars :exports results
#+END_SRC

#+RESULTS[6059ed0e54b2fb4a1ffa5498e8464512aa080bfd]: position-8
[[file:position-8.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
This is the same CSS -- all I've done is set the body's position to
=relative=.

Remember, without a =top= or other property, =relative= is just like
=static=.

However, now the location of our absolutely positioned paragraph
has changed. Instead of its position being based on where the =html=
element starts, it's based on where the =body= starts. Because the
=body= has a non-static position.
#+END_NOTES

* 3-column layout

[[file:day5/3column/goal.png]]
#+BEGIN_NOTES
We're going to build a typical 3 column layout for a page using
CSS.

This will use much of the information we're already covered, as well
as a couple of toosl that we haven't seen before.

At the end we'll have something that looks like this, that you can use
as a skeleton for the exercises.

The dimensions here are going to be used through the CSS, so I'll cover
them briefly.

The left and right columns are each 15ems wide. With the margins and
padding they take up 37ems of width in total, leaving the rest for the
main content div.
#+END_NOTES

** 3-column: Setup

- Create =scratch/3column= directory
- Create =scratch/3column/style.css=
- Create =scratch/3column/index.html=

#+INCLUDE: "day5/3column/3column.html" src html

#+BEGIN_NOTES
This is our initial HTML, very similar to what we've seen before.

The heading, and the 3 columns, are different =div= elements, and
I've given each of them a unique identifier so they can styled
appropriately in the CSS.

Do this, and let me know when you're finished.

[Wait]
#+END_NOTES

** 3-column: Initial HTML

#+NAME: 3column-initial
#+BEGIN_SRC html-chrome :cache yes :url (shell-quote-argument (expand-file-name "day5/3column/3column.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS[8604f09c1f98cc1dd4f5b9eb6dcdaf84969245e4]: 3column-initial
[[file:3column-initial.png]]

#+BEGIN_NOTES
So far, not very impressive.

We'll add styles bit by bit to end up with the layout I showed earlier.
#+END_NOTES

** 3-column: =body=, =div=, =#header= styles

#+INCLUDE: "day5/3column/3column-1.css" src css

#+BEGIN_NOTES
We start with some general styles for the body and the divs.

We set relative positioning on the =body= element. This ensures that
any absolutely positioned divs later are positioned off the =body=
element and not the =html= element.

For all divs we give them a solid black border, a light grey
background, and a little bit of padding to let the design breathe
a little bit.

The top header also gets a 1em margin all the way around.
[Wait]
#+END_NOTES

** 3-column: =body=, =div=, =#header= styles

#+NAME: 3column-1
#+BEGIN_SRC html-chrome :cache yes :url (shell-quote-argument (expand-file-name "day5/3column/3column-1.html")) :flags --window-size=866,600 --force-device-scale-factor=1.5 :exports results
#+END_SRC

#+RESULTS[8604f09c1f98cc1dd4f5b9eb6dcdaf84969245e4]: 3column-1
[[file:3column-1.png]]



** 3-column: =#content= styles

#+INCLUDE: "day5/3column/3column-2.css" :lines "15-21" src css

#+BEGIN_NOTES
There are are a few things here that we haven't seen before.

[skip, using absolute positioning now]
The first is =float=.

This is a bit like absolute positioning, in that it takes the element
out of the normal flow of the page. Howeever, it remains part of the
flow.

The element is shifted to the left (in this case) until it's touching
the edge.

However, we want the contet to appear to the right of the secondary
content div, so we give it a left margin of 18ems -- that covers the
15ems width of the secondary content div, and the margins.
[end skip]

I use absolute positioning to put the content div 18ems from the left
of the page. This covers the width of the secondary content as well
as padding and margins.

Since I want the content div to take up a minimum amount of height
I set a =min-height= property.

=50vh= is also new. The value =50vh= means "50% of the view height".  The view, or viewport
is the size of the web browser window, so this ensure that the main
content div is at least 50% of the viewport height.

Finally, we say how wide the =div= should be, using =calc()=. This is
also new. It allows us to compute sizes based on percentages and
absolute values.

Here I'm saying I want the width of the main content =div= to be 100%
of the width of the browser, minus 37ems. That accounts for the width
of the left and right columns and margins and padding.

[Wait]
#+END_NOTES

** 3-column: =#content= styles

#+NAME: 3column-2
#+BEGIN_SRC html-chrome :cache yes :url (shell-quote-argument (expand-file-name "day5/3column/3column-2.html")) :flags --window-size=866,600 --force-device-scale-factor=1.5 :exports results
#+END_SRC

#+RESULTS[5e5acb4d09cf94bf05fa2946f8b9de61aa1b3373]: 3column-2
[[file:3column-2.png]]

#+BEGIN_NOTES
The end result looks like this. You can see how the layout is starting
to take shape.
#+END_NOTES

** 3-column: =#secondary= styles

#+INCLUDE: "day5/3column/3column-3.css" :lines "22-28" src css

#+BEGIN_NOTES
This should be pretty straightforward by now.

We position the secondary contetn div absolutely, and 1em from the left
of its containing element. We also give it a fixed width of 15ems,
and the same minimum height that the main content div has as well.

[Wait]
#+END_NOTES

** 3-column: =#secondary= styles

#+NAME: 3column-3
#+BEGIN_SRC html-chrome :cache yes :url (shell-quote-argument (expand-file-name "day5/3column/3column-3.html")) :flags --window-size=866,600 --force-device-scale-factor=1.5 :exports results
#+END_SRC

#+RESULTS[5e5acb4d09cf94bf05fa2946f8b9de61aa1b3373]: 3column-3
[[file:3column-3.png]]

#+BEGIN_NOTES
Did everyone get something that looks like this?

[Wait]
#+END_NOTES

** 3-column: =#tertiary= styles                                    :exercise:

#+NAME: 3column-4
#+BEGIN_SRC html-chrome :cache yes :url (shell-quote-argument (expand-file-name "day5/3column/3column-4.html")) :flags --window-size=866,600 --force-device-scale-factor=1.5 :exports results
#+END_SRC

#+RESULTS[4d0b6b60af6ac4af44f4a143c6c671e2f2470be4]: 3column-4
[[file:3column-4.png]]

#+BEGIN_NOTES
OK, now you go and write the style for the =#tertiary= div, to position
it on the right hand side with 1em's worth of indentation. It should also
be 15ems wide, just like the secondary one.

The end result should look like this.

[Wait]
#+END_NOTES

** 3-column: =#tertiary= styles

#+INCLUDE: "day5/3column/3column-4.css" :lines "29-36" src css

#+BEGIN_NOTES
This should be pretty straightforward by now.

We position the secondary contetn div absolutely, and 1em from the left
of its containing element. We also give it a fixed width of 15ems,
and the same minimum height that the main content div has as well.

[Wait]
#+END_NOTES

** 3-column exercises: Overview                                    :exercise:

- Use columns in your portofolio and recipes
- Experiment with different widths, heights, and other styles

** 3-column exercises: Portfolio example                           :exercise:

#+NAME: 3column-portfolio
#+BEGIN_SRC html-chrome :cache yes :url (shell-quote-argument (expand-file-name "day5/3column/3column-portfolio.html")) :flags --window-size=866,600 --force-device-scale-factor=1.5 :exports results
#+END_SRC

#+RESULTS[2fc0cf404491b0c11c71043d0a2f64e1c60d5d6e]: 3column-portfolio
[[file:3column-portfolio.png]]

#+BEGIN_NOTES
This is one way that you might decide to lay out your portfolio.

You don't have to do it exactly like this -- if you think you have a better
layout in mind, go for it.

Experiment with different widths, heights, colors, borders, and so on,
until you have something that you're happy with.

#+END_NOTES
** 3-column exercises: Recipe example

#+NAME: 3column-recipe
#+BEGIN_SRC html-chrome :cache yes :url (shell-quote-argument (expand-file-name "day5/3column/3column-recipe.html")) :flags --window-size=866,600 --force-device-scale-factor=1.5 :exports results
#+END_SRC

#+RESULTS[5743a7671946c6797ab89bd6b6733bc17b9d5b02]: 3column-recipe
[[file:3column-recipe.png]]

#+BEGIN_NOTES
For the recipes, again, this is just a suggestion. Notice how I've
removed the third column because for me I didn't think I needed it,
but you might find uses for it -- maybe you want to include some
information about where the recipe came from, or what it means to you.

Again, up to you. This is your chance to experiment.
#+END_NOTES

** 3-column exercises: =position: sticky;=

- Look up what =position: sticky;= does
  - Use MDN
- Can you find a way to include that in your layout?

* Grid and Flex layouts

- Two additional (newer) layout systems
- Grid: [[https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout][MDN CSS Grid Layout]]
- Flex: [[https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox][MDN CSS Flexbox]]
- Experiment creating 3-column layout with both of use

#+begin_notes
Static, relative, and absolute positioning can sometimes be difficult to understand and predict, so two new systems were developed later, called *grid* and *flex* (or *flexbox*).

Both of them make achieving some types of layouts much simpler. MDN has excellent documentation and tutorials for both of them, so read through that documentation and try recreating that 3-column layout twice, once with grid, and once with flex.
#+end_notes

* TODO Problems with these layouts

- Try resizing the page to be very narrow
  - Where would you see a narrow screen?
- What about very wide?

#+BEGIN_NOTES
There are some problems with these layouts.

One is that they don't really work when the screen is quite narrow.
The fixed sizes for the side columns means that the main content
gets squashed as the screen gets narrower.

Where would you see a narrow screen?

[Wait]

Also, if the browser is very wide then the main content becomes
difficult to read.

There are lots of studies that show that people read text most
effectively when the line is somewhere between 60 and 80 characters
wide. Any wider than that and the reader loses track of where they
are when their eye reaches the end of the line and they have to
scan back to the beginning of the next one.

So what we want, ideally, is a way to change the styling depending
on the characteristics of the device that the user is using.
#+END_NOTES

* TODO CSS Media queries

- *Conditional* CSS rules based on device characteristics
  - =width=
  - =height=
  - =orientation=
  - =print=
  - ...

#+BEGIN_NOTES
So far all of the CSS we've been writing is always applied to the
page, no matter what sort of device the user is using to view the
page.

In the last 15 years or so the type and style of devices that people
can view webpages on has changed drastically. We've gone from
computers with monitors to tablets of all shapes and sizes, phones,
and even watches.

These devices have different capabilities and sizes, and trying to
create a "one size fits all" stylesheet that worked no matter what
device was being used to view the page is very difficult.

Media queries are a way of extending your stylesheet to be able to
say "Only apply this rule if the device has *this* characteristic".

Some examples will probably make this clearer.
#+END_NOTES

** Breadcrumb navigation

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day5/display-3.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
[[file:display-3.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Remember our breadcrumb navigation example from earlier. At the moment
this unconditionally renders our breadcrumb list like this.

You can imagine that on a small display, like a phone, this might not
be ideal. The individual entries in the list are small and hard to tap,
and it wraps around on to mulitiple lines in a way that isn't very
pleasing.

What we want is a way to choose between two different types of
presentation of the list, depending on the type of device that's being
used to view the page.

We can use a media query to do this -- to say that this presentation
should only happen when the screen is wider than some amount -- if
it's not, we'll use different CSS to show the breadcrumbs in a
traditional list.
#+END_NOTES

** Media query, end result

#+BEGIN_CENTER
[[file:day5/display-4.html][Breadcrumb with media query]]
#+END_CENTER

#+BEGIN_NOTES
[Demo the page]

Here's the end result.

Watch what happens when I resize the page.

[Demo resizing the page]

So when the page gets narrower than a certain width the presentation
of the list changes.

- It appears on mulitple lines.
- Indentation is used to show the hierarchy
- There's a different arrow

Resizing the page like this to test things out can get annoying, so
let me show you a trick with the developer tools as well.

- First, I open the developer tools
- Then I click this "Toggle device toolbar" button

See how the page has changed.

At the top here I have some controls to let me say how large I want to
pretend the page is.

I can either type in some numbers directly, or I can use these handles
on the page to drag to change the size of the page.

While I'm doing this my main browser window stays the same size.

[Demo]

Notice how when the page width is less than the threshold that the
presentation changes exactly as it did before.

You can also use the "Responsive" drop down to set the size of the
display to that of specific devices for testing.

[Demo]

So, now we know the end result, lets look in to how this works.
#+END_NOTES

** The viewport
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: no-heading
   :END:

[[file:viewport.png]]

#+BEGIN_NOTES
When a web page is loaded the browser has to figure out the size
of the page -- the width and the height.

It does this using the HTML, CSS rules, images, videos, font sizes,
and so on, to figure out how the big the page is. Then it *renders*
the page. You can think of *rendering* as being a fancy word for
*drawing*.

The rendered page might be bigger than the browser window.. If it is
then the browser adds scrollbars to the page. You'll have seen this,
when the page is too tall you get a vertical scrollbar to scroll up
and down, and if it's too wide you get a horizontal scrollbar to
scroll left and right.

We say that the bit of the page you can see at any point is the
*viewport*, and when you scroll the page you're moving the viewport
around.

This is exactly what this image shows. The whole page is here, but the
browser window is this brighter part here -- this is the viewport, and
it's a lot smaller than the whole page. When you use the scrollbars
to move up and down the page don't think of this as the page moving
up and down -- think of it as the viewport moving up and down.

On narrow screens, like you find on phones and tablets, this happens
a lot.

What also happens on phones and tablets is that the browser pretends
that the viewport is bigger than it is. For example, if the phone
screen is 600 pixels wide it might pretend that it's 1,000 pixels
wide.

Then it renders the page as it if had 1,000 pixels of width to
create an image of the page.

Then is scales that image so that it's 600 pixels wide to fit the
screen.

Then you can use the pinch-zoom feature in the browser to zoom in or
out of the page.

This works well for non-mobile-optimized web pages.

But it's a problem for mobile-optimized pages. We want to be able to
say "Use this different style if the screen is less than 600 pixels wide".
But the browser is pretending that the screen is a lot larger. We need
a way to tell the browser to stop pretending that the screen is bigger
than it is, and use the real screen size.
#+END_NOTES

** The =viewport= =meta= element

#+INCLUDE: "day5/display-4.html" :lines "6-7" src html

- Belongs in the document's =head=

#+BEGIN_NOTES
The way to shut off this browser behaviour is with a =meta= element.
This provide a mechanism to communicate additional information to the
browser, with a =name= and =content= attribute.

To control the viewport we set the =name= to viewport, and put the
control in the =content= attribute.

Earlier I said that the browser can pretend that the viewport is wider
than the device.

By adding this to the document's =head= element we tell it to always
set the viewport's width to be the same as the device's width.
#+END_NOTES

** Writing media queries

#+BEGIN_SRC css
@media type (expression) {
  /* CSS rules go here */
}
#+END_SRC

#+BEGIN_NOTES
The general format of a media query in a CSS file is the literal string
=@media=, followed by the media type (which is optional), and a series
of one or more expressions.

If the type matches the device, and all the expressions are true, then
the CSS inside the media query is used.

If it doesn't then it's ignored.
#+END_NOTES

** Media query =type=

#+BEGIN_SRC css
@media type (expression) {
  /* CSS rules go here */
}
#+END_SRC

- =all= - All devices, the default
- =print= - When printing the page
- =screen= - When displaying the page on screen
- =speech= - When speaking the page

#+BEGIN_NOTES
The =type= is optional, and specifies the type of device that the
page is being viewed on.

The default is =all=. If it's missing then this is assumed. You can
also use

=print= - the CSS rules will only apply if the page is being printed

=screen= - the CSS rules will only apply if the page is being viewed
on a screen

=speech= - the CSS rules will only apply if the page is being read
by a speech-synthesisor, e.g., for people using the page who are
partially sighted or blind.
#+END_NOTES

** Media query =expression=

#+BEGIN_SRC css
@media type expression {
  /* CSS rules go here */
}
#+END_SRC

#+REVEAL_HTML: <div class="leftcol">
- =min-width=
- =min-height=
- =orientation=
- =pointer=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- =hover=
- =resolution=
- =aspect-ration=
- ...
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
The expression allow to query the capabilities of the device to decide
if the CSS rules should apply or not. You can query for many things,
including

- the devices minimum width and height
- its orientation (portrait or landscape)
- does it have a pointing device?
- can the user hover over elements?
- the display resolution
- the aspect ratio
#+END_NOTES

** Media query examples

#+BEGIN_SRC css
@media screen and (min-width: 600px) {
  /* ... */
}
#+END_SRC

#+BEGIN_SRC css
@media print and (orientation: landscape) {
  /* ... */
}
#+END_SRC

#+BEGIN_SRC css
@media screen and (not(hover)) {
  /* ... */
}
#+END_SRC

#+BEGIN_CENTER
[MDN Media Query]
#+END_CENTER

#+BEGIN_NOTES
Here are some examples.

In the first one, the CSS rules will only apply if the page is being
viewed on screen and the minimum width of the page is at least 600
pixels wide.

In the second one, the CSS rules will only apply if the page is being
printed and the paper orientation is landscape.

The third one applies if the page is being viewed on the screen and
the device does not support "hovering" over elements. For example,
in a device with a mouse you can hover the mouse pointer over an
element. But on a device with no mouse and only a touch screen that
doesn't work.
#+END_NOTES

** New CSS 1/3
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: no-heading
   :END:

#+INCLUDE: "day5/display-4.css" :lines "1-5" src css

#+BEGIN_NOTES
This is the start of the CSS. It's identical to the previous
CSS, because the list's padding and colour are the same no matter
what the width of the viewport is.
#+END_NOTES

** New CSS 2/3
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: no-heading
   :END:

#+INCLUDE: "day5/display-4.css" :lines "6-19" src css

#+BEGIN_NOTES
These are the same CSS rules from earlier, but we only want them to
apply if the browser viewport is 600 pixels wide (or wider). So
they're wrapped in a media query that tests this.
#+END_NOTES

** New CSS 3/3
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: no-heading
   :END:

#+INCLUDE: "day5/display-4.css" :lines "20-44" src css

#+BEGIN_NOTES
These are new CSS rules.

Because of the media query they take effect when the viewport is
less than 600 pixels wide.

The first one make sure that each =li= element has an arrow before
it. The =\2ba1= is the code for the arrow.

The :before elements normally have a =display= value of =inline=. This
means that trying to set the width doesn't work, and the arrow character
is a bit bigger than normal. So I set the =display= to =inline-block=,
which we saw earlier, and give it a minimum width.

The very first =li= element doesn't need an arrow, so we specialise
that in the second rule.

These last three rules increase the padding of the 2nd, 3rd, 4th, and
every following =li= item.

The effect is that the second one appears indented by 1em, the third
by 2em, and the 4th and all the following ones by 3em.

Then the media query is closed out.
#+END_NOTES

** Media query recap

#+BEGIN_SRC html
<meta name="viewport" content="width=device-width">
#+END_SRC

#+BEGIN_SRC css
@media type expression {
  /* CSS rules go here */
}
#+END_SRC

** Loading different CSS based on media query

#+BEGIN_SRC html
<head>
  <link href="style.css" rel="stylesheet">
  <link href="large.css" rel="stylesheet"
     media="screen and (min-width: 600px)">
  ...
</head>
#+END_SRC

#+BEGIN_NOTES
You don't have to put the media query in the CSS file.

Instead, you can put the media query in a =media= attribute on the
=link= element that loads the CSS file.

In this example our page will always load the first stylesheet.

But it will only load the second stylesheet if the expression in the
=media= attribute is true.

Since mobile devices tend to be less powerful, this ensures that the
CSS for larger devices is only loaded and processed by those devices.
Mobile devices will never even load =large.css=, making the page
slightly faster to load for them.
#+END_NOTES

** Hiding elements with =display: none;=

#+BEGIN_SRC css
@media screen and (max-width: 600px) {
  ul.breadcrumb {
    display: none;
  }
}
#+END_SRC

#+BEGIN_NOTES
I mentioned three different possible values for the =display=
property earlier. There are others, and one of the most useful is
=none=.

Use this to completely remove the element from the display. This
is very useful with media queries, as you can use this to hide
elements that aren't so useful on small screens.

For example, if we wanted to hide the breadcrumb list entirely we
would write this CSS rule with the associated media query.
#+END_NOTES

** Best practice: Design for smaller sizes first

- Build stylesheet assuming small device
  - Default to hiding elements
- Then add stylesheets with media queries
  - Progressively show content as the screen gets bigger
  - Called "Mobile first" design
- *Breakpoint*: The size or other change that triggers a new stylesheet

#+BEGIN_NOTES
Now that you know all this you might be asking -- what's the best
way to do things? Should I design for a large screen first, and then
build stylesheets that remove content as the screen gets smaller?

Or should I design for smaller screen first, and then shown content
as screens get larger?

In general, designing is much easier if you start with the smaller
size first, and get that working. Then start adding additional
stylesheets with different media queries as the size (or something
else) changes.

We call the point where a new stylesheet is needed a "breakpoint".

A good way to figure out if you need to add a new breakpoint is by
looking at the width of the widest block of text on the page. If it's
more than about 80 characters (roughly 8 to 10 English words) then
it's time to add a breakpoint with a new stylesheet that adjusts
sizing, padding, margins, and layout to keep the information legibile.
#+END_NOTES



* Exercises                                               :exercise:

- Improve cheatsheets and recipes
- Use media queries / mobile first design
- Inspiration:
  - [[https://mediaqueri.es/]]
  - https://colly.com/about
- Change font size, line height
- Hide / show elements
- Change element presentation
- Adjust padding, margin, borders

* Read tutorials

- https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML
- https://developer.mozilla.org/en-US/docs/Learn/CSS
- Ask questions, if you have them

#+begin_notes
The articles linked to from the main part of
https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML
should now make sense to you all.  They introduce some more HTML than
we've covered in the course, but in an accessible way.

The equivalent pages for CSS are linked to from
https://developer.mozilla.org/en-US/docs/Learn/CSS. If you read those
you'll find out about a handful of CSS features we've not covered yet
either. Being able to learn these things from the documentation is an important skill.
#+end_notes
