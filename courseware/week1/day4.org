#+Title: Powercoders Basel Course work, Day 4, CSS
#+INCLUDE: "../include/settings.org"

* Longer recap

- Files and directories
- HTML
  - Elements, attributes, structure
- The command line
- Version control with Git
- Your cheatsheets

* TODO Goals for today

- Introducing CSS
- More experience with version control

* DONE Introducing styling to the web

- HTML says "What it is", not "What it should look like"
- Mostly...
- *Cascading Style Sheets* (CSS) say what it should look like
- "This element..."
  - "... or these elements..."
  - "... should look like this"
- These are CSS *rules*

* TODO A CSS rule

#+BEGIN_SRC css
p {
  color: red;
  font-weight: bold;
  margin-left: 2em;
}
#+END_SRC

#+BEGIN_NOTES
Here's an example CSS rule.

It starts with a selector, =p=. The selector says which elements the
rule should apply to. In this case, the selector will apply to all
the =p= elements on the page.

The selector is followed by a block of *declarations*. The block starts
and ends with the opening and closing curly brackets.

Inside the block are three declarations. Each declaration is the name
of a property, a colon, and the value for the property. And then
finished with a semi-colon.

This CSS rule tells the browser to find all the =p= elements and make
the text color red, bold, and give them a left margin that is 2 ems
wide.

An "em" is a special distance -- it's the width of the letter m in
whichever font and size you are using. So if you have a big font
2ems is wider than 2ems in smaller font.
#+END_NOTES
* TODO A CSS rule

#+BEGIN_SRC css
selector {
  property_1: value_1;
  property_2: value_2;
  property_3: value_3;
  ...
}
#+END_SRC

#+BEGIN_NOTES
[A more formal definition of the structure]
#+END_NOTES

* TODO Adding CSS to the scratch file

- Create =scratch/style.css=
- Create =scratch/css.html=

#+INCLUDE: "day4/css.html" src html

#+BEGIN_NOTES
- External file immediately
  - Teach good practice from the beginning
  - Makes it easier to manage
  - Avoids mixing different syntaxes in the same file
- Create the empty file (CLI, use touch)
- Link to it. Reload page, show that nothing has changed.
#+END_NOTES

** Don't forget to add and commit

#+BEGIN_SRC shell
git add scratch/style.css
git add scratch/css.html
git commit -m "..."
#+END_SRC

** TODO Add some HTML content

#+INCLUDE: "day4/css-2.html" :lines "8-23" src html

#+BEGIN_NOTES
Add this content to the body. Make sure that Atom doesn't
complain about the markup.

Those =id= and =class= attributes -- those are new, we're going
to cover those very soon, for now, just make sure you enter them
exactly.
#+END_NOTES

** TODO Add some HTML content

#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day4/css-2.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS:
[[file:add-some-html-content.png]]

** Add and commit!

#+BEGIN_CENTER
Don't forget to add and commit the changes.
#+END_CENTER

* CSS Selectors
** TODO Selecting all elements of a particular type

 #+REVEAL_HTML: <div class="leftcol">
 #+INCLUDE: "day4/style-3.css" src css

- Check, add, and commit
 #+REVEAL_HTML: </div>

 #+REVEAL_HTML: <div class="rightcol">
 #+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day4/css-3.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
 #+END_SRC

 #+RESULTS:
 [[file:styling-all-elements-of-a-particular-type.png]]
 #+REVEAL_HTML: </div>

 #+BEGIN_NOTES
 p selector.

 =color= sets the text colour.

 =background-color= sets the background colour.

 We've given it a left and a right margin.
 #+END_NOTES

** TODO Selecting one element using =id=

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day4/style-4.css" src css

- Check, add, and commit
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day4/css-4.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS:
 [[file:styling-just-one-element-using-id.png]]


 #+BEGIN_NOTES
 - Introduce the id attribute
 - Give selector example
 #+END_NOTES

** TODO Selecting elements based on container

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day4/style-5.css" src css

- Check, add, and commit
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day4/css-5.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS:
[[file:selecting-elements-based-on-container.png]]

#+BEGIN_NOTES
Problem - we only wanted the =em= in the =p=, but we got the one
in the =li= as well.

How do we fix that?
#+END_NOTES

** TODO Styling elements based on container

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day4/style-6.css" src css

- Check, add, and commit
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day4/css-6.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS:
[[file:styling-elements-based-on-container.png]]

#+BEGIN_NOTES
Our selector is now more *specific*, saying that it only matches
=em= elements that are inside =p= elements
#+END_NOTES

** TODO Styling all elements of particular class

#+REVEAL_HTML: <div class="leftcol">
#+INCLUDE: "day4/style-7.css" src css
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day4/css-7.html")) :flags --window-size=320,320 --force-device-scale-factor=2 :exports results
#+END_SRC

#+RESULTS:
[[file:styling-all-elements-of-particular-class.png]]

* TODO The =id= attribute

#+REVEAL_HTML: <div class="leftcol">
- All elements support the =id= attribute
- Value is an arbitrary string
- Value *must* be unique in the HTML
- Use for things that appear at most once
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html
<div id="header">...</div>

<div id="main-content">...</div>

<p><span id="author">...</span>
   <span id="publish-date">...</span>
   <span id="category">...</span></p>
#+END_SRC
#+REVEAL_HTML: </div>
* TODO The =class= attribute

#+REVEAL_HTML: <div class="leftcol">
- All elements support the =class= attribute
- Value is an arbitrary string
- Value *does not* need to be unique in the HTML
- Use for things that might appear multiple times
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html
<p class="warning">...</p>

<pre class="html">...</p>

<pre class="css">...</p>

<img class="screenshot">
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Some example classes.
#+END_NOTES

* Break

* TODO CSS colours

** Colour theory, red, green, blue, alpha

- RGBA = Red, Green, Blue, Alpha
- R, G, B in range [0 - 255]
  - 0 = none of that colour
  - 255 = maximum amount of that colour
- Alpha in range [0.0 - 1.0]
  - 0.0 = completely transparent, 0% of the colour
  - 1.0 = completely opaque, 100% of the colour
  - 0.5 = 50%  of the colour
  - 0.25 = 25% of the colour, etc

#+BEGIN_NOTES
Computers generally represent a colour as the combination
of 4 different values.

The first three values represent the amount of a particular colour
in each. Those colours are the amount of red, green, and blue in
the image.

The fourth value is called the *alpha*, or transparency of the
image, and goes from 0.0 to 1.0.

A value of 1.0 for the alpha means the colour is not transparent at
all. A value of 0.5 means it's 50% transparent. And 0.25 means it's
75% transparent.

These values then get mixed together to create the final colour
that you see on the screen.
#+END_NOTES

** TODO Colour examples

#+BEGIN_SRC html-chrome :url (shell-quote-argument (expand-file-name "day4/colour-table.html")) :flags --window-size=1024,800 --force-device-scale-factor=1.0 :exports results
#+END_SRC

#+RESULTS:
[[file:colour-examples.png]]

** CSS colour properties

- =color=
- =background-color=
- =border-color=
- =text-decoration-color=
- ...

#+BEGIN_NOTES
Generally, the =color= property is used to define the foreground
colour of an element's content, and the =background-color=
property defines the background colour.

Depending on the element other CSS colour properties might also
be available.

For example, if the element supports borders then you can give
them a color using =border-color=.

For text content that is decorated -- for example, with an underline,
the colour of the decoration is normally the same as the colour
of the text. But you can change that using the =text-decoration-color=
property.
#+END_NOTES

** How to specify CSS colours

#+BEGIN_NOTES
Now that we know that, lets take a look at the syntax for specifying
colours in CSS.
#+END_NOTES

*** Colour names

#+BEGIN_SRC css
p {
  color: black;
}
#+END_SRC

#+REVEAL_HTML: <div class="leftcol">
- =black=
- =silver=
- =gray=
- =white=
- =maroon=
- =red=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- =purple=
- =fuchsia=
- =green=
- =lime=
- =olive=
- =yellow=
#+REVEAL_HTML: </div>

#+BEGIN_CENTER
... and more
#+END_CENTER

#+BEGIN_NOTES
You've already seen this in the examples to date. CSS supports
some predefined colour names that you can use that always mean
the same thing.

Note that the names are *not* surrounded by quote marks in the CSS.

Using the colour names is OK when you're testing stuff out, but
they have some limitations, including:

- No support for an alpha value
- Typo's in the names will result in them being ignored

So it's generally best to use one of the other mechanisms.
#+END_NOTES

*** rgb(r, g, b)

#+BEGIN_SRC css
p {
  color: rgb(185, 61, 244); /* Royal purple */
}
#+END_SRC

- =rgb(red_value, green_value, blue_value)=

#+BEGIN_NOTES
This syntax is very common. You write =rgb()= (with opening and
closing parentheses) and then you write the red, green, and blue
numbers inside, separated by commas.

By the way, that slash-star and star-slash is how we include a
comment in a CSS file.
#+END_NOTES

*** rgba(r, g, b, a)

#+BEGIN_SRC css
  p {
    color: rgba(185, 61, 244, .67); /* Royal purple, 67% opaque */
  }
#+END_SRC

- =rgb(red_value, green_value, blue_value, alpha_value)=

#+BEGIN_NOTES
If you need to specify the alpha value then you use =rgba= instead
of =rgb=.
#+END_NOTES

*** With hexadecimal digits

#+BEGIN_SRC css
p {
  color: #b93df4; /* Royal purple */
}
#+END_SRC

#+BEGIN_NOTES
This is not the time to learn hexadecimal.

Who here already knows hexadecimal numbers?

[Wait -- if more than one or two]

OK, very briefly, the six digits are the hexadecimal representation
of the red, green, and blue values. The first two hexadecimal digits
are the red component, the middle two are the green component, and
the last two are the blue component.

At the time that we're doing this there is experimental support for
specifying the alpha value using a similar syntax, but it's not
widely implemented yet.
#+END_NOTES

*** DONE Recommendation: Use =rgb()= or =rgba()=

#+BEGIN_NOTES
My recommendation for you all is to use the =rgb()= or =rgba()=
syntax when specifying colours, and that's what I'll be doing
through the rest of the course.
#+END_NOTES

*** TODO Colour picker for Atom

- =File= > =Settings=
- =+ Install=
- Search for =color-picker=
- Install it

| Windows              | OS X                |
|----------------------+---------------------|
| =Ctrl= + =Alt= + =c= | =âŒ˜= + =Shift= + =c= |

* TODO Colour palettes

* TODO The browser inspector

- =More tools= > =Developer tools=

#+BEGIN_CENTER
Live demo
#+END_CENTER

#+BEGIN_NOTES
A tour of the browser inspector.

- How to open it
  - Menu
  - Ctrl + Shift + i
  - Right click, inspect element

The "Elements" sheet (which is the only one we're concerned with at
the moment).

- The top pane
  - Dynamic version of the loaded page
  - Demo:
    - Hovering highlights the hovered element
    - Toggling nested elements
    - Double-click text content to edit it
    - Double-click element name to change it
    - Right-click menu

- CSS selector immediately below the pane
  - Show how it changes as different elements are selected
  - Show how it shows ID and class for CSS

- Style pane
  - Toggling styles on and off
  - Direct editing of the style (property name and value)
  - Special helpers for certain properties (e.g., colour)
  - element.style section, for just that element
  - Links from the property set to the CSS file that defines it
  - Inheritance (use p and p#footer for this)

- Show how to dock to different sides

Reiterate that any changes made in the inspector are not permanent,
and will be lost as soon as the page reloads.

- The console (if displayed)
  - Just show that it's there and that we'll be using it next week

- How to get out of developer tools
#+END_NOTES

* You experiment with the Developer Tools


* CSS resources

- MDN page
- Colors
  - color.adobe.com
  - www.paletton.com
  - coolors.co
  - https://material.io/tools/color

* TODO Exercises and Practice

- Start adding styles to your portfolio
  - Choose a colour scheme

- Try and repoduce images as web page
  - https://003.powercoders.org/files/exercise_7_webdesign_1.jpg
  - https://003.powercoders.org/files/exercise_7_webdesign_2.jpg
  - Prob. requires =table= and =float=
  - (easier): https://003.powercoders.org/files/webdesign_3.PNG
    - Float
  - CV Workshop: https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-02/wed-may-2
    - TODO: Make this a separate file, link to it from here.
* Advanced CSS material
* CSS reset
** Where do default styles come from?

- The browser includes a stylesheet
- It sets the default behaviours that your stylesheet overrides
- Called the =user agent stylesheet=
- Different browsers can have different defaults

#+BEGIN_NOTES
You might be asking yourself how the browser knows how to style
things if you don't use any CSS?

For example, even if you don't have a CSS file, the browser still
makes =h1= headings larger than =h2= headings. And those headings
are larger than paragraphs.

Links are blue, and underlined, and so on.

The answer is that each browser comes with its own default stylesheet
that it falls back to if you don't provide any styles for a
particular element.

This is referred to as the user agent stylesheet. We say that the
browser is acting as an "agent" on behalf of the "user", which is
where the term comes from.

Now, can anyone see how this might cause a problem when there are
lots of different browsers?

[Wait]
#+END_NOTES

** Different user agents have different default stylesheets

- The same page can look different in different user agents
- Argggggh!

#+BEGIN_NOTES
Right -- different browsers can have different default styles for
different things.

For example, one browser might give more space around headings than
another browser. Or maybe use a different font size. Or font. Or
colour. Or line height.

This can make it very difficult to get web page designs that look
and work correctly in all browsers when these defaults change.
#+END_NOTES

** CSS "reset" or "normalize" stylesheets

- Eric Meyer's [[https://meyerweb.com/eric/tools/css/reset/][reset stylesheet]]
- Nicolas Gallgher and Jonathan Neal's [[https://github.com/necolas/normalize.css][normalize.css]]

#+BEGIN_NOTES
In order to deal with this people started developing stylesheets
that would "reset" or "normalize" the styles to a known baseline,
overriding all the browser defaults and ensuring that your CSS
rules start from the same base set of styles.

Erir Meyer's reset stylesheet, and normalize.css are two of the
most well known I think.

I'm mentioning this here *not* because you need to start using
these in your projects here (yet).

But I do want you to know that this inconsistency between the
browser default stylesheets is a problem, and these reset or
normalize stylesheets are the ways that we work around this.
#+END_NOTES
* TODO Internal and inline styles

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_CENTER
Internal
#+END_CENTER
#+BEGIN_SRC html
...
<head>
  <style>
    body {
      background-color: grey;
      color: blue;
      font-size: 1em;
      font-family: Arial, Sans-Serif;
    }
  </style>
</head>
...
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_CENTER
Inline
#+END_CENTER
#+BEGIN_SRC html
<p style="margin-left: 3em; color: red;">...</p>
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
So far we've been putting all of our CSS in a separate file and loading
it in the page with a =link= element.

This is generally the best way to do it -- it keeps the CSS language
entirely in its own file which is much easier to deal with.

However, there are two other ways of specifying CSS rules that I want
you to know, just in case you ever encounter them.

The first, on the left, is internal CSS.

You can put a =style= element in the document's =head=, and then write
your CSS rules there.

The second, on the right, is inline CSS. Each element supports a
=style= attribute. The value of the attribute is one or more CSS
properties, separated by semi-colons.

There's no need to use a selector here, because the style only applies
to this element.

This can be a very quick way of experimenting with a different style
just for one element -- you don't have to find the specific selector
for it -- but I find that experimenting with the styles using the
browser inspector is an even better approach.

I'm going to use internal and inline styles in some of the examples
just so that everything fits on one slide. But you should generally
always use external stylesheets, and the =link= element.
#+END_NOTES
* TODO CSS Cascades and Specificity

- Most specific CSS rule wins
  - #id is more specific than .class
  - .class is specific then just an element
- Tie break, last one declared wins

** Exercise: CSS Cascades and Specificity 1

#+REVEAL_HTML: <div class="leftcol">
#+NAME: css-specificity-1
#+BEGIN_SRC html-chrome :exports code
<!DOCTYPE html>
<html>
  <head>
    <style>
      body p { color: green; }
      html p { color: purple; }
    </style>
  </head>
  <body>
    <p>Here is a paragraph</p>
  </body>
</html>
#+END_SRC

#+RESULTS: css-specificity-1
[[file:css-specificity-1.png]]

#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- What colour is the paragraph?
  - Green?
  - Purple?
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Don't do this, this is just a quiz.

Will the =p= element's content be green or purple?
#+END_NOTES

** Solution: CSS Cascades and Specificity 1

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<css-specificity-1>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :noweb yes :exports results
<<css-specificity-1>>
#+END_SRC

#+RESULTS:
[[file:solution-css-cascades-and-specificity-1.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
In this case the two CSS rules both match the heading. The first
says "Match =h1= after =body=", and the second says "Match =h1=
afer =html=".

Both rules have the same specificity -- neither of them have classes
or IDs, they're just simple selectors.

Although the =body= element is closer to the =h1= element in the
tree that doesn't matter.

So the CSS rule that's defined last wins, and that's why the title
is in purple and not green.
#+END_NOTES

** Exercise: CSS Cascades and Specificity 2

#+REVEAL_HTML: <div class="leftcol">
#+NAME: css-specificity-2
#+BEGIN_SRC html-chrome :exports code
<!DOCTYPE html>
<html>
  <head>
    <style>
      p {
        color: white;
        background-color: black;
      }
      p.info {
        background-color: rgba(0, 0, 255, 0.5);
      }
    </style>
  </head>
  <body>
    <p class="info">Here is a paragraph</p>
  </body>
</html>
#+END_SRC

#+RESULTS: css-specificity-2
[[file:css-specificity-2.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- What colour is the paragraph?
  - White text, black background?
  - Black text, blue background?
  - White text, blue background?
  - Black text, light blue background?
  - White text, light blue background?
#+REVEAL_HTML: </div>

** Solution: CSS Cascades and Specificity 2

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<css-specificity-2>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :noweb yes :exports results
<<css-specificity-2>>
#+END_SRC

#+RESULTS:
[[file:solution-css-specificity-2.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
It's white text with a light blue background.  Here, the most specific
rule is =p.info=, because the =p= has a =class= value of =info=.

That sets the =background-color=. However, the paragraph also matches
the =p= rule. The =color= property in that rule is *not* overridden
by the =p.class= rule, so it gets applied as well.

The properties have cascaded together.

Finally, it's a light blue background because the colour is specifed
with a 50% alpha value -- so the blue is modified by the white of the
page "underneath" the paragraph.
#+END_NOTES

** Exercise: CSS Cascades and Specificity 3

#+REVEAL_HTML: <div class="leftcol">
#+NAME: css-specificity-3
#+BEGIN_SRC html-chrome :exports code
<head>
  <style>
    p {
      color: white;
      background-color: black;
      text-decoration: none;
      border: 1px solid black;
    }
    p.info {
      background-color: rgba(0, 0, 255, 0.5);
      text-decoration: underline;
      padding: 1em;
    }
    p#tip {
      color: black;
      background-color: rgba(0, 255, 0, 0.5);
    }
  </style>
</head>
<body>
  <p id="tip" class="info">Here is a paragraph</h1>
</body>
#+END_SRC

#+RESULTS: css-specificity-3
[[file:css-specificity-3.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
What will the paragraph look like?
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
#+END_NOTES
** Solution: CSS Cascades and Specificity 3

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<css-specificity-3>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :noweb yes :exports results
<<css-specificity-3>>
#+END_SRC

#+RESULTS:
[[file:solution-css-specificity-3.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here the paragraph has picked up styling from three rules.

Because it has =id= set to =tip= it's black with a partially transparent
green background.

Because it has =class= set to =info= it's also picked up the
=p.info= style rules.

The =background-color= is ignored, because it's overridden by the
=#info= style, but both the =text-decoration= and =padding= rules
have been applied.

Finally it also matches the =p= rule. But the =p= rule's =color=,
=background-color=, and =text-decoration= are overriden by the other
rules, so this rule contributes nothing.
#+END_NOTES

* TODO CSS fonts

- CSS gives a lot of control over the appearance of text
- Collectively, these are the =font-*= properties.

* Font-families: Serif, sans-serif, and monospace

#+REVEAL_HTML: <div class="leftcol">
#+NAME: basic-font-families
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html>
    <head>
      <style>
	h1.serif { font-family: serif; }
	h1.sans { font-family: sans-serif; }
	h1.mono { font-family: monospace; }
      </style>
    </head>
    <body>
      <h1 class="serif">This is serif</h1>
      <h1 class="sans">This is sans-serif</h1>
      <h1 class="mono">This is monospace</h1>
    </body>
  </html>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :exports results :noweb yes
<<basic-font-families>>
#+END_SRC

#+RESULTS:
[[file:serif-sans-serif-and-monospace-fonts.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
There are three main font types that we care about.

Serif fonts are called that because they have the little sticking
out bits at the ends of bits of the letters. For example, at the
left and right ends of the top of the T.

Sans-serif literally means "without serifs" -- as you can see in
the second heading these letters have no sticking out bits.

And monospace fonts might be serif or sans-serif. Ther main
characteristic is that all the letters are the same width.

When you've been programming you've been using a monospace
font in your editor.
#+END_NOTES

** Default fonts are set in the browser

- chrome://settings/fonts

#+BEGIN_NOTES
When you specify just =serif=, =sans-serif=, or =monospace= the
browser will use whichever font the user has configured their
browser to use for that type.

In Chrome if you go this URL you'll see the configuration page
that lets the user decide what to use.
#+END_NOTES

** A font stack

#+BEGIN_SRC css
body {
  font-family: 'DejaVu Serif', 'Times New Roman', Times, serif;
}

h1, h2, h3, h4, h5, h6 {
  font-family: 'DejaVu Sans',
}

pre, code, tt {
  font-family: 'DejaVu Sans Mono', monospace;
}
#+END_SRC

#+BEGIN_NOTES
You can list multiple fonts for a =font-family= entry. This is
called a *font stack*.

When the browser sees a font stack it checks to see if the first
font in the list is installed on the user's computer. If it is
it uses it.

If it's not it moves on to the next font in the list. So you
should list the fonts in the stack from most specific to least
specific.

In this example the =body= text will be displayed in "DejaVu Serif"
if it's installed on the computer.

If it's not then "Times New Roman" will be used. If that's not
there then "Times". And finally, whatever the browser is configured
to use for a serif font will be used.

Notice how the fonts with spaces in the names have to be enclosed
in double quotes.
#+END_NOTES

** "Web safe" fonts

- [[[https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals#Web_safe_fonts][MDN Web Safe fonts]]]

| *Names* / *Font stack*   | *Type*     |
|--------------------------+------------|
| =Helvetica, Arial=       | sans-serif |
| =Courier New, Courier=   | monospace  |
| =Georgia=                | serif      |
| =Times New Roman, Times= | serif      |
| =Verdana=                | sans-serif |

#+BEGIN_NOTES
Because you can't rely on all users that are browsing your web
page to have the same fonts installed, the idea of "web safe"
fonts emerged.

These are fonts that are so common that it's safe to assume
that they're installed on all computers that will browse your
site.

In the table here some fonts have newer, or nicer variants,
but that might be a bit less common.

For example, =Courier New= is a newer version of =Courier=. If
it's available then use it, otherwise fallback to =Courier= in
the font stack.
#+END_NOTES

** Downloadable fonts

#+BEGIN_SRC css
@font-face {
  font-family: 'Open Sans';
  src: local('OpenSans Regular'),
       url('/fonts/OpenSans-Regular-webfont.woff2') format('woff2'),
       url('/fonts/OpenSans-Regular-webfont.woff') format('woff');
}
#+END_SRC

#+BEGIN_NOTES
Of course, this is very limiting to the design of your site --
if you can only assume that a handful of fonts are installed
then you don't have a lot of flexibility.

Early attempts to solve this typically involved creating images
of the text that you wanted to appear in a special font, and
using those images on your site.

But this had problems:

- The image files can be quite large
- They don't scale well if the user zooms in or not
- Even with the =alt= attribute they're not very accessible
- The user can't copy the text in the image

and so on.

So a mechanism was invented in CSS to allow the designer to
specify new font family names, and to provide URLs where the
browser could download the font from.

This is the =@font-face= CSS rule. Notice the leading =@= sign.

This example rule defines a new face, called "Open Sans". The
=src= block tells the browser where to find the font.

This starts with a =local= entry. It tells the browser that if
a local font called "OpenSans Regular" is already installed on
the computer then use that.

If the font isn't installed then the =url= entries tell the
browser where the font can be downloaded from.

There are several different formats for font files, and this
example specifies two URLs in two different formats.

Because these font specifications are entirely specified in CSS,
and because you can use the =link= elemnt to point to multiple
CSS files, people realised that you could create online repositories
of free fonts and make it very easy to include them in web pages.

Google Fonts is an example of this.
#+END_NOTES

** The Google Fonts site

#+BEGIN_CENTER
Demo - [[https://fonts.google.com]]
#+END_CENTER

#+BEGIN_NOTES
[Demo using the Google Fonts site]

[Find the Lato font]
#+END_NOTES

** Google Fonts Example

#+NAME: google-fonts-example
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html>
    <head>
      <title>Google Fonts example</title>
      <link href="https://fonts.googleapis.com/css?family=Lato"
	    rel="stylesheet">
      <style>
	h1.lato { font-family: Lato, sans-serif; }
	h1.sans { font-family: sans-serif; }
      </style>
    </head>
    <body>
      <h1>An unstyled heading</h1>
      <h1 class="lato">A heading in Lato</h1>
      <h1 class="sans">A heading in sans-serif</h1>
    </body>
  </html>
#+END_SRC

#+BEGIN_NOTES
Here I have a simple page. In the =head= element I link to
an external Google Fonts CSS file to load a font called "Lato".

In the =style= element I create two different =h1= styles,
one which will use the Lato font and fall back to =sans-serif=
if it's not available, and one that always uses the =sans-serif=
font.

Then I create three =h1= elements styled differently.

All clear?

[Wait]
#+END_NOTES
*** Google Fonts example

#+BEGIN_SRC html-chrome :noweb yes :exports results :flags --window-size=400,240 --force-device-scale-factor=2
<<google-fonts-example>>
#+END_SRC

#+RESULTS:
[[file:google-fonts-example.png]]

#+BEGIN_NOTES
And here's the result.

The first heading uses whatever the browser's default stylesheet
says to use as the font. In this case it's a serif font.

The second heading has used Lato.

And the third heading has used the browser's default sans-serif
font.
#+END_NOTES

** Exercise: Google Fonts

- Choose three fonts from Google Fonts
  - One sans-serif, for headings
  - One serif, for almost everything else
  - One monospace
- Update your files to use them

#+BEGIN_NOTES
For this exercise, go to Google Fonts and choose two fonts,
one sans-serif, and one serif.

Generally, sans-serif fonts look better when used as headlines,
and serif fonts are better when used for the main text on the
page.

Choose one of each that you like, and use the Google Fonts site
to get the code to include in a =link= element in the =head=
of your pages.

Make the changes to your pages, and style the =body= and =heading=
elements to use the fonts that you have chosen.

[Wait]
#+END_NOTES

** Solution: Google Fonts (html)

#+NAME: google-fonts-solution
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html>
    <head>
      <title>Google Fonts example</title>
      <link href="https://fonts.googleapis.com/css?family=Cardo|Cutive+Mono|Titillium+Web"
            rel="stylesheet">
      <link href="style.css" rel="stylesheet">
    </head>
    <body>
      <h1>My first heading</h1>

      <p>I like to write. Using only short sentences. It's
        very relaxing.</p>

      <pre>echo "Don't forget to add and commit your changes"</pre>
    </body>
  </html>
#+END_SRC

** Solution: Google Fonts (CSS)

#+BEGIN_SRC css
h1, h2, h3, h4, h5, h6 {
  font-family: 'Titilliam Web', sans-serif;
}

pre, tt, code {
  font-family: 'Cutive Mono', monospace;
}

body {
  font-family: 'Cardo', serif;
}
#+END_SRC

** Result: Google Fonts

#+BEGIN_SRC html-chrome :exports results :flags --window-size=400,240 --force-device-scale-factor=2
  <!DOCTYPE html>
  <html>
    <head>
      <title>Google Fonts example</title>
      <link href="https://fonts.googleapis.com/css?family=Cardo|Cutive+Mono|Titillium+Web"
	    rel="stylesheet">
      <style>
	h1, h2, h3, h4, h5, h6 {
	  font-family: 'Titilliam Web', sans-serif;
	}

	pre, tt, code {
	  font-family: 'Cutive Mono', monospace;
	}

	body {
	  font-family: 'Cardo', serif;
	}
      </style>
    </head>
    <body>
      <h1>A simple heading</h1>

      <p>I like to write. Using only short sentences. It's
	very relaxing.</p>

      <pre>echo "Don't forget to and and commit your changes"</pre>
    </body>
  </html>
#+END_SRC

#+RESULTS:
[[file:result-google-fonts.png]]
* TODO =font-size: ...=

#+REVEAL_HTML: <div class="leftcol">
- Sets the height of the font
- =body= default is =16px=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC css
p {
  /* Size measured in pixels */
  font-size: 16px;
}

p.warning {
  /* Size measured in 'm' widths (approx) */
  font-size: 1.5em;
}
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
You adjust the height of the font with =font-size=.

There are several different ways to specify the size, but the most
common are =px= and =em=.

Using =px= sets the size in pixels. The default value for elements
in the body that don't have an explicit size is =16px=. Remember
that that the user agent stylesheet might change that.

Using =em= sets the size relative to the size of element that
contains this one.

All these sizes will be adjusted if the user uses the browser's
controls to zoom in or out of the page.
#+END_NOTES

** =font-size: ...= example

#+REVEAL_HTML: <div class="leftcol">
#+NAME: font-size-example
#+BEGIN_SRC html
<!DOCTYPE html>
<html>
  <head>
    <style>
      article { font-size: 2em; }
      article p { font-size: 0.75em; }
    </style>
  </head>
  <body>
    <p>Unstyled p, size = 16px = 1em.</p>

    <article>
      <p>article p, size = ?px</p>
    </article>
  </body>
</html>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :noweb yes :exports results
<<font-size-example>>
#+END_SRC

#+RESULTS:
[[file:font-size-example.png]]
#+REVEAL_HTML: </div>

** Solution: =font-size: ...=

#+REVEAL_HTML: <div class="leftcol">
#+NAME: font-size-example2
#+BEGIN_SRC html
<!DOCTYPE html>
<html>
  <head>
    <style>
      article { font-size: 2em; }
      article p { font-size: 0.75em; }
    </style>
  </head>
  <body>
    <p>Unstyled p, size = 16px = 1em.</p>

    <article>
      <p>Article = 2em = (default * 2)
        = (16px * 2) = 32px</p>

      <p>article p = 0.75em = (article * 0.75)
        = (32 * 0.75) = 24px</p>
    </article>

    <p style="font-size: 24px;">p, forced to 24px.</p>
  </body>
</html>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome :exports results :noweb yes :flags --window-size=640,240 --force-device-scale-factor=2
<<font-size-example2>>
#+END_SRC

#+RESULTS:
[[file:solution-font-size.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here's how that calculation works out.

The default body size is 16px. Unless something's changed, 1em
equals 16px.

We set article's size to 2em. This means the default * 2, so 16 * 2,
which is 32 pixels.

Then we set the =article p= to 0.75em. This means 75% of whatever the
default for article is. Since article is 32px this means 75% of 32,
which is 24.

So the final size for the p is 24px.

I've put another =p= element at the bottom and explicitly set its
size to 24px, and as you can see, they're the same.
#+END_NOTES

* TODO =font-weight: ...=

- Says how bold the text should be

#+BEGIN_SRC css
strong {
  font-weight: bold; /* Default */
}
#+END_SRC

#+BEGIN_SRC css
strong {
  font-weight: normal; /* Disables bold */
}
#+END_SRC

#+BEGIN_SRC css
span.bolder {
  /* <strong>This is <span class="bolder">more bold</span></strong> */
  font-weight: bolder;
}
#+END_SRC

#+BEGIN_SRC css
span.lighter {
  /* <strong>This is <span class="lighter">less bold</span></strong> */
  font-weight: lighter;
}
#+END_SRC

#+BEGIN_NOTES
=font-weight= says how *heavy* the text should be. Normal text has
a weight of =normal=. You can say that text should be made bolder,
or bolder than the surrounding element, or ligher than the
surrounding element.
#+END_NOTES

* TODO =font-style: ...=

- Used for italic variations, rare

#+BEGIN_SRC css
em {
  font-style: italic; /* Default */
}
#+END_SRC

#+BEGIN_SRC css
em {
  font-style: normal; /* Disables italics */
}
#+END_SRC

#+BEGIN_SRC css
em {
  font-style: oblique; /* Simulates italic */
}
#+END_SRC

#+BEGIN_NOTES
It's rare to see =font-style= used. It controls whether the content
should be shown in italics or not. It has three values.

- =italic= is the default for elements like =em=, and will show
  the content in italics.

- =normal= disables the italics, and shows the content normally.

- =oblique= is a bit like italics, but instead of using the italic
  version of font, it takes all the normal letters and applies a
  slant to them, resulting in a slightly different effect.
#+END_NOTES
* TODO =line-height: ...=

- How much extra space to leave around each line
- Gives the text some "breathing room"
- Value is a multiplier of the font-size

#+BEGIN_SRC css
body {
  line-height: 1.2;  /* Font size * 1.2 */
}
#+END_SRC

#+BEGIN_NOTES
Using =line-height= lets you set the overall height of each line.

Normally, this is the =font-size= plus a little bit extra, and you
can control how much extra.

It's generally accepted that a bit more space between the lines
gives the text some breathing room, and makes it easier to read.

There are several ways to specify this (including using absolute
px values, and ems) but the best way is generally to use a
unit-less number, as it is in this example. Then it takes whatever
the font-size is and multiplies it by this number to compute the
line height.

Depending on the font values of between 1.2 and 1.5 generally give
good results.
#+END_NOTES

* TODO =font: ...= shorthand property

#+BEGIN_SRC css
p {
  font: italic normal bold normal 3em/1.5 Helvetica, Arial, sans-serif;
}
#+END_SRC

#+BEGIN_SRC css
p {
  font-style: italic;
  font-variant: normal;
  font-weight: bold;
  font-stretch: normal;
  font-size: 3em
  line-height: 1.5
  font-family: Helvetica, Arial, sans-serif
}
#+END_SRC

* TODO =text-transform: ...=

#+BEGIN_SRC css
h1 {
  text-transform: none;  /* Do nothing special */
}
#+END_SRC

#+BEGIN_SRC css
h1 {
  text-transform: uppercase;  /* Text shown in ALL CAPS */
}
#+END_SRC

#+BEGIN_SRC css 64c0d43
h1 {
  text-transform: lowercase;  /* Text shown all lowercase */
}
#+END_SRC

#+BEGIN_SRC css
h1 {
  text-transform: capitalize;  /* First Letter Capitalized */
}
#+END_SRC

#+BEGIN_SRC css
h1 {
  text-transform: full-width;  /* Similar to monospace */
}
#+END_SRC

* TODO =text-decoration: ...=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC css
p {
  text-decoration: none;
}
#+END_SRC

#+BEGIN_SRC css
p {
  text-decoration: underline;
}
#+END_SRC

#+BEGIN_SRC css
p {
  text-decoration: overline;
}
#+END_SRC

#+BEGIN_SRC css
p {
  text-decoration: line-through;
}
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC css
p {
  text-decoration-line: line-through;
  text-decoration-style: wavy;
  text-decoration-color: red;
}

/** The previous rule is identical to the next rule. */

p {
  text-decoration: line-through wavy red;
}
#+END_SRC
#+REVEAL_HTML: </div>

** Text decoration examples

#+BEGIN_SRC html-chrome :exports results
<p style="text-decoration: underline;">This has "text-decoration:
   underline;".</p>

<p style="text-decoration: overline;">This has "text-decoration:
   overline;".</p>

<p>The next text has a wavy red line-through.</p>

<p style="text-decoration: line-through red wavy">Here is some text
 that is difficult to read.</p>
#+END_SRC

#+RESULTS:
[[file:text-decoration-examples.png]]

* TODO =text-shadow: ...=


#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC css
p {
  text-shadow: x-offset y-offset blur color;
}
#+END_SRC
- =x-offset=: Shadow starts this many pixels right
  - Can be negative, shadow is offset to the left

- =y-offset=: Shadow starts this many pixels down
  - Can be negative, shadow is offset up

- =blur= is how blurry the shadow is.

- =color= is the shadow's color, can include alpha
#+REVEAL_HTML: </div>
#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html-chrome
<h1 style="text-shadow: 5px 5px 0px red;">Me
   and my shadow</h1>

<h1 style="text-shadow: -5px -5px 5px red;">Me
   and my shadow</h1>
#+END_SRC

#+RESULTS:
[[file:text-shadow.png]]
#+REVEAL_HTML: </div>

* TODO Exercises: Fonts

- [[https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals]]
- https://webdesign.tutsplus.com/articles/9-quick-wins-for-halfway-decent-design--cms-19444
- Size calculators
  - https://type-scale.com/
  - https://www.modularscale.com/
- Make your pages look prettier
  - =line-height=
  - =font-size=
  - More =font-family= choices
  - Decorations and shadows
  - Anything else...

#+BEGIN_NOTES
Some exercises.

First, open the MDN page for fundamentals of styling text. It covers
all the material we've just gone over, and a few other things as well.
It's a very handy guide to what you can and can't do.

Second, read the design tips article. It turns out that you can't just
use whatever font and font size you want and expect the result to look
nice. That article has some good hints on what to do and what to avoid.

Of course, most of the time you'll almost certainly be working with a
User Interface designer who will be making a lot of these decisions,
or you'll be collaborating with them on the decisions. But it doesn't
hurt to have a basic understanding of the problems they're trying to
solve.

The two =scale= websites both provide tools that let you create a
harmonious set of sizes to use for your fonts, so that the page
feels balanced.

And then you can use the new CSS rules we've covered to adjust your
pages to make them look prettier and more interesting.
#+END_NOTES

* TODO More selectors

- =div + p= (all =p= after a =div=)
- =p ~ ul= (all =ul= preceeded by =p=)
- =[attribute]= (all elements with attribute =attribute=)
  - =[id]= (e.g. all elements with =id= attribute)
- =[attribute=value]=
- =[attribute~=value]= (contains)
- =[attribute|=value]= (starts with)

* TODO Even more selectors

- =:checked=
- =:first-child=
  - =p:first-child=
- =::first-letter=
- =::first-line=
- =:hover=
- ...

* TODO Box Model

- Content
- Padding
- Borders
- Margins

- CSS Units
  - https://css-tricks.com/the-lengths-of-css/

#+BEGIN_NOTES
https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-02/wed-may-2
has an image of the box model
#+END_NOTES

* TODO Positioning

- https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-03/mon-may-7

** Text alignment =text-align=
* TODO Visibility

- https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-03/mon-may-7

* TODO Float

- https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-02/fri-may-4

* TODO Flexbox

- https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-02/fri-may-4

* TODO Media queries

- https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-02/fri-may-4

* TODO Principles of webdesign

- What is webdesign?
- Margins
- Whitespace
- Grids

- Bootstrap

#+BEGIN_NOTES
https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-03/tue-may-8
#+END_NOTES

* TODO CSS animations

https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-03/fri-may-11

* TODO calc()

https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-03/fri-may-11

* TODO Gradients

https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-03/fri-may-11
* TODO object-fit

https://sites.google.com/powercoders.org/resources/curriculum-003-lausanne/week-03/fri-may-11
