#+TITLE: Introduction to Javascript
#+SETUPFILE: "../../../include/settings.org"

* TODO Recap of last week

- Files, directories, the shell
- Creating HTML files
- HTML structure, elements, attributes, nesting
- Reading MDN
- Version control with Git
- Cascading Stylesheets (CSS)

* TODO Programming is...

- Taking a problem...
- ... breaking it down into smaller pieces
- ... creating instructions for those smaller pieces
- ... and putting it all together

#+BEGIN_NOTES
When we're programming we're giving the computer a set of
instructions to carry out.

The computer will, faithfully, carry out those instructions.
It doesn't care if they're wrong, or make no sense, or use the
wrong values. It will just carry out the instructions.

As a programmer, our job is to take a problem, break it down
in to a set of instructions that the computer can understand,
and then write those instructions.
#+END_NOTES

* TODO Code example

#+BEGIN_EXAMPLE
Row 1 (RS): Sl1 K 12 (13, 15, 16, 17), ssk, k1 turn (there will be a gap
after the k1). 1 st dec.
Row 2 (WS): Sl1, p5, p2tog, p1 turn (there will be a gap after the
p1). 1 st dec.
Row 3: Sl1, k to 1 st before the gap, ssk (1 st from each side of the
gap), k1 turn. 1 st dec.
Row 4: Sl1, p to 1 st before the gap p2tog (1 st from each side of
the gap), p1, turn. 1 st dec.
Repeat rows 3-4 until all sts have been worked.
#+END_EXAMPLE

#+BEGIN_NOTES
Here's something that could be a computer program.

Can anyone tell me what it actually is?
#+END_NOTES

* TODO Socks!

#+CAPTION: https://www.knitpicks.com/patterns/Do_The_Twist_Socks__D55946220.html
[[file:c:/Users/Nik%20Clayton/Documents/Powercoders/Course%20material/socks.jpg]]

#+BEGIN_NOTES
Knitting is *absolutely* programming.

- It's got a complicated syntax that not many people know
- You have to be able to visualise what the pattern does in your head
- It has the idea of repeating steps, and decision making

Does anybody here knit?
#+END_NOTES

* TODO Javascript: Adding interactivity to web pages

#+BEGIN_NOTES
Right, lets do some programming.

Programming is the art of taking a problem, breaking it down in to
small steps, and writing code that implements those steps.

If you don't know how to write the code for that step, break the
step down in to smaller steps until you do. And if you still don't,
learn how to do that step.
#+END_NOTES

* TODO JS Problem 1: Changing the style of a paragraph

- Show a paragraph of text on a web page
- Show a list with three items underneath it
  - One says "Make it a warning"
  - One says "Make it a tip"
  - One says "Make it normal"
- Clicking on them should change the paragraph style
- Show examples below the list

#+BEGIN_NOTES
Here's our problem.

[Run through the problem]
#+END_NOTES

* TODO JS Problem 1: Goal

#+BEGIN_CENTER
[[file:change_para_class/solution-1.html][The solution]]
#+END_CENTER

#+BEGIN_NOTES
And here's what the solution will look like to the user.
#+END_NOTES

* JS Problem 1: Initial HTML setup

#+INCLUDE: "samples/change_para_class/index-1.html" src html

* JS Problem 1: Initial CSS setup

#+INCLUDE: "samples/change_para_class/style.css" src css

* TODO JS Problem 1: Decompose the problem

- We know:
  - How to create a page, with paragraphs and styles
- We don't know:
  - What did the user click on?
  - How do I change the style?

#+BEGIN_NOTES
What do we already know how to do?

- Create the web page
- Add the paragraphs
- Style text using CSS

So I look at this problem and I think -- if I can figure out which
list item the user clicked on, I could change the CSS style of the
main paragraph to either the style for a warning or a style for a
tip. When the style changes the paragraph will change appearance.
#+END_NOTES

* TODO JS Problem 1: Check the solution should work

#+BEGIN_NOTES
An easy way to check and see if this solution should work is to
use the browser inspector to modify the paragraph's style to use
the appropriate CSS class.

If the look of the paragraph changes then we have a pretty good
idea that this will work.

[Demo this with [[file:change_para_class/index-1.html][index-1.html]]]
#+END_NOTES

* TODO JS Problem 1: What don't we know how to do?

- React to the user clicking on a list item
- Change the class of an element

#+BEGIN_NOTES
I need to:

- Figure out if the user clicked on a listitem
- Change the class associated with the paragraph

This is a big part of the learning process -- you decide what you
don't know, and then go off and learn the missing pieces so that
you can do what you set out to do.

Ordinarily you'd have enough experience to be able to start figuring
out what sort of documentation you can read to learn how to do this.

In this case, we're going to cheat, because not all of you have the
right amount of experience, and I'm going to help you get to the point
where you'll be able to do all of this yourself.

That's what I'm here for.
#+END_NOTES

* TODO It's time for Javascript!

#+BEGIN_NOTES
Lets get on and do some programming!
#+END_NOTES

* TODO JS: Chrome Console

- Chrome Developer Tools includes a REPL
  - Read, Evaluate, Print, Loop
  - Called the "Console"
- Type Javascript in the console (read)
- It evaluates it (evaluate)
- It displays the result (print)
- And then it goes back so we can type some more (loop)
- This is great for very quick experiments

#+BEGIN_NOTES
We've used the Chrome Dev. Tools already, but they have a lot more
functionality than we've looked at so far.

One of these is a Javascript REPL, called "console". In the console
you can type bits of Javascript code and it will read what you've
typed, run the code (we call that "evaluating it"), print the
results, and then loop back and let you enter more code.

To get to it, open the Developer Tools, and then click the "Console"
tab at the top.

TODO: Relate this to the terminal. It has a prompt, it's waiting
for you to type stuff. However, instead of typing in commands,
you're typing in Javascript code.
#+END_NOTES

* TODO Javascript expressions

#+BEGIN_SRC javascript
1 + 1;
#+END_SRC

#+BEGIN_NOTES
We're going to write a little bit of Javascript in the console. Type
the example, and make sure you end it with a semi-colon, then press
RETURN.
#+END_NOTES

** TODO Expression results

#+BEGIN_SRC javascript -n
> 1 + 1;
< 2
>
#+END_SRC

#+BEGIN_NOTES
Here's what you should see.

We call the =1 + 1= an *expression*.

Your Javascript expression on line 1 has been read, evaluated, and the
result has been printed on line 2.

Then the prompt has been displayed, waiting for you to type something
else.
#+END_NOTES

** Values

#+BEGIN_SRC javascript -n
> 1 + 1;
< 2
>
#+END_SRC

- Expressions *always* return a value
- "One plus one returns two"

#+begin_notes
When we write a Javascript expression we *always* get back a value.

Values are the information that our program operates on. Almost all programs consist of taking in values from somewhere, manipulating those values in some way, and storing or displaying the resulting values somewhere else.

This expression evaluates one plus one, and returns the value two.
#+end_notes

** TODO More expressions

#+BEGIN_SRC javascript
2 * 2;
6 / 2;
'hello' + 'world';
#+END_SRC

- Always end the line with a semi-colon, =;=
- Single quotes, ='=, not ="=

#+BEGIN_NOTES
Let's write a little bit of Javascript in the console, just to
play around.

Each line here is a different Javascript expression. Type them
out, and press RETURN at the end of each line.

Make sure you end each line with a semi-colon. It's not always
necessary, but the rules for when you don't need to are complex
so for the moment you need to get in to the habit of always
doing so.

Use single-quotes around the words, not double quotes, and
be careful not to mix them up -- starting with a single quote
and ending with a double quote for example.
#+END_NOTES

** TODO What happened?

#+BEGIN_SRC javascript -n
> 2 * 2;
< 4
> 6 / 2;
< 3
> 'hello' + 'world';
< "helloworld"
#+END_SRC

#+BEGIN_NOTES
What actually happened here?

Looking at line 1 first.

The right-bracket (greater than sign) is the REPL's prompt. This is
similar to the prompt in the shell -- it shows you where you can type.

Immediately after that is the Javascript code that you wrote. This is
expression. In Javascript we use the *asterisk* character to indicate
*multiplication*. This is also called the *star*.

The expression has been evaluated, and the result is 4, shown on line 2.

Line 3 is another expression. This uses the *forward slash* to divide 6
by 2, and the result, on line 4, is 3.

Line 5 is where things start to get a little bit weird. We're using the
plus sign, but we're not adding numbers together. What's going on here?

As we saw in the first example, Javascript uses the plus sign to add
two numbers together. However, when anything on the left or the right
hand side of the plus is a string of characters, it glues them together
instead.

This is called *concatenation*.

Notice how Javascript *does not* add a space between the two words, it
just sticks them right together.

Look at the result as well -- see how it's contained inside double
quotes.  This is the console's way of showing you that the value
returned is also a string of characters. Compare that with the results
from further up, which are just numbers, without quotes.

This should tell you something interesting -- numbers and strings are
different things in Javascript.
#+END_NOTES

* Value types

- Values *always* have a *type*
- *Type* is "What sort of thing is this?"
- Types we've seen so far:
  - Numbers (=1=, =2=, =3=, =3.14159...=, =4=, ...)
  - Strings (='hello'=, ='world'=, ...)
- A value can only have one type

#+begin_notes
In Javascript a value *always* has a *type*. The type tells us what sort -- or type -- of thing it is.

So far we've seen two different types that Javascript knows about.

There are numbers, like 1, 2, 3, etc.

And there are strings of characters.

As we go on we're going to discover more types.
#+end_notes

** Some number operators

| Operator | Operation           | Example | Result |
|----------+---------------------+---------+--------|
| =+=      | Addition            | =2 + 2= | =4=    |
| =-=      | Subtraction         | =2 - 2= | =0=    |
| =/=      | Division            | =3 / 2= | =1.5=  |
| =*=      | Multiplication      | =5 * 2= | =10=   |
| =%=      | Remainder / modulus | =9 % 2= | =1=    |
|          |                     | =8 % 2= | =0=    |
| =**=     | Exponention (x^y)   | =2**3=  | =8=    |

#+begin_notes
Javascript uses some fairly standard symbols for different operations on numbers.

The forward slash is how we do division, and the asterisk, or star, is what we use for multiplication.

We get the remainder of a division using the percent operator. I've put two examples here to show how that works. If we take 9 and divide it by 2 we get 4, with 1 remainder -- 4 times 2 is 8, then add 1 for 9.

But if we take 8 and divide it by 2 we get 4 with no remainder.

This is an easy way to check and see if a number is even or odd.

To perform exponention, or raising one number to the power of another number we use two asterisks next to each other. 
#+end_notes

** How to write strings

#+begin_src javascript
'this is a string'  // single quotes (style guide)
"this is a string"  // double quotes (generally avoid)
#+end_src

- The quotes are *not* part of the string
- Use single quotes (mostly), double quotes (rarely)

#+begin_src javascript
'What's up'         // this is an error
#+end_src

#+begin_src javascript
'What\'s up?'                 // backslash to "escape" the quote
"What's up?"                  // legit use of double quotes
"They said \"What's up?\"."   // more quote escaping
'They said "What\'s up?".'    // ... or use single quotes
#+end_src

- Type these strings in to the console to check

#+begin_notes
When we write strings in the console, or in code, we have to tell Javascript that it's a string.

The way that we do that is by placing a quote character at the beginning and end of the string. This is required.

If you miss off one or both of them you will have an error.

The quotes are *not* part of the string. Each one of these strings in the first example starts with the letter =t= and ends with the letter =g=.

Javascript supports using three different types of quotes for string -- single quote, double quotes, and back quotes. So which should we use?

Javascript doesn't see any difference between single quotes and double quotes. When we're programming it's a good idea to be consistent and pick a style and stick to it. For this course the style I'm using is single quotes almost everywhere.

There's an exception -- what if we want to use a quote mark inside our string?

We can't just include it, as I've done on the "this is an error code" -- when Javascript looks at this it sees a string with the value =what=, and then the =s up' ...= on the rest of the line, and doesn't know what to do with it. Notice how the colours are wrong too, that's something your editor will do to show you there are problems.

We can fix this in two ways.

The first way is to *escape* the quote inside the string. We do that by putting a backslash character immediately before it. This tells Javascript that the single quote should be treated as a regular character, and not as a character that ends the string.

The second way is to use double quotes instead.

And if you need to use double quotes inside a double-quoted string you can use the backslash to escape the quote as well.
#+end_notes

** Concatenating strings with =+=

#+begin_src javascript
'this' + 'is' + 'a' + 'string';     // 'thisisastring'
#+end_src

#+begin_src javascript
'this ' + 'is ' + 'a ' + 'string';  // 'this is a string'
#+end_src

#+begin_notes
As we've already seen, we can join strings together using the =+= operator as well.

The other operators -- subtract, multiply, divide, etc, do not work on strings.
#+end_notes

** What happens if you =+= numbers and strings?

#+begin_src javascript
1 + 'hello';    // What happens?
#+end_src

#+begin_notes
Since we can use the plus sign with both numbers and strings you might be wondering what happens if we try and add a number to a string? Like in this example here.

Try this out in the console and see what happens.
#+end_notes

** What happens if you =+= numbers and strings?

#+begin_src javascript
1 + 'hello';    // '1hello'
#+end_src

#+begin_src javascript
'1' + 'hello';  // '1hello'
#+end_src

#+begin_notes
What's happened here is that Javascript has tried to be helpful.

Adding a number to a string doesn't make sense, so Javascript has first converted the number to a string, and then, because the value on the left of the plus and the value on the right of the plus are both strings it has concatenated them together.
#+end_notes

** What happens if you =+= numbers and strings?

#+begin_src javascript
'1' + '1';     // '11', not 2
#+end_src

#+begin_notes
This can be a subtle source of problems. In this example here, even though both strings just contain numbers, because they're strings Javascript has concatenated them instead of adding them together.
#+end_notes

* TODO Variables
- Variables allow us to give names to values

#+BEGIN_SRC javascript -n
  let x;           // Declare a variable called 'x'
  x = 4;           // Set x's value to 4
  x;               // Evaluate the expression 'x'
  2 + x;           // Evaluate the expression '2 + x'
#+END_SRC

#+BEGIN_NOTES
A variable is a way of taking a *value* and giving it a *name* that we can use later.

You can think of it as being a bit like a box. You can put something
in the box -- the value -- and get it out again later. And you can
write something on the box -- the name -- to tell you what the thing
inside the box is.

Before we use a variable we should declare it. We do this using the
=let= keyword.

This first line tells Javascript "I am creating a new variable,
and it will be called =x=".

Once you have a variable you can give it a value -- put something in
the box. To do that we use the single equals sign, as we have here.

You can read this as "x becomes 4" or "x is assigned the value 4", or
"4 is put in the box labelled x".

We can use variable names in expressions. The simplest expression with
a variable is one that contains just the variable name, as we have done
on line 3 here.
#+END_NOTES

** Variables, values, and types

#+BEGIN_SRC javascript -n
  let x;           // Declare a variable called 'x'
  x = 4;           // Set x's value to 4
  x;               // Evaluate the expression 'x'
#+END_SRC

- =x= is the variable
- =x= contains the value =4=
- The type of the value is =Number=
- The variable does not have a type, the value does

** What happens if we don't give variables a value?

#+begin_src javascript
let y;             // Declare a variable called 'y;
y;                 // Evaluate the expression 'y;
#+end_src

- What does this display?

** The =undefined= value and type

#+begin_src javascript
let y;             // Declare a variable called 'y'
y;                 // Displays 'undefined'
#+end_src

- Types
  - Numbers
  - Strings
  - =undefined=

- Important: *not* ='undefined'=

** The =undefined= value and type

| *value*     | *type*      |
|-------------+-------------|
| =4=         | Number      |
| ='hello'=   | String      |
| =undefined= | =undefined= |


** TODO Variables in expressions

#+BEGIN_SRC javascript -n
  let x;           // Declare a variable called 'x'
  x = 4;           // Set x's value to 4
  x;               // Evaluate the expression 'x'
  let y = x + 2;   // <-- What does this do?
  y;               // <-- What does this show?
  x = 5;           // Change x's value to 5
  let z = x * y;   // <-- What does this do?
  z;               // <-- What does this show?
  y;               // <-- What does this show?
#+END_SRC

#+BEGIN_NOTES
We can use variable names in expressions. The simplest expression with
a variable is one that contains just the variable name, as we have done
on line 3 here.

On lines 1 and 2 we declared a variable and gave it a value using two
lines.

We can combine this in one, as you can see on line 4. Here we create
a new variable called y, and give it the value of the expression =x + 2=.

What is y's value going to be?

[Wait] -- answer is 6.

The values in variables can change. Think of it like taking something
out of the box and replacing it with something else.

That's what we do on line 6 -- we change x's value to 5.

On line 7 we create a third variable called =z=, and set its value to
=x * y=.

What will line 8 print?

[Wait] -- answer is 30.

On line 4 we set y's value to the value of x + 2. On line 6 we changed
x's value.

When we print y's value on line 9, what do you think will be shown?

[Wait] -- answer is 30

Everyone who said 30, that's right. For everyone else -- in an expression
a variable's value is evaluated once, and whatever value it had at the time
is used.

When we change =x= on line 6, =y= has already been assigned it's value based
on the value of =x= at the time. Changing =x= on line 6 has no effect on the
value from line 4.

Another way of thinking about that -- on line 4, y's value is not =x + 2=.
y's value is 6. The fact that =x= was involved in calculating that value
is *not* saved in the variable.
#+END_NOTES

* TODO Functions

#+BEGIN_SRC javascript
> alert('hello, world');
< undefined
#+END_SRC

- Functions allow us to *reuse* code
- =alert= is the *name* of the function
- Function name followed by =(...)= means we are *calling* the function
- ='hello, world'= is the function's only *parameter*
  - Sometimes also called an =argument=
- Someone else wrote the =alert= function for us

#+BEGIN_NOTES
What we're doing here is called *calling a function*.  We know it's a
function because of the round braces, or *parentheses* immediately after the function name.

TODO: Does this look like anything else we've seen [Wait: hope they
say the calc() function in CSS]

A function is a way of taking a chunk of code and giving it a name so
that we can re-use it, and call it from other places. Javascript provides
some functions for us ready to use, =alert= is one of those.

It's also possible to to write your own functions, and we'll be doing that later.

Some functions need extra information in order to operate. For example, the =alert= function needs to know the message that we want to display.  If a function needs this extra information we put it inside the parentheses. Here we have a =string=, ='hello, world'=, that the alert function will use.

We call this extra information -- if it's there -- the function's *parameters*. Sometimes we use the word *argument* as well -- they mean roughly the same thing.

When you pressed ENTER you should have seen a dialog box pop up with
the message.  After you closed the dialog box the REPL finishes and shows
you the line =undefined=.

Notice how this is *not* in quotes. This means it's not a string.

=undefined= here is a special value that Javascript has. In this case
it means that the =alert= function did not return a specific value,
so =undefined= was returned.

I know this is weird, and it's a lot to take in. We'll be doing more
exercises to strengthen this knowledge.

#+END_NOTES

** Writing to the console with =console.log=

#+begin_src javascript
console.log('hello, class');
#+end_src

#+begin_notes
We can also write to the console using the =console.log= function.

This is one of those lies that I'll explain in more detail later. =console.log= is not a function, it's something else.

But at the moment, it looks like a function, walks like a function, and quacks like a function, so we're going to treat it as though it's a function.

Try this out in your console.
#+end_notes

** Declaring / defining a function                                 :exercise:

#+BEGIN_SRC javascript
  let greet = function() {
    console.log('hello');   // <-- function body
  };
#+END_SRC

#+BEGIN_NOTES
When we write a function we say that we are *defining* it. You'll
also hear people talking about *declaring* a function. They mean
the same thing.

A function definition, like this example here, consists of:

- The name of the variable
- The *keyword* =function=
- A list of any function parameters, surrounded by parentheses. In this example there are no parameters, but we still need to include the parentheses
- The Javascript statements that define the function, surrounded by curly brackets. We call this the function *body*

Notice how there are *not* semicolons after the opening and closing
curly brackets. This is one of the exceptions to the rule that each
Javascript line should end with a semicolon.

Type this in to the REPL, and let me know when you've done that.
#+END_NOTES

** Declaring / defining a function

#+BEGIN_SRC javascript
  function greet() {
    console.log('hello');
  }
#+END_SRC

#+BEGIN_NOTES
Defining functions is so common that there's a shorthand for it that doesn't need the =let= keyword

These two examples are identical -- we've created a name, called =greet=, and said that =greet= is a function.

See how the =let= keyword is missing, and the name of the function comes after the =function= keyword.

This way is more common.
#+END_NOTES

** Calling functions

#+BEGIN_SRC javascript
  > greet();
  < "hello"
#+END_SRC

#+BEGIN_NOTES
To *call* a function you write its name, followed by any parameters it
takes, surrounded by parentheses.

If the function doesn't take any parameters (like this one) you must
still include the parentheses. As normal, we end with a semicolon.

What you've just seen here is the *flow of control* changing. Ordinarily
the REPL runs things as you type them, one after the other.

In this case you've caused the flow to change, and code that you
wrote *earlier* has been called.

Remember this, it's going to come up a lot.
#+END_NOTES

** Functions with parameters                                       :exercise:

#+BEGIN_SRC javascript
  let double = function(num) {
    return num * 2;
  };
#+END_SRC

#+BEGIN_SRC javascript
> double(10);
< 20
#+END_SRC

#+BEGIN_NOTES
Here's an example of a function that does take a parameter. As before we
have the =function= keyword followed by the function name. In parentheses
is the name of the parameter, which I've called =num=.

Inside the function body you can treat the parameter as though it was a
variable. In this case we take the value, multiply it by 2, and return
it back to the caller.

Try this, and make sure you see the same result.
#+END_NOTES

*** Functions with parameters

#+BEGIN_SRC javascript
  greet = function(name) {
    return 'hello, ' + name;
  }
#+END_SRC

#+BEGIN_SRC javascript
  > greet('Nik');
  < "hello, Nik"
#+END_SRC

#+BEGIN_SRC javascript
  > greet();
  < // What does this show?
#+END_SRC

** TODO Functions return values

- Calling a function *always* returns a value
  - A number, a string, =undefined= etc
- We can save that value in a variable, like any other value

#+begin_src javascript
let x = alert('hello, world');   // returns undefined
x;                               // undefined
#+end_src

** TODO Functions change the flow of control

* TODO Evaluating expressions in Javascript

Anywhere we have code that needs a value (3, 'hello', etc) we can replace that value with either

1. A variable that *contains* the value we need
2. A function that *returns* the value we need

#+begin_notes
TODO(nik):

Talk about the E bit of the REPL, the "evaluate" part. Explain that we've been providing expressions, and Javascript evaluates them.

In order to read and understand what the code will do you need to understand how the evaluation works.
#+end_notes

** TODO Javascript expression evaluation

   #+begin_src javascript
   3 + 3 + 3
   #+end_src

   #+begin_src javascript
   let x = 3;
   3 + x + 3;
   #+end_src

   #+begin_src javascript
   let x = 3;
   let y = 4;
   let z = 2;
   x + y * z;
   #+end_src

   #+begin_notes
   TODO(nik): Expand this with more examples, and do each evaluation it step by step.

Show more complicated examples that include function calls in the middle of expressions
   #+end_notes


* TODO Initial Javascript exercises                                :noexport:

#+begin_notes
This needs to be updated with the instructions for downloading and trying the exercises.

#+end_notes

** Install Node

** Make a copy of the repository

#+begin_notes
clone https://github.com/nikclayton/edabit-javascript-challenges
#+end_notes

** Load it in to VS Code

** Tour of each exercise

*** README

*** Tests

*** Code skeleton

*** Run the tests, they fail

*** Write some code

*** Re-run the tests

*** When they pass, submit

*** Move on to the next exercise


#+begin_notes

#+end_notes

** Exercises to do:

- [[https://github.com/nikclayton/edabit-javascript-challenges/tree/master/very-easy/return-the-sum-of-two-numbers][very-easy/return-the-sum-of-two-numbers]]
- [[https://github.com/nikclayton/edabit-javascript-challenges/tree/master/very-easy/area-of-a-triangle][very-easy/area-of-a-triangle]]
- [[https://github.com/nikclayton/edabit-javascript-challenges/tree/master/very-easy/return-the-next-number-from-the-integer-passed][very-easy/return-the-next-number-from-the-integer-passed]]
- [[https://github.com/nikclayton/edabit-javascript-challenges/tree/master/very-easy/return-the-remainder-from-two-numbers][very-easy/return-the-remainder-from-two-numbers]]
- [[https://github.com/nikclayton/edabit-javascript-challenges/tree/master/very-easy/is-the-number-less-than-or-equal-to-zero][very-easy/is-the-number-less-than-or-equal-to-zero]]
- [[https://github.com/nikclayton/edabit-javascript-challenges/tree/master/very-easy/the-farm-problem][very-easy/the-farm-problem]]

#+begin_notes
Initial set of exercises that involve functions, returning values, and simple math.
#+end_notes

* TODO Inspecting the DOM

- Document Object Model (DOM)

#+BEGIN_NOTES
So what else can we do with Javascript?

One of the most important things is inspect the Document Object Model,
or DOM.

The what?
#+END_NOTES

* TODO Let's map out where we are

- Problem: Click, change paragraph style
  - Javascript console
  - Expressions
  - Variables
  - Functions
  - DOM <-- we are here

#+BEGIN_NOTES
Remember our original problem -- we want to be able to click on one of
list items to change the style of a paragraph.

In order to do that we're having to learn a lot of new things, bit by bit.
Here's what we've covered so far, and there's more to come. I'll come back
to this periodically to make sure you don't get lost.
#+END_NOTES

* TODO Changing the DOM

#+BEGIN_SRC html
<h1 id="myheading">My First Heading</h1>

...

<script>
  document.getElementById('myheading').innerHTML = "Hello, PowerCoders!";
</script>
#+END_SRC

#+BEGIN_NOTES
The document object model is this tree of elements. Javascript provides
mechanisms to access this tree of elements, and navigate your way around
it.

Crucially, it *also* provides ways to change the DOM tree.

Who remembers this snippet from the test that we gave all the
applicants?

[Check]

Who knows *exactly* what this does?

[Check]

For those that don't, we're going to spend some time breaking this down
so that you understand it.

You've all seen =h1= before, and you know what the =id= attribute does.

[Check]

The stuff inside =script= is new.

For now, all you need to know is that the =script= element allows you
to write Javascript in a webpage, and that this line in the middle here
is some Javascript code.

This code *changes the contents of the DOM tree*. And because it changes
the tree, the web page immediately changes.

This line has three important parts to it, and we're going to break
them down.
#+END_NOTES

** TODO =document=

#+BEGIN_SRC javascript
document;
#+END_SRC

- Javascript *global* *variable*
- Contains the DOM tree
- Represented as an =HTMLDocument= *object*

#+BEGIN_NOTES
=document= is the name of a Javascript *global* *variable*.

Earlier, when we first introduced variables, we saw how you create them
with the =let= keyword.

There are some variables that already exist in Javascript. =document=
is one of those variables. You don't need to declare it, it's already
there, waiting for you to use it.

The =document= variable contains the DOM *object*, which gives you
access to the DOM. Another way of saying this is that the variable's
*type* is *HTMLDocument*.

Try typing =document;= in to the Javascript console.

What do you see?

[Demo]

The console is trying to be helpful -- it's giving you a clickable
representation of the DOM, and if you move the mouse over different parts
of it you'll see it light up.

For now, it's enough to know that objects have *properties* and *behaviours*
that we can access by using =.= character.

Another word for *behaviours* that we'll use here is *method*, which is
the proper term for this.

#+END_NOTES

** TODO =document.getElementById()=

#+BEGIN_SRC javascript
document.getElementById('myheading');
#+END_SRC

- Returns an =Element= object
- =Element= objects have their own *properties* and *methods*

#+BEGIN_NOTES
Here we are using one of those *methods* that the DOM provides.

The =getElementById()= method searches the DOM for the element that has
the ID provided as a *parameter* to the method.

Notice how this looks very similar to the =alert()= function call from
earlier. Functions and methods are very similar.

The method returns an =Element= object. Everyone try this in the console.

[Demo]

Notice how there are no double quotes around the result. This is how we
know it's not a string, but something different.
#+END_NOTES

** TODO What if you mis-spell the ID?

#+BEGIN_EXAMPLE javascript
> document.getElementById('x');
< null
#+END_EXAMPLE

#+BEGIN_NOTES
Try this, and make sure you seem the same result.

What does =null= mean here?

You've already seen =undefined=. =undefined= means that a thing has a
name, but hasn't been given any value yet.

=null= is a special value that we use to mean "This thing does not have
a value, and that's deliberate". In this case, =getElementById()= returns
the special =null= value to indicate that it couldn't find an element
with that ID.

#+END_NOTES

** TODO Types we've seen so far

- Numbers
- Strings
- undefined
- HTMLDocument (the DOM)
- An Element
- null

#+BEGIN_NOTES
So far we've seen a few different Javascript types, so lets pause for
a moment and go through them.

- Numbers are the things you and I recognise as numbers in everyday life.
- Strings are collections of one or more characters.
- =undefined= is the special "Does not have a value yet" type
- =HTMLDocument= is the type of the DOM object
- =Element= is the type returned by =getElementById()=
- =null= is the special "does not exist" type.

TODO(nik): Slide at some later point to indicate that =null= is not
actually a type.
#+END_NOTES

** TODO Storing an element in a variable

#+BEGIN_SRC javascript
let el = document.getElementById('myheading');
#+END_SRC

- Save the result in a variable
- The =let= *keyword* *declares* a variable
- =el= is the name of the variable
- === means *becomes*

#+BEGIN_NOTES
Lets save the result of calling =document.getElementById()= into a
variable so that we can use it later.

This is just like the variables that we declared earlier.
#+END_NOTES

** TODO Variable names

#+BEGIN_SRC javascript
let el;               // All lower case
let heading_element;  // snake-case
let HeadingElement;   // UpperCamelCase
let headingElement;   // lowerCamelCase
#+END_SRC

- Any letters, lower case a-z or upper case A-Z
- The underscore _

#+BEGIN_NOTES
There is *nothing* special about calling the variable =el=. It's a somewhat
common convention in Javascript, but you can call it almost anything you want,
with a few restrictions.

Broadly, variable names can contain a mix of lower or upper case letters
and numbers. You can also use the underscore character.

If you want to have a variable name that contains more than one word there
are multiple ways to represent that, all with different names. We have:

- snake case, with an underscore
- capitalising the first letter of each word, called Camel Case, because
  the upper case letters look like camel humps.
- CamelCase, but where the first letter is lower case

Javascript doesn't care what you use.
#+END_NOTES

** TODO Follow your team's style guide

- Good programmers are consistent
  - Except when they're not...
- Style guide describes conventions
- We use the [[https://google.github.io/styleguide/jsguide.html][Google Javascript style guide]]
  - Which says to use =lowerCamelCase= for variable names

#+BEGIN_NOTES
Although Javascript doesn't care, people do.

It is very common for a team to adopt a *style guide* that describes
the decisions the team has made about how things like naming variables
should be addressed.

For this course I'm using the Google Javascript style guide, and that
says that variable names that are two more words should be in
=lowerCamelCase=. So that's what we're going to do from now on.
#+END_NOTES

** TODO Using variables

#+BEGIN_SRC javascript -n
> let el = document.getElementById('myheading');
< undefined
> el;
<    <h1 id="myheading">Hello, Powercoders</h1>
> document.getElementById('myheading');
<    <h1 id="myheading">Hello, Powercoders</h1>
#+END_SRC

#+BEGIN_NOTES
As we saw earlier, anywhere you use the variable's name you're
actually referring to whatever value is inside the variable.

In this example we create the variable on line 1, and use it -- by writing
its name -- on line 3.

The result is line 4 -- remember, this is *not* a string, because it's
not surrounded by double quotes.

On line 5 we just call =getElementById()= directly, and we get the same
result.

Do you see how we have saved the result of calling =getElementById()= in
the variable?
#+END_NOTES

** TODO Element properties

#+BEGIN_SRC javascript
el.id;           // "myheading"
el.tagName;      // "h1"
el.clientWidth;  // 883
el.innerHTML;    // "Hello, Powercoders"
#+END_SRC

#+BEGIN_NOTES
Each HTML element in the DOM has properties that you can inspect, by writing
the variable name, a dot, and then the property name.

From now on in these examples I'm going to write a comment after the line that
shows what you should see.

Here are some example properties that elements have.

- =id= is the element's ID, if it has one
- =tagName= is the text of the element's tag
- =clientWidth= is how wide the element is
- =innerHTML= is the HTML text inside this element
#+END_NOTES

** TODO Changing element properties

#+BEGIN_SRC javascript
el.id = 'newid';
el.tagName = 'newname';
el.clientWidth = 400;
el.innerHTML = 'New Heading';
#+END_SRC

#+BEGIN_NOTES
You can change the value of these properties. That works for some of them,
like =id= and =innerHTML=.

It doesn't work for others, because they are fixed based on the document. You
can't change the =h1= name for example, or try and change the width of the
element like this.

Make all of these changes, and let me know when that's done.
#+END_NOTES

** TODO Property changes are reflected on the page

#+BEGIN_CENTER
Demo
#+END_CENTER

#+BEGIN_NOTES
If you go back to the "Elements" tab in the developer tools after
making those changes you'll see that they're reflected there too.

This is because this section always mirrors the current state of
the DOM.
#+END_NOTES

** TODO JS: Problem 1: We're going to...

1. Write a function...
2. ... that finds the paragraph element...
3. ... and changes its class

#+BEGIN_NOTES
Remember this? It's the actual problem that we're trying to
solve.

We still don't know how to write a function. We're going to
come to that later.

We do now know how to find the paragraph element. We're going
to have to give it an ID, and then we can use that to call
=getElementById()= to fetch the element from the DOM.

We haven't yet talked about how we might change the class
that's assigend to the element.

This is where you have to start thinking like a programmer.

We know that we can use the =innerHTML= property to change the HTML
inside the element.

If we can change the HTML inside the element then it's very likely
that there are other element properties that we can use to change
the class.

We don't know what they are, but we can make a reasonable guess
that they must exist.

But to find out if we're right we're going to have to look at
some documentation.
#+END_NOTES

** TODO Exercise: MDN Element Properties                           :exercise:

- Search for =MDN Element Properties=
- Can you find anything that shows how to change classes?

#+BEGIN_NOTES
So what I want you to do now is go to Google and search for
=MDN element properties=.

The "MDN" is to ensure that pages from the Mozilla Developer
Network come up first. And "element properties" are the things
we're interested in.

You've got 10 minutes to see what documentation you find, read
through it, and see if you find anything that looks like it will
help.

It's OK if you don't get a complete answer at this point, I just
want you to get used to searching for information and reading
the results.

[Pause here, let them do it]
#+END_NOTES

** TODO =classList= and =className=

- [[https://developer.mozilla.org/en-US/docs/Web/API/Element][MDN Element]]
- =classList=
  - [[https://developer.mozilla.org/en-US/docs/Web/API/Element/classList][MDN classList]]
- =className=
  - [[https://developer.mozilla.org/en-US/docs/Web/API/Element/className][MDN className]]

#+BEGIN_NOTES
Hopefully you found one or both of the =classList= and =className=
properties.

These are linked to from the MDN Element page, so lets take a quick
look at that page now.

TODO: Talk about the structure of the page
- Properties and methods on the right
- Description at the top
  - HTMLElement and SVGElement are distinct, that's interesting
- Early on we see =classList= and =className= properties
- Searching the page for =class= doesn't turn up much else of interest
  - Except =getElementsByClassName()=, that might be handy in the future

Let's look at the =classList= page.

- It's readonly
- Also mentions =className=
- What's a =DOMTokenList= ?
- These methods look interesting, especially =add=, =remove=, =replace=
- Look, there's example code

And =className=

- Read and write
- Simpler interface
- Also example code
#+END_NOTES

** TODO =className=

#+BEGIN_SRC javascript
  el.className;	// What does this print?
#+END_SRC

#+BEGIN_NOTES
TODO(nik): Talk about why this prints the empty string,
and not =null= or =undefined=.
#+END_NOTES

*** Setting =className=

- We have two classes we want to use
  - =warning=
  - =tip=

#+BEGIN_SRC javascript -n
el.className = 'warning';
el.className;
// Check element tab!
el.className = 'tip';
el.className;
// Check element tab!
#+END_SRC

#+BEGIN_NOTES
TODO(nik): Have them do this.

Ask them why the style doesn't change.
#+END_NOTES

** TODO JS: Problem 1: We're going to...

1. Write a function...
  - ?
2. ... that finds the paragraph element...
  - =document.getElementById('...');=
3. ... and changes its class
  - Change the =className= property

#+BEGIN_NOTES
Here's our problem again, and I've filled in the information
we've learned so far.

It's time to learn how to write Javascript functions.
#+END_NOTES

* TODO Introduction to functions

- Functions provide *encapsulation*
- A function is a:
  - Collection of Javascript statements
  - With a name
  - And optional parameters
  - That you can *call* from other code
- =alert('Some message');=

#+BEGIN_NOTES
One of the things we do when we're programming is try and manage
complexity, and one of the ways that we do that is by hiding things
behind names.

We call this *encapsulation*.

A function lets us take some functionality in our code, give it a
dedicated name, and then *call* the function from other parts of
the code.

We say that functions take *parameters* which can control what it
does.

You've already used one function, =alert()=. And you've used object
methods, like =getElementById()=, which are very similar.
#+END_NOTES

* Including Javascript in the HTML

#+BEGIN_SRC html
  <html>
    ...
    <body>
      ...
      <script>
        // Javascript code goes here
      </script>
    </body>
  </html>
#+END_SRC

#+BEGIN_NOTES
So far all of your Javascript code has been entered in to the REPL.
It's time to change that.

To add Javascript code to an HTML page we're going to use the =script=
element.

The contents of this element should be Javascript code, just as you
entered it in to the REPL.

At the moment the right place to put the =script= element is
immediately before the =body= finishes. So just before the closing
=</body>= tag.

This is also weird -- we're really mixing and matching HTML and
Javascript code now. I know this can be a bit confusing, and we're
going to change it later to make it easier, but for now we have to
do it this way.

Edit the HTML file and add a =script= element immediately before the
end of the body.
#+END_NOTES

* How do we know if our code is working?

#+BEGIN_SRC javascript
console.log('some message');
#+END_SRC

#+BEGIN_NOTES
Javascript code can send messages to the console. This very useful
when writing code, as you can send messages containing the values of
variables, or indicating that the program got to a particular place.

To do that, we write =console.log()= add the message we want to send,
just like this.
#+END_NOTES

** Exercise: Log a message to the console                          :exercise:

#+BEGIN_SRC html
<script>
  console.log('My code is running!');
</script>
#+END_SRC

#+BEGIN_NOTES
Modify the HTML file, and add this call to =console.log= inside
the =script= element.

Save the file.

Make sure the developer tools are open, and you can see the console.

Reload the page.

If everything worked you should see the message show up in the
console.

[Wait]
#+END_NOTES

** Exercise: Calling functions from the console                    :exercise:

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_CENTER
In the HTML
#+END_CENTER
#+BEGIN_SRC html
<script>
  console.log('My code is running');

  function greet(name) {
    console.log('Hello, ' + name);
  }
</script>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_CENTER
In the console
#+END_CENTER

#+BEGIN_SRC javascript
greet('Your name here');
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
From the console you can call functions that are defined in your
Javascript file.

To demonstrate this, edit the HTML so that the =script= element
contains a new function called =greet=, that looks like the one
here.

Save and reload the page.

Open the console.

In the console, make sure you see the "My code is running!" message,
and then call the function, as shown on the right.

[Wait]
#+END_NOTES

* Exercise: A function that changes the class                      :exercise:

#+BEGIN_SRC javascript
setClassTip();   // <-- goal (in the console)
#+END_SRC

#+BEGIN_SRC javascript
let setClassTip = function() {
  // You write the function in the <script> element

  // 1. Get the <p id="mypara"> element in to a variable.

  // 2. Change the element's className property
  //    to 'tip'.
}
#+END_SRC

#+BEGIN_NOTES
We now know everything we need to write a function that changes the class
of the paragraph in our page.

Here, I've provided the outline of a function that will set the element's
class name to 'tip'.

I want you to use the information that we learned earlier, and
complete this function in the HTML =script= element.

When it's working, you should be able to save and reload the page,
and call =setClassTip()= in the console.
#+END_NOTES

** Solution: A function that changes the class

#+BEGIN_SRC javascript
let setClassTip = function() {
  let el = document.getElementById('mypara');
  el.className = 'tip';
}
#+END_SRC

#+BEGIN_NOTES
Did everyone do OK with this?

What problems did you have? Let's talk through them with the class.

[Wait]
#+END_NOTES

* TODO JS: Problem 1: We're going to...

1. Write a function...
  - Done
2. ... that finds the paragraph element...
  - =document.getElementById('...');=
3. ... and changes its class
  - Change the =className= property
4. Call the function when the listitem is clicked
  - ?

#+BEGIN_NOTES
Back to the problem again, and we've made a lot of progress, and
almost solved it.

The last thing we need to figure out is how do we call our functions
when the user clicks on one of those listitems?
#+END_NOTES

* TODO DOM Events

- General term for "An interesting thing has happened"
- Let's you say
  - When this thing happens...
  - ... call my function =foo()=

#+BEGIN_NOTES
So far when you've been writing code you've also been the person that's
causing the code to be called.

For example, those =setClass...= functions are called by you typing the
function name in to the REPL and pressing RETURN.

It happens when *you* want it to.

DOM events provided a way for you to say "Call this function when this
event happens".

In this way you're no longer in control of exactly when your code is
called. Or even the order in which it is called. This is that *flow
of control* thing that I mentioned earlier coming up again.
#+END_NOTES

** Sample events - [[https://developer.mozilla.org/en-US/docs/Web/Events][MDN DOM Events]]

#+REVEAL_HTML: <div class="leftcol">
- =click=
- =mouseover=
- =load=
- =online=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="leftcol">
- =keyup=
- =drop=
- =scroll=
- =resize=
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Searching for =MDN DOM Events= will show you the MDN page with details
of all the events that can be triggered. I've put some examples here
just to give you some idea of what's possible.

=click= fires when ever the user clicks on something.

=mouseover= fires when the user moves the mouse over an element.

=load= fires when the webpage has completely finished loading.

=online= fires when the browser goes online. For example, if your
computer was disconnected from the network, and then you turn WiFi on
and it reconnects.

=keyup= fires when the user releases a key if they've been typing
something.

=drop= fires if the user has dragged something on to the page, and
then released the mouse button, "dropping" it on to the page.

=scroll= fires whenever the user scrolls the page.

=resize= fires whenever the browser window is resized.

We want to change the class associated with the paragraph whenver the
user clicks, so we want to use the =click= event.
#+END_NOTES

** Event terminology

- An event is *triggered* or *fires*
- A function called for an event *listens for, and handles the event*
- These functions are called *event listeners* (or *event handlers*)

** Listening for click events with attributes

- The =onclick= attribute is to specify the event listener

#+BEGIN_SRC javascript
function listenForClick(event) {
  // Do something
}
#+END_SRC

#+BEGIN_SRC html
<p onclick="listenForClick(event);">Some text</p>
#+END_SRC

#+BEGIN_NOTES
Here's our Javascript function that is going to listen for the event.

All event listeners take at least one parammeter, and the first
parameter is *always* an object that contains more details about
the event, and depends on the type of event that fired.

This is a completely normal function declaration -- it's got a
name, the =event= parameter, and the function body. There is
nothing special about this function at all. In particular,
the function name *does not* need to be =handle...=, or contain
the word =click=, or anything like that. It's just a useful
convention to follow.

To tell the browser that this event listener should be called when
the user clicks on the element we use the element's =onclick=
attribute.

We haven't seen this yet, but it's just like the other HTML
attributes we saw last week -- a name, an equals sign, and then
the attribute value in double quotes.

The only difference is that the attribute's value is some more
Javascript code.

This is a bit weird -- we're mixing HTML and Javascript together
inside a single element.
#+END_NOTES

* Exercise: Putting it all together                                :exercise:

- Write two more Javascript functions to change the paragraph's class
  - As event listeners they'll need an =event= parameter
  - =setClassWarning=
  - =clearClass=
- Add =onclick= attributes to the three =li= elements to call
  those functions
- Save the files and test

#+BEGIN_NOTES

#+END_NOTES

** Solution: Putting it all together (HTML)

#+INCLUDE: "samples/change_para_class/solution-1.html" :lines "11-16" src html

** Solution: Putting it all together (Javascript)

#+INCLUDE: "samples/change_para_class/solution-1.html" :lines "21-39" src javascript

** Add and commit!

* Just for fun: =mousemove=

- =click= is one of many events that can fire
- =mousemove= is another
- Change one or more =onclick= to =onmousemove=
- See what happens

#+BEGIN_NOTES
=click= is one of the events that can fire, but we've seen that there are
many others.

One of them is called =mousemove=, with an =onmousemove= attribute.

Just for fun, see what happens if you change one or more of the
=onclick= attributes to =onmousemove=.
#+END_NOTES

* Revert the change

#+BEGIN_SRC shell
% git checkout -- index.html
#+END_SRC


* TODO Refactoring

- Rare to design a program correctly on first go
- Requirements can change
- Knowledge can change
- Rewriting code to improve it is *refactoring*

#+BEGIN_NOTES

#+END_NOTES

* TODO What's wrong with our code?

 - Inline Javascript
 - Repeated code
 - Event binding with =onclick=

#+BEGIN_NOTES
There's a few things I don't like with our code at the moment.

First, the Javascript is inline -- this means it's in the same file
as the HTML.

This isn't a big problem with something as small as this, but it's
still confusing -- we're mixing and matching two completely different
languages in one file.

Best practice is to -- where possible -- split Javascript out in to
its own files. That way all the Javascript code is in one place, and
the HTML is separate.

We've already done this with the CSS, and for exactly the same reason.

Second, if you look at the three functions they are very similar. They only
thing that changes is the string they use for the CSS class.

When you have a few functions that do very similar things you should
consider if they can be replaced with one function that takes a parameter
that controls its behaviour.

This is *not* always the right thing to do. It's a value judgement, and
sometimes having several similar-but-different functions is the right
thing to do. In this case, I'm happy with the idea that we can convert
these three functions in to one function.

Finally, we bind our event listener to the event using the =onclick=
attribute. This is OK, but there is another way to do it, which I want
to show you. For code as simple as this it's really not necessary, but
it is a good way to show the technique.
#+END_NOTES

* TODO Refactoring: Inline Javascript

- Place the Javascript in a separate file

#+BEGIN_SRC html
  ...
  <script src="setClass.js"></script>
</body>
#+END_SRC

#+BEGIN_NOTES
To refactor the inline Javascript we have to put the contents in a
separate file, and then use the =script= element in the HTML
to load the file.
#+END_NOTES

** TODO External CSS in the =head=

#+BEGIN_SRC html
<head>
  ...
  <link rel="stylesheet" href="style.css" type="text/css">
  ...
</head>
#+END_SRC

#+BEGIN_NOTES
This is very similar to what you've already done with CSS.
#+END_NOTES

** TODO Refactoring inline Javascript, smaller steps

1. Create an empty file, =setClass.js=, and check.
2. Create the =script= element, and check.
3. Move the Javascript code to =setClass.js=, and check.
4. Commit the change.

#+BEGIN_NOTES
Earlier I said that we take the current Javascript, put it in a
new file, and then add a =script= element to reference the new
file.

We're actually going to take more steps to do this.

This is because we want to be safe. Refactoring can sometimes be
difficult, and you want to make sure that you don't accidentally
break code that's already working.

So the trick is to break the change down in to small, independent
steps that should each be safe. At each stage you test the change
and make sure that things still work.

If they don't work then it's very easy to go back and undo the
last small change you made, or review it to see what went wrong.
#+END_NOTES

** TODO Create =setClass.js=, and check

- File > New > JavaScript File
- Call it =setClass.js=

** TODO Create the =script= element, and check

#+BEGIN_SRC html
  ...
  <script>
    // Existing code here
  </script>
  <script src="setClass.js"></script>
</body>
#+END_SRC

** TODO Move the Javascript code to =setClass.js=, and check

#+INCLUDE: "samples/change_para_class/set-class-1.js" src javascript

** TODO Delete the old =script= elements

#+INCLUDE: "samples/change_para_class/refactor-1.html" src html

** TODO Recap

- Created a new file
- Referenced it with ~<script src=...>~
- Moved the code over
- Deleted code from the old location
- Checked at each step

#+BEGIN_NOTES

#+END_NOTES
* TODO Refactoring: Repeated code

#+INCLUDE: "samples/change_para_class/set-class-1.js" src javascript

#+BEGIN_NOTES
If we look at this code we see that these three functions are
almost identical. The only thing that changes is the name of
the class that we set.
#+END_NOTES

** Exercise: Take the class name as a parameter

#+BEGIN_SRC javascript
  setClass(event, 'tip');    // <-- goal
#+END_SRC

#+BEGIN_SRC javascript
function setClass(event, /* ... */) {
  // You write the function body.

  // Add a named parameter for the class name.

  // Use the named parameter as the new class name.
}
#+END_SRC

#+BEGIN_NOTES
So we could replace these three with one function that will take
two parameters.

That's what I'd like you to do.  Write a new function, called
=setClass=. The first parameter is the event, the second is a string
that will be the name of the class to use.

Do *not* replace the existing functions.

Write the function in the =setClass.js= file.

Here's the outline of function, you need to fill in the missing
pieces.
#+END_NOTES

** Solution: Take the class name as a parameter

#+INCLUDE: "samples/change_para_class/set-class-2-1.js" :lines "16-20" src javascript

#+BEGIN_NOTES
Did everyone do OK with this?

What problems did you have? Let's talk through them with the class.

When you've done this there still shouldn't be any change to how the
page works. You've written the new function, but you haven't used it
anywhere yet.
#+END_NOTES

** Replace one function call with a call to =setClass=

#+INCLUDE: "samples/change_para_class/refactor-2-1.html" :lines "11-16" src html

#+BEGIN_NOTES
To use the function we replace the code in the =onclick= attribute that calls
=setClassWarning= with code that calls the new =setClass= function.

Go ahead and make this change to your code, and reload the page.

If you've done everything correctly so far then everything should still work.

Double check that.
#+END_NOTES

** TODO Exercise: Replace all function calls

** TODO Solution: Replace all function calls

#+INCLUDE: "samples/change_para_class/refactor-2-2.html" :lines "11-16" src html

#+BEGIN_NOTES
Check it still works.
#+END_NOTES

** TODO Delete the obsolete functions

#+INCLUDE: "samples/change_para_class/set-class-2-2.js" src javascript

#+BEGIN_NOTES
Now that you've verified that the new code works correctly you can delete the
obsolete functions. When you're done =setClass.js= should only contain one
function, and it should look like this.

Verify, and then commit your changes.
#+END_NOTES

** TODO Recap

- Identified duplicated code
- Wrote a generic function with an extra parameter
- Verified new function worked
- Replaced calls to old function with calls to new function
- Deleted old code
- 14 lines -> 4 lines

#+BEGIN_NOTES
Fewew lines of code means fewer bugs.
#+END_NOTES

* TODO IDEs                                                        :noexport:
** TODO Some web development problems

- Too many files
- Easy to make mistakes
- "tightly coupled" content

#+BEGIN_NOTES
I want to talk about some of the problems you may already have
encountered that makes this stuff difficult.

As you're probably beginning to realise, there are a lot of files
needed for web development. Each page is its own file, and then there
are the CSS files as well.

And we're going to be introducing more files later in the course.
Pretty soon it becomes difficult to keep track of them all.

The syntax of the files can be complicated -- keeping track of which
HTML element needs to be closed, or forgetting to close a double
quote, or mis-spelling a CSS property name can all cause issues that
can be difficult to track down.

And the information in these files is what we call "tightly coupled".
This means that when you, for example, change the class name in a CSS
file you have to change it everywhere it's used in the HTML files as
well. If you miss just one instance your web page is going to look
strange, and might be broken.

If you imagine a site with 100s of pages you can see how this would
very quickly become difficult to work with.
#+END_NOTES

** TODO Integrated Development Environments (IDE)

#+BEGIN_NOTES
TODO(nik): Move some of this material to when Atom is introduced

[Check: Has everyone here used a word processor before?]

Forget about web development for a moment, and think about writing
documents.

They have their own set of problems -- am I using the fonts and
headings consistently? Do the footnotes have the correct numbers?  Is
the table of contents correct? That sort of thing.

To solve those problems for writing documents we invented word
processors, which provide features to take care of all of that for
you, so you can focus on writing the text of the document.

We did similar things for programming -- we invented special tools
specifically to try and make programming easier, and to help us when
we write code so that it's more difficult to make mistakes.

We call these programs *Integrated Development Environments*, or
*IDEs*.

There are lots of different IDEs available, with different
functionality. At the simpler end are programs like Notepad++ on
Windows, which helps show you the HTML structure and uses colours to
help you distinguish between HTML elements, content, and attributes.

Atom, which we've been using so far, has a few more features to
help out -- for example, the HTML linter that we've been using to
catch simple mistakes. This is somewhere in the middle of the
spectrum.

At the other end are more complicated IDEs like Visual Studio and
*Web Storm*. These are very powerful, but are more complicated to
learn.

However, once you get used to the features they can make web
development a lot easier, and speed up a lot of things.

#+END_NOTES

** TODO WebStorm: Installation

- Live exercise

#+BEGIN_NOTES
Going to be using an IDE called WebStorm.

TODO(nik): Installation
#+END_NOTES

** TODO WebStorm: Initial setup

- Live exercise

#+BEGIN_NOTES
TODO(nik): Cover

- Opening the first time
- Setting project options
  - 2 spaces not 4
  - Indentation for all block level elements
- Disable Language Injection feature (not necessary yet)
- Mark modified tabs with asterisks
#+END_NOTES

** TODO WebStorm: Opening a project

- Live exercise

#+BEGIN_NOTES
TODO(nik): Complete
#+END_NOTES

** TODO WebStorm: Initial tour

- Live exercise

#+BEGIN_NOTES
- Initial window layout (files, directories on left, contents on right)
- Tool windows, showing and hiding
- [MAYBE] View > Enter Distraction Free mode
- Editor help
  - HTML
    - Syntax colouring
    - Highlighting start and end tags
    - Automatic indentation
    - Reformatting code to match style (Code > Reformat code)
    - Collapsible sections (left hand margin, "code folding")
    - Syntax / validity checking (check mark at the top right)
    - Open file in a browser
    - Current 'path' through the document structure (bottom of the screen)
    - "Structure" tool window
    - TODOs
    - Autocompletion
    - Auto-closing tags
  - CSS
    - Common features
      - Syntax highlighting
      - Code reformatting
      - Validity checking
      - Current

- Creating new files
  - File > New, choose the type
  - Right-click on directory / file, choose the type


#+END_NOTES
** TODO WebStorm: Troubleshooting

- Live exercise

#+BEGIN_NOTES
- Delete a quote from a CSS class
- Delete closing bracket from opening tag
- Delete opening bracket from closing tag

#+END_NOTES

** TODO WebStorm: Debugging

- Breakpoints
- Starting the debugger
- Stepping through code
- Inspecting variables
- Flow of control
- Ending debug session

#+BEGIN_NOTES
Topics to hit are in the slide
#+END_NOTES


* TODO Refactoring: Event binding with =onclick=

#+BEGIN_SRC html
... onclick="nameOfFunction(event);" ...
#+END_SRC

- This is how we've been binding listeners to events
- Javascript code in an HTML attribute
- Introduces a dependency between HTML and Javascript

#+BEGIN_NOTES
So far this is how we've been binding our event listeners to particular
events.

This works.

But it does introduce a few problems.

The first is that we're mixing languages -- this is HTML, but the value
of the attribute should be Javascript code. That's just weird.
#+END_NOTES

** HTML and Javascript dependency

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC dot :file dependency-1.svg :cmdline -Tsvg -Gstylesheet=../graphviz.css
digraph G {
  graph [nodesep=2];
  html [label="HTML"];
  javascript [label="Javascript"];

  html -> javascript [xlabel="HTML knows Javascript\nfunction names"];

  javascript -> html [taillabel="        Javascript knows\nHTML IDs"];
}
#+END_SRC

#+RESULTS:
[[file:dependency-1.svg]]

#+REVEAL_HTML: </div>


#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file dependency-2.svg :cmdline -Tsvg -Gstylesheet=../graphviz.css
digraph G {
  graph [nodesep=2];
  html [label="HTML"];
  javascript [label="Javascript"];

  html -> javascript [style="invis"];
  javascript -> html [taillabel="        Javascript knows\nHTML IDs"];
}
#+END_SRC

#+RESULTS:
[[file:dependency-2.svg]]

#+REVEAL_HTML: </div>
#+BEGIN_NOTES
More importantly, our HTML needs to know the name of the functions to
call.  This introduces a *dependency* between the HTML and the
Javascript.

This the diagram here on the left -- both the HTML and the Javascript
need to know abouteach other.

If we ever change the name of the Javascript functions we'll need to
change the HTML as well.

In fact, we just had to do that as part of the refactoring. Remember
we had to change all of the =onclick= attribute values when we
refactored and decided to use a new function.

What's better, as much as possible, is if the HTML doesn't know
about the Javascript. This way we only have on dependency to think
about, as in the diagram on the right.

In an example as small as this one this dependency is easy to manage.
But as projects get bigger the increasing numbers of dependencies can
make it much more difficult to think about the program -- there are
more things that you need to keep in your head.

So we're going to change this.
#+END_NOTES

** Adding an Event Listener using =onclick=

#+BEGIN_SRC html
<p onclick="listenForClick(event);">Some text</p>
#+END_SRC

#+BEGIN_SRC javascript
function listenForClick(event) {
  // Do something
}
#+END_SRC

#+BEGIN_NOTES
Just as a reminder, this is what we've been doing so far.
#+END_NOTES

** Adding an Event Listener using =addEventListener()=

#+BEGIN_SRC html
<p id="mypara">Some text</p>
#+END_SRC

#+BEGIN_SRC javascript
function listenForClick(event) {
  // Do something
}

let el = document.getElementById("mypara");
el.addEventListener('click', listenForClick);
#+END_SRC

#+BEGIN_NOTES
This is the new way. We've made a number of changes here.

1. We've removed the =onclick= attribute from the =p= element. We
   don't need it any more.

   This means our HTML element no longer contains any Javascript
   code either.

2. We've added an =id= attribute to the =p= element. This is because
   we're going to need to find it in the DOM using Javascript.

3. Our event listener code (the =listenForClick= function) stays the
   same.

4. We find the =p= element using our old friend, =getElementById()=.

5. Once we've found it, we use its =addEventListener= method to say
   which event to listen for, and which event listener to call.

There's something subtle going on here that I want to draw
your attention to.

It's this usage of =listenForClick= on line 6, without any parentheses.
#+END_NOTES

** Solution...?

#+BEGIN_SRC html
  <ul>
    <li id="make-warning">Make it a warning</li>
    <li onclick="setClass(event, 'tip');">Make it a tip</li>
    <li onclick="setClass(event, '');">Make it normal</li>
  </ul>
#+END_SRC

#+BEGIN_SRC javascript
  function setClass(event, className) {
    let el = document.getElementById('mypara');
    el.className = className;
  }

  let makeWarning = document.getElementById('make-warning');
  makeWarning.addEventListener('click', setClass);
#+END_SRC

#+BEGIN_NOTES
So here's the beginning of a solution.

We've added =id= attributes to an =li= element so we can refer back
to it in the code.

On the first one we've removed the =onclick= attribute.

And in the Javascript code we've added two lines, the first finds the
=li= element, and the second adds a =click= event listener, using our
=setClass= function.

That looks OK, right?

[Wait]

It's not. Can anyone see the bug?

[Wait]

The problem is on this last line, where we use =setClass=.

When =setClass= is called it will be passed one parameter, the event.

But we changed that so it needs two parameters, where the second one is
the text of the new class.

Are we going to have to go back to having three different functions?

We could, but there's another way.
#+END_NOTES

** Solution

#+BEGIN_SRC javascript
  let makeWarning = document.getElementById('make-warning');
  makeWarning.addEventListener('click', setClass);
#+END_SRC

#+BEGIN_SRC javascript
  let makeWarning = document.getElementById('make-warning');
  makeWarning.addEventListener('click', function(event) {
    setClass(event, 'warning');
  });
#+END_SRC

- Create an anonymous function
- ... that calls =setClass=
- ... with the correct second parameter

#+BEGIN_NOTES
Try this, and reload the page in the browser, and then click the
green listitem.
#+END_NOTES

** Exercise: Add the other listeners

- Don't forget to remove the =onclick= attributes from the HTML

** Solution: Add the other listeners

#+BEGIN_SRC javascript
  function setClass(event, className) {
    let el = document.getElementById('mypara');
    el.className = className;
  }

  let makeWarning = document.getElementById('make-warning');
  makeWarning.addEventListener('click', function(event) {
    setClass(event, 'warning');
  });

  let makeTip = document.getElementById('make-tip');
  makeTip.addEventListener('click', function(event) {
    setClass(event, 'tip');
  });

  let makeNormal = document.getElementById('make-normal');
  makeNormal.addEventListener('click', function(event) {
    setClass(event, '');
  });
#+END_SRC

* Refactoring: Cleaning up =setClass()=

#+BEGIN_SRC javascript
  function setClass(event, className) {
    let el = document.getElementById('mypara');
    el.className = className;
  }
#+END_SRC

#+BEGIN_NOTES
Here's our code for =setClass= again. Can anyone suggest any way that
it could be simplified?

[Wait]
#+END_NOTES

** Removing the =event= parameter

#+INCLUDE: "samples/change_para_class/refactor-3-4.js" :lines "1-5" src javascript

#+INCLUDE: "samples/change_para_class/refactor-4-1.js" :lines "1-5" src javascript

#+INCLUDE: "samples/change_para_class/refactor-4-1.js" :lines "7-11" src javascript

#+BEGIN_NOTES
When we first wrote =setClass= (first box) it was an event listener.

This meant that its first parameter was always =event=, which contained
extra information about the event that fired.

With our refactoring it's no longer an event listener -- we have new
event listeners that call it.

Because of this the =event= parameter is no longer needed. We don't use
it anywhere in the *function body*, so we can remove it from the function.

Of course, we also need to change it everywhere we call it to no longer
pass in the parameter.

This is excellent practice to follow. If you don't do this then future
programmers might look at your code and scratch their heads wondering
why this unused paramater is being passed in to the function.

Make this change, check that everything still works, and then commit
the change.
#+END_NOTES

** Method and property chaining

#+INCLUDE: "samples/change_para_class/refactor-4-1.js" :lines "1-5" src javascript

#+BEGIN_NOTES
We can simplify this code even more using a technique called *method
chaining*.

Looking at this code, we create a variable, assign the return value of
=document.getElementById= to it, and then change the =className=
property of the elemnent.

Normally we use variables to make our code cleaner. Carefully choosing the
names of our variables can make the code easier to understand and communicate
what we intend to the next programmer to come along.

In this case though that's not really the case. We only use the =el= variable
once.

So instead of putting the return value from =getElementById= in its own
variable we can use the result directly.
#+END_NOTES

** Method and property chaining

#+INCLUDE: "samples/change_para_class/refactor-4-1.js" :lines "1-5" src javascript

#+INCLUDE: "samples/change_para_class/refactor-4-2.js" :lines "1-4" src javascript

#+BEGIN_NOTES
I realise that's not the easiest thing to understand, so here's what it
looks like.

At the top is our original function, and at the bottom is the function
re-written to use method and property chaining.

This kind of chaining is incredibly common in Javascript.

Is this clear to everyone?

[Wait]

Make this change and commit.
#+END_NOTES

** Method and property chaining

#+INCLUDE: "samples/change_para_class/refactor-4-2.js" :lines "5-18" src javascript

#+BEGIN_NOTES
And we can do the same thing when we're adding the event listeners.
The variables we create there aren't used either, we can remove
them and use chaining to make the code smaller.

Is this clear to everyone?

[Wait]

Make this change and commit.
#+END_NOTES

* TODO Refactoring: Reflection

#+REVEAL_HTML: <div class="leftcol">
- External Javascript
  - Keeps files smaller
  - Avoids mixing languages in a file
- Replaced similar functions with a single function
- Removed =onclick= attributes, =addEventListener=
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Other simplifications
  - Removed a parameter
  - Method / property chaining removed a variable
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
That's the refactoring complete at this point, so lets take a look back
at exactly what we did so you can appreciate what you've learned.

We moved the inline Javascript out in to its own file. This made the HTML
file a lot smaller, and meant that we weren't mixing different languages in
one file -- making things simpler and less likely to get mixed up.

We saw how we had three functions that were very similar, and replaced them
with one function -- =setClass= -- that took a parameter that it used to
make the change.

And we removed the =onclick= attributes entirely, replacing them with calls
to =addEventListener= to install our own event listeners.

With all of that done we discovered a couple of other simplifications
that allowed us to remove an unused paremter, and employed property
chaining to remove variables and simplify the code.

And we did this very iteratively -- it wasn't all in one go. At each step
we checked that the code still worked, so when we discovered that it
didn't (with the event listeners) it was easy to know exactly which
change was causing the problem.
#+END_NOTES

* TODO The DOM tree

- An HTML page is a tree of elements
- The DOM allows us to inspect and change the tree

#+BEGIN_NOTES
When we looked at files and directories last week, we noticed that they
formed a tree of things.

Does everyone remember that?

[Wait]

HTML pages are also trees.
#+END_NOTES

* TODO Tree refresher

#+REVEAL_HTML: <div class="leftcol">
- Tree is a hierarchy of *nodes*
- Each node has exactly one *parent*
  - Except the top, or *root* node
- Nodes with the same parent are *siblings*
- Node anywhere under another node is a *descendant node*
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file tree.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  A -> B;
  A -> C;
  C -> D;
}
#+END_SRC

#+RESULTS:
[[file:tree.svg]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Our tree forms a hierarchy of things, called nodes.

Each node in the tree has a parent node, except for the node at the top
of the tree, which we call the *root* node.

In this diagram on the right, A is the root node. It has two *children*, B and C.

We say that B and C are *siblings*, because they share the same *parent node*.

D is a child of C. D and C are *both* descendants of A.
#+END_NOTES

** TODO File and directories as trees

#+BEGIN_SRC dot :file tree-filesystem.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  //graph [splines="ortho"];
  node [shape="folder"];

  home [label="Home"]
  desktop [label="Desktop"];
  documents [label="My Documents"];
  tax [label="Tax"];
  photos [label="My Photos"];
  poco [label="Powercoders"];
  basel [label="Basel"];
  coursework [label="coursework"]
  week2 [label="week2"];
  day1 [label="day1.html" shape="note"];

  img8198 [label="IMG_8198.jpg" shape="note"];
  img8199 [label="IMG_8199.jpg" shape="note"];
  img8200 [label="IMG_8200.jpg" shape="note"];

  home -> desktop;
  home -> documents;
  documents -> tax;
  home -> photos;
  photos -> img8198;
  photos -> img8199;
  photos -> img8200;
  home -> poco;
  poco -> basel;
  basel -> coursework;
  coursework -> week2;
  week2 -> day1;
}
#+END_SRC

#+RESULTS:
[[file:tree-filesystem.svg]]

 #+BEGIN_NOTES
 And here's the filesystem as a tree.
 #+END_NOTES



** TODO HTML as a tree

#+NAME: html-as-a-tree-example
#+BEGIN_SRC html
<html>
  <head>
    <title>My first page</title>
  </head>
  <body>
    <h1>My first heading</h1>
    <p>My first paragraph</p>
  </body>
</html>
#+END_SRC

#+BEGIN_NOTES
So lets look at how we can think as HTML as a tree.

Here's a simple HTML document, with a few elements that are
nested in side one another.

To think of this as a tree, we take the =html= element and make
that the root node.
#+END_NOTES

** TODO =html= as root node

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<html-as-a-tree-example>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file html-tree1.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  html
}
#+END_SRC

#+RESULTS:
[[file:html-tree1.svg]]

#+REVEAL_HTML: </div>

** TODO =head= is a child of =html=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<html-as-a-tree-example>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file html-tree-2.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  html -> head
}
#+END_SRC

#+RESULTS:
[[file:html-tree-2.svg]]

#+REVEAL_HTML: </div>

** TODO =title= is a child of =head=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<html-as-a-tree-example>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file html-tree-3.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  html -> head
  head -> title
}
#+END_SRC

#+RESULTS:
[[file:html-tree-3.svg]]

#+REVEAL_HTML: </div>

** =title= content is a child of =title=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<html-as-a-tree-example>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file html-tree-4.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  html -> head
  head -> title
  title -> title_content
  title_content  [label="My first page" shape=none];
}
#+END_SRC

#+RESULTS:
[[file:html-tree-4.svg]]

#+REVEAL_HTML: </div>

** TODO =body= is a child of =html=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<html-as-a-tree-example>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file html-tree-5.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  html -> head
  head -> title
  title -> title_content
  title_content  [label="My first page" shape=none];

  html -> body;
}
#+END_SRC

#+RESULTS:
[[file:html-tree-5.svg]]

#+REVEAL_HTML: </div>

** TODO =h1=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<html-as-a-tree-example>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file html-tree-6.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  html -> head
  head -> title
  title -> title_content
  title_content  [label="My first page" shape=none];

  html -> body;
  body -> h1;
}
#+END_SRC

#+RESULTS:
[[file:html-tree-6.svg]]

#+REVEAL_HTML: </div>

** TODO =h1= content

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<html-as-a-tree-example>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file html-tree-7.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  html -> head
  head -> title
  title -> title_content
  title_content  [label="My first page" shape=none];

  html -> body;
  body -> h1;
  h1 -> h1_content;
  h1_content [label="My first heading" shape=none];
}
#+END_SRC

#+RESULTS:
[[file:html-tree-7.svg]]

#+REVEAL_HTML: </div>

** TODO =p=

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<html-as-a-tree-example>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file html-tree-8.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  html -> head
  head -> title
  title -> title_content
  title_content  [label="My first page" shape=none];

  html -> body;
  body -> h1;
  h1 -> h1_content;
  h1_content [label="My first heading" shape=none];

  body -> p;
}
#+END_SRC

#+RESULTS:
[[file:html-tree-8.svg]]

#+REVEAL_HTML: </div>

** TODO =p= content

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html :noweb yes
<<html-as-a-tree-example>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file html-tree-9.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  html -> head
  head -> title
  title -> title_content
  title_content  [label="My first page" shape=none];

  html -> body;
  body -> h1;
  h1 -> h1_content;
  h1_content [label="My first heading" shape=none];

  body -> p;
  p -> p_content;
  p_content [label="My first paragraph" shape=none];
}
#+END_SRC

#+RESULTS:
[[file:html-tree-9.svg]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
This is a really, *really* important thing to understand.

There is *no* difference between thinking about your HTML page as a
collection of text ordered top-to-bottom in a file, and thinking
about as a collection of nodes organised in a tree.

The information, and the structure, is identical.

It's just the representation that's different.

It turns out that people are really good at dealing with information
laid out the way we have it in the file.

Computers are really good at dealing with information in trees.

You will need to develop the ability to mentally *flip* between
thinking about the HTML as it is in the file, and thinking about
the HTML as a tree.

This just takes some practice.
#+END_NOTES

** TODO Live DOM Viewer

- https://software.hixie.ch/utilities/js/live-dom-viewer/

** TODO Exercise: Draw the tree for a sample page

#+BEGIN_SRC html
<html>
  <head>
    <title>A test page</title>
  </head>
  <body>
    <h1>This is a test page</h1>
    <p>It has some content in a paragraph.</p>
    <img src="foo.png" alt="">
    <p>It has another para with <em>emphasised</em> text.</p>
    <ul>
      <li>And a list...</li>
      <li>... of items.</li>
    </ul>
  </body>
<html>
#+END_SRC

#+BEGIN_NOTES
We're going to test how well you understand this, because as I say,
it's really important. If you don't get this then a lot of the stuff
that's coming up isn't going to make any sense at all.

Here's an example page.

What I want you to do is take a sheet of paper and a pen and draw the
tree for this page. Each element is a node.

When you're done let me know. I'll collect them up and we'll check them.
Some of you will have made mistakes.

*That is absolutely fine.*

We're all going to learn from those mistakes.

OK?
#+END_NOTES

** Solution: Draw the tree for a sample page

#+BEGIN_SRC dot :file tree-sample.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
  digraph G {
    node [shape="hexagon"];

    html -> head;
    head -> title;
    title -> title_content;
    title_content [label="A test page" shape="none"];

    html -> body;
    body -> h1;
    h1 -> h1_content;
    h1_content [label="This is a test page" shape="none"];

    body -> p1;
    p1 [label="p"];
    p1 -> p1_content;
    p1_content [label="It has some content in a paragraph" shape="none"];

    body -> img;

    body -> p2;
    p2 [label="p"];
    p2 -> p2_content_1;
    p2_content_1 [label="It has another para with " shape="none"];
    p2 -> em;
    em -> em_content;
    em_content [label="emphasised" shape="none"];
    p2 -> p2_content_2;
    p2_content_2 [label="text." shape="none"];

    body -> ul;
    ul -> li1;
    li1 [label="li"];
    li1 -> li1_content;
    li1_content [label="And a list..." shape="none"];
    ul -> li2;
    li2 [label="li"];
    li2 -> li2_content;
    li2_content [label="... of items." shape="none"];
  }
#+END_SRC

#+RESULTS:
[[file:tree-sample.svg]]

** TODO Exercise: Draw the tree for your page

#+BEGIN_NOTES
You've all got webpages that you've been building, so I want you
to take one of those pages -- and please choose one that's more
complex than this example -- and draw the tree for that page.
#+END_NOTES



* TODO Changing the DOM tree with Javascript

- =document= provides a method to create new nodes
- =Element= provides methods to attach the nodes to the tree

#+BEGIN_NOTES

#+END_NOTES

** Adding a new paragraph

#+REVEAL_HTML: <div class="leftcol">
#+BEGIN_SRC html
...
<body>
  <h1>First heading</h1>
  <p>First para</p>
</body>
...
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC dot :file dom-add-para-1.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  body -> h1;
  h1 -> h1_content;
  h1_content [label="First heading" shape="none"];

  body -> p;
  p -> p1_content;
  p1_content [label="First para" shape="none"];
}
#+END_SRC
#+RESULTS:
[[file:dom-add-para-1.svg]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Suppose we have this partial HTML tree (I've omitted the =html= and =head=
nodes to make the diagram simpler, but you can pretend that they're still
there.

How do we go about adding a new paragraph to this page?
#+END_NOTES

** First, create a new =p= node.

#+BEGIN_SRC dot :file dom-add-para-2.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  body -> h1;
  h1 -> h1_content;
  h1_content [label="First heading" shape="none"];

  body -> p;
  p -> p1_content;
  p1_content [label="First para" shape="none"];

  p2 [label="p"];
}
#+END_SRC

#+RESULTS:
[[file:dom-add-para-2.svg]]

#+BEGIN_NOTES
First we have to create a completely new node.

When we do this the node isn't attached to anything else. It's just floating
off, as if it was in space.

You can see it here at the top right of the graph.
#+END_NOTES

** Then, give it some content

#+BEGIN_SRC dot :file dom-add-para-3.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  body -> h1;
  h1 -> h1_content;
  h1_content [label="First heading" shape="none"];

  body -> p;
  p -> p1_content;
  p1_content [label="First para" shape="none"];

  p2 [label="p"];
  p2 -> p2_content;
  p2_content [label="Second para" shape="none"];
}
#+END_SRC

#+RESULTS:
[[file:dom-add-para-3.svg]]

#+BEGIN_NOTES
Now our shiny new node exists we can give it some content. Because this is a
=p= node we can attach a text content node to it.

Now we have to attach it to =body= node. Until we do this our new paragraph
won't appear in the DOM.

The body already has two elements associated with it. In order, left to right
they are the =h1= and the =p=.

When we say that we want to add our new node to the end of this list we
say that we are *appending* it to the list of child nodes of the =body=.
#+END_NOTES

** Append it to the body

#+BEGIN_SRC dot :file dom-add-para-4.svg :cmdline -Tsvg -Gstylesheet=../../../graphviz.css
digraph G {
  node [shape="hexagon"];
  body -> h1;
  h1 -> h1_content;
  h1_content [label="First heading" shape="none"];

  body -> p;
  p -> p1_content;
  p1_content [label="First para" shape="none"];

  body -> p2;
  p2 [label="p"];
  p2 -> p2_content;
  p2_content [label="Second para" shape="none"];
}
#+END_SRC

#+RESULTS:
[[file:dom-add-para-4.svg]]

#+BEGIN_NOTES
And after appending the node to the =body='s list of children we end up with
a tree that looks like this.
#+END_NOTES

** The equivalent HTML
#+REVEAL_HTML: <div class="leftcol">
[[file:dom-add-para-4.svg]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+BEGIN_SRC html
<body>
  <h1>First heading</h1>
  <p>First para</p>
  <p>Second para</p>
</body>
#+END_SRC
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
And if we -- in our heads -- convert this tree back to the HTML text
representation that we're familar with then we get this result.
#+END_NOTES

** HTML

#+INCLUDE: "samples/dom-append.html" src html

#+BEGIN_NOTES
Here's the HTML we're going to use.
#+END_NOTES

** The steps

1. Create a =p= node
2. Give it content
3. Find the =body= element
4. Append the new node to the list of the =body='s children

** Create a =p= node

#+BEGIN_SRC javascript
let elP = document.createElement('p');
#+END_SRC

[[file:dom-add-para-2.svg]]

#+BEGIN_NOTES
We've already seen the =document= variable, but we haven't used the
=createElement= method that it provides yet.

This method takes one parameter -- the tag name of the element to
create. Since we want to create a new paragraph we pass the string =p=
as the single parameter here.

We save the result in a variable, as we're going to need it in a
moment.
#+END_NOTES

** Give it content

#+BEGIN_SRC javascript
let content = document.createTextNode('Second para');
elP.appendChild(content)
#+END_SRC

[[file:dom-add-para-3.svg]]

#+BEGIN_NOTES
With our paragraph created we can go and give it some content. The text
in the paragraph is not an element, it's a text node.

Again, the =document= variable has a method that we can use to do this,
called =createTextNode=. The single argument here is the text that should
be used as the content for the node.

To add the text node as a child of the =p= element node we use the new
=appendChild= method. This has to be called as a method on the element
we want to add it to, which is why we use =p= element here (saved in the
=elP= variable.
#+END_NOTES

** Find the =body= element

#+BEGIN_SRC javascript
let elBody = document.getElementById('body');
#+END_SRC

[[file:dom-add-para-3.svg]]

#+BEGIN_NOTES
We're going to add our new =p= element to the body, and in order to do
that we have to find it.

This is the =getElementById= method that we've already been using a lot.
There's nothing special about this.
#+END_NOTES

** Append the new node to the list of =body='s children

#+BEGIN_SRC javascript
elBody.appendChild(elP);
#+END_SRC

[[file:dom-add-para-4.svg]]


* Exercises: Changing the DOM tree

** Adding a paragraph

- Create an HTML page with a paragraph of text
- Clicking the text should add a new a paragraph to the bottom
  of the page

** Adding lists

- Change the previous page
- Add a new paragraph, that, if clicked, adds a list with three
  listitems to the bottom of the page.
  - The second listitem should contain emphasised and non-emphasised text


* Race conditions (async)                                          :noexport:

#+BEGIN_NOTES
Content is only relevant after =async= on =script= is introduced.

#+END_NOTES
** TODO There's an ordering problem / race condition

- Browser loads HTML page
- Starts reading it line by line
- Gets to the =script=
  - Loads the Javascript
  - Starts running it
- Reads the =body=

#+BEGIN_NOTES
There's a problem here that we may or may not see, depending
on how lucky we are.

It's do with how the browser loads the page.

Very roughly, the browser loads the HTML page in one go, and
then starts reading it line by line in order to figure out
what to do.

It will reach the =script= element in the HTML =head=, and will
go off and start loading the Javascript.

At the same time it continues processing the rest of the HTML.

Now, one of two things will happen.
#+END_NOTES

** Possible futures

#+REVEAL_HTML: <div class="leftcol">
- Browser reads all the HTML
  - Creates the =li= elements
- Browser runs the Javascript
  - =getElementById(...)= works
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Browser runs the Javascript
  - =getElementById(...)= fails!
- Browser reads all the HTML
  - Creates the =li= elements
#+REVEAL_HTML: </div>

#+BEGIN_SRC javascript
let liGreen = document.getElementById('li-green');
#+END_SRC

#+BEGIN_NOTES
If the left hand side happens then everything is OK.

If the right hand side happens then we have a problem.

This is because the Javascript will be run *before* the browser has
create the =li= element with the =li-green= ID.

And if that happens, the call to =getElementById= will fail (and
return null), because the =li= element doesn't exist yet.

We call this a *race condition* -- we say that there is a race between
the browser finishing the HTML or finishing the Javascript. Depending
on which one wins the race either things work or they don't.

These sorts of problems can be very difficult to track down.

In order to fix this we need some way to make sure that our code
that accesses the DOM only runs when the browser has finished loading
the HTML page.

#+END_NOTES

* TODO Deeper look at variables                                    :noexport:

TODO(nik): Find the right place to put this.


* TODO Programming as communiction to other people                 :noexport:

* TODO =classList= in the REPL                                     :noexport:

TODO(nik): Maybe move this later, it's more advanced.

- Reload =getelementbyid.html=
- Open the console

#+BEGIN_SRC javascript
let el = document.getElementById('myheading');
let cl = el.classList;
#+END_SRC

#+BEGIN_NOTES
Let's experiment with =classList=. We can do this directly in the
REPL, and then inspect the output in the *Elements* tab.

Get back to a known state by closing the tab (if you haven't
already), reloading the page, opening the console, and typing
the following.

Line 1 we've done before -- we create a variable called =el=
and set its value to the element that has the ID =myheading=.

Line 2 is new, but very similar -- we create a variable called
=cl= and sets its value to the =classList= property.
#+END_NOTES

*** Adding a class with =add()=

#+BEGIN_QUOTE
=element.classList= itself is read-only, although you can modify
it using the =add()= and =remove()= methods.
#+END_QUOTE

**** Adding a class with =add()= 2/4

#+BEGIN_QUOTE
*add(String[, String [,...]])*
  Add specified class values.If these classes already exist in
  attribute of the element, then they are ignored.
#+END_QUOTE

**** Adding a class with =add()= 3/4

#+BEGIN_QUOTE
#+BEGIN_SRC javascript -n
div.classList.add('anotherClass');
#+END_SRC
#+END_QUOTE

**** Adding a class with =add()= 4/4

#+BEGIN_SRC javascript
cl.add('myclass');
#+END_SRC

#+BEGIN_NOTES
Finally, lets actually use Javascript to add a class to the
element that we've found.

=cl= is our variable that contains the class list, and we've
seen from the documentatin that we can call the =add()= method
to add a new class.

So lets do that. Type this in to the console, then go and
look at the element view and verify that the new class shows
up on the element.

[Demo]
#+END_NOTES

*** Replacing a class with =replace()=

#+BEGIN_QUOTE
*replace(oldClass, newClass)*
  Replaces an existing class with a new class
#+END_QUOTE

#+BEGIN_NOTES
Did you happen to notice this in the documentation?

There is another method called =replace()=. If you use it
it takes two arguments, and replaces the existing class on
the element with a new class.
#+END_NOTES

**** Replacing a class with =replace()=

#+BEGIN_SRC javascript
cl.replace('myclass', 'newClass');
#+END_SRC

#+BEGIN_NOTES
We can try this in the REPL too.

Before you type and run this, I want you to think about what
you expect the result to be.

Then run it.

Then go and check that the result is what you expected.

[Wait and demo]
#+END_NOTES


* TODO The language and the environments                           :noexport:

#+BEGIN_NOTES
Slide to talk about the difference between Javascript the language,
and Javascript the browser environment. Up until this point we
haven't been making the distinction.
#+END_NOTES
