#+TITLE: Powercoders Prep, Week 2
#+SETUPFILE: "../../include/settings.org"
#+PROPERTY: header-args:html-chrome :flags --window-size=320,240 --force-device-scale-factor=2 :cache yes

* Goal for this week

- Become comfortable with HTML
- Making mistakes and fixing them
- Reading documentation

* Common mistakes

- Not enough / too much space
- Using the wrong quotes, ='= vs ="=
- Using the wrong case
- Mis-spellings
- Number =1= vs. lowercase letter =l=

#+BEGIN_NOTES
Progamming is a precision activity. Sometimes using an upper case letter instead of a lower case letter can cause something to not work.

Or having the wrong amount of spaces.

Or spelling things wrong. Or using the wrong quotes.

When I was hosting the interviews, the #1 problem I saw people make was not following the examples / instructions precisely.

This is a skill that you will need to learn.
#+END_NOTES

* Finding mistakes

- You don't see what you typed
- You see what you *meant* to type
- Compare the example, with what you typed, character by character

#+begin_notes
You will definitely make mistakes in this course when copying information out. This is normal.

It can be difficult to spot these mistakes because you will look at the screen and instead of seeing what you actually typed you will see what you meant to type -- your brain will see the whole line and think "Yes, that looks good" and it won't see the glaring error you've made.

The *only* way to combat this is that when things don't work, compare what you've written with what you were supposed to write character by character.

If necessary put one finger up on the screen and very slowly compare exactly what you typed with what you were supposed to type, saying each character out loud as you do so. This will help you spot the problems.
#+end_notes

* Teaching

#+BEGIN_QUOTE
"All teaching is the process of lying, and then replacing the lies
 with successively better approximations of the truth."
#+END_QUOTE

#+begin_notes
We're going to be starting simply. That means that some of the things you will learn at first will turn out to be wrong later. That's fine, this is quite complex material, and it would be very difficult to try and understand the complexity from the very beginning.
#+end_notes

* Files and directories

- Information is stored in files.
- Files have names and extensions
- Extensions are a convention that indicate the file's contents
- E.g., the filename =index.html=
  - =index= is the "basename"
  - Then a dot
  - =html= is the extension

#+BEGIN_NOTES
Everything you do as a web developer is going to involve working with files, so it's important that you have a good mental model of how they work.

A file is a collection of information. That information might be the text of a web page, or the data that makes up an image, or an audio file, or the data that make up anything else.

Each file has a filename. We say that the filename is made up of three parts, which are:

- The basename
- A full-stop character. We tend to call this 'dot'.
- Generally 1-4 characters after the dot, called the 'extension'

Conventionally, the extension is used to describe the type of data that is in the file. For example:

- .txt  -- text files
- .html -- HTML files (more on these later)
- .png  -- Portable Network Graphics (a type of image)
- .css  -- Cascading Style Sheet (also more later)
- .js   -- Javascript (much more, later)

However, this is just a convention, and it's possible for a file's extension
to *not* match its actual contents. This can cause problems, so we'll look
at that later.
#+END_NOTES

** Show extensions on Windows

#+REVEAL_HTML: <div class="leftcol">
- \faWin + =extension= -> "Show or hide file extensions"
- Find "Hide extensions for known file types"
- Make sure it is *not* selected
#+REVEAL_HTML: </div>

[[file:windows-hide-extensions.png]]

#+BEGIN_NOTES
For those of you with Windows computers we need to make a small change.

Trying to be helpful, Windows has a default configuration option that means
it won't show you a file's extension. This is incredibly unhelpful when
you're a frontend developer, so we need to turn that off now.

If you're using Windows 10 try these instructions.

Anyone not using Windows 10, let me know.
 #+END_NOTES

** Directories

 - Files are stored in directories (folders)
 - Like boxes. You can put a file in a box.
 - You can also put a box in a box.
 - This gives us a "nested" structure

 #+BEGIN_NOTES
 Files are placed in collections -- the modern name for these
 collections is a "folder". However, the earlier name was
 "directory". That name is in the name of lots of commands that we'll
 use, and is still very widespread, so that's the name we'll use.

 You can think of a directory as being like a box that you can put
 files in to. You can also put a directory inside another directory --
 like putting a box inside a box.

 When we do this we say that one directory is *nested* inside the
 other.

 If you imagine that you're inside one of these boxes-as-directories,
 and climb out of it, you'll find yourself in another directory. If you
 keep doing this you'll eventually find that you can't climb out any
 more -- you've reached the *root* directory.

 The root directory has a special name, '/', or 'slash' (or forward
 slash).
 #+END_NOTES

** Paths

- Each file is in exactly one directory
- "path" is the route to the file through all the directories it is in,
  starting from the root.
- Possible paths
  - (Windows) =C:\Users\Nik Clayton\poco.txt=
  - (OS X) =/Users/nik/poco.txt=
  - (Windows) =c:/users/nik clayton/poco.txt=

#+BEGIN_NOTES
A file can only ever be in one directory at a time.

This means that we can uniquely identify a file by starting at the
root directory and then listing all the directories that we have to go
through to get to file.

We separate these directory names with a '/' slash character too.

Windows and OS X show you different slash characters for the separator,
but in Windows you can use either. For programming purposes the forward
slash is easier to use than the backward slash.

Windows also generally doesn't pay attention to the *case* of the path,
it treats upper and lower case the same. OS X does.

Windows also has *drive letters*, which are a holdover from about 30
years ago. If you're accessing a file on the same drive on Windows you
don't need to include the drive letter, but if it's on a different
drive then you do.

That generally won't be an issue in this class.
#+END_NOTES

** The directory tree (family tree)

#+BEGIN_SRC dot :cache yes :file family-tree.png :cmdline -Tpng -Gstylesheet=../graphviz.css
  graph G {
    graph [dpi=172 scale=2 bgcolor="#002b36"];
    node [style="filled" fontname="sans-serif" fontcolor="#9ee0e3" color="#eee8d5" fillcolor="#3f3f3f"];
    edge [color="#eee8d5"];
    subgraph ggp {
      rank = same;
      Walter;
      Alice;

      John;
      Beatrice;

      Arthur;
      Lillian;

      George;
      Lena;
    }

    subgraph gp {
      rank = same;
      JohnC [label=John]
      Barbara;

      Ralph;
      Maude;
    }

    subgraph p {
      rank = same;
      Steve;
      Liz;
    }

    Walter -- JohnC;
    Alice -- JohnC;

    John -- Barbara;
    Beatrice -- Barbara;

    Arthur -- Ralph;
    Lillian -- Ralph;

    George -- Maude;
    Lena -- Maude;

    JohnC -- Steve;
    Barbara -- Steve;

    Ralph -- Liz;
    Maude -- Liz;

    Steve -- Nik;
    Liz -- Nik;
  }
#+END_SRC

#+RESULTS[28ff7e5334e06f5fd040c8eba62c844e3dbdbf32]:
[[file:family-tree.png]]

 #+BEGIN_NOTES
 Another way of thinking about this directory structure is as what
 computer scientists call a "tree".

 This is a bit like a family tree. There are special English terms for
 people in the tree, including

 - parent
 - grandparent
 - sibling (like a brother or sister)

 #+END_NOTES

** The directory tree

#+BEGIN_SRC dot :cache yes :file tree-filesystem.png :cmdline -Tpng -Gstylesheet=../graphviz.css
digraph G {
  graph [dpi=148 scale=1 bgcolor="#002b36"];
  node [style="filled" fontname="sans-serif" fontcolor="#9ee0e3" color="#eee8d5" fillcolor="#3f3f3f"];
  edge [color="#eee8d5"];

  node [shape="folder"];

  root [label="/"];
  apps [label="Apps"];
  apps_dot [label="..."];

  program_files [label="Program Files"];
  program_files_dot [label="..."];

  users [label="Users"];
  home [label="Nik Clayton"]
  desktop [label="Desktop"];
  documents [label="My Documents"];
  tax [label="Tax"];
  photos [label="My Photos"];
  poco [label="Powercoders"];
  coursework [label="coursework"]
  week1 [label="week1"];
  day1 [label="day1.html" shape="note"];

  img8198 [label="IMG_8198.jpg" shape="note"];
  img8199 [label="IMG_8199.jpg" shape="note"];
  img8200 [label="IMG_8200.jpg" shape="note"];

  root -> apps;
  apps -> apps_dot;
  root -> program_files;
  program_files -> program_files_dot;
  root -> users;

  users -> home;
  home -> desktop;
  home -> documents;
  documents -> tax;
  home -> photos;
  photos -> img8198;
  photos -> img8199;
  photos -> img8200;
  home -> poco;
  poco -> coursework;
  coursework -> week1;
  week1 -> day1;
}
#+END_SRC

#+RESULTS[cd587466c574d5cf5193b0f0e91a715892bc8f85]:
[[file:tree-filesystem.png]]

 #+BEGIN_NOTES
This is a bit like that family tree, although it's been turned upside
down.

At the top of the tree is the root directory.

Below that we have various child directories. These might contain files, other directories, or both.

At the bottom right is a file, =day1.html=.

Search up in the diagram and find the =Powercoders= directory.

This is a:

- Child of the =Nik Clayton= directory
- Sibling of the =Desktop=, =My Documents=, and =My Photos= directories
- Parent of the =coursework= directory
- Grand-parent of the =week1= directory

Computer scientists love trees. You'll be seeing stuff like this a lot.
 #+END_NOTES


* Introduction to the web

- Web page
 - Text file with additional markup codes
- Web browser
  - Technical term: "user agent"
  - Processes the text and codes to display the page
- Web server
  - Receives requests for page at http://.../some/file/name
  - Responds with the page
    - Or an error code

#+BEGIN_NOTES
At its heart, a web page is a file that contains text and special codes
to specify how the text should be displayed.

This file is read by a web browser; like Chrome, or Firefox, or Safari.
The browser uses the information in the text and the special codes to
generate the final page that you can interact with.

A web server is special software that the browser talks to in order to
download a web page. We'll cover that in more detail a lot later.
#+END_NOTES

** Web pages are just text

- Open https://www.powercoders.org/
- Right-click on the page
- Choose "View source" from the menu that appears

#+BEGIN_NOTES
This is text for the Powercoders home page. There's a lot here that at
least some of you will never have seen before. But even then you can
start to make out some structure to the content.
#+END_NOTES

** Create a scratch directory

- Using the shell:
  - Go to your home directory
  - Create a directory called =poco=
  - Change in to the =poco= directory
  - Create a directory inside =poco= called =scratch=

#+BEGIN_NOTES
The =scratch= directory is where we are going to store HTML and other
files that are temporary, and you can use for experimentation. Later on
we'll create other directories for longer lived projects.

Try and do do all of this using the shell commands you learned last week.
#+END_NOTES

** Create a file in VSCode

- Start VSCode if it's not already running
- Close any open tabs
- =File= > =Open Folder...=
- Navigate to, and select, the =scratch= folder you just created
- =File= > =New File=
- Change the file type from =Plain Text= to =HTML=

#+begin_notes
We're going to create a file in VSCode the same way we did last week... with one change.

Before creating the file we tell VSCode to open the =scratch= folder.

This changes the VSCode interface and now shows an *Explorer* pane to the left of the file contents (and just to the right of the column of icons).

This is useful when you have several different files open, or want to create files in different directories, and we'll be doing that later.

If you want to close the *Explorer* pane you can do so by clicking the Files icon on the left (the one that looks like two sheets of paper). Clicking it again will re-open the pane.
#+end_notes

** Enter the following text

#+BEGIN_EXAMPLE
<p>This is an HTML paragraph.</p>
#+END_EXAMPLE

- Remember, let VSCode help you as you type

#+BEGIN_NOTES
Type this text, exactly as shown, in to VSCode.

Remember that VSCode will try and help you by inserting text and other things for you. Let it help you, and do this carefully, paying close attention.
#+END_NOTES

** Save it

- =File= > =Save=
- Save it as =index.html=

** Load it in to your browser

| Windows      | OS X      |
|--------------+-----------|
| =Ctrl= + =o= | =⌘= + =o= |

** Compare the result

#+REVEAL_HTML: <div class="leftcol">
#+NAME: first-html
#+BEGIN_SRC html-chrome
  <p>This is an HTML paragraph.</p>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS: first-html
[[file:first-html.png]]
#+REVEAL_HTML: </div>

* What have we just done?

- HTML (HyperText Markup Language)
- 1 element, =p=
- Start tag, content, end tag

#+BEGIN_SRC html :noweb yes
<<first-html>>
#+END_SRC

#+BEGIN_NOTES
You've just created and loaded an HTML file.

HTML is *not* a programming language, it's a markup language, and we use it to define the structure of the web page.

An HTML file consists of one or more elements, which you use to *mark up* different parts of the page to make it appear or behave in a particular way.  The type of element used determines whether it's a paragraph, or an image, or a link, or anything else that HTML supports.

An element has three main parts in the text.

It begins with the *start tag*. This is the name of the element surrounded by *angle brackets*, =<= and =>=. This says where the element starts.

It ends with the *end tag*. This is like the start tag, except that the name of the element is preceded by a *forward slash*.

In between the start tag and the end tag is the element's *content*. In this example that's the text of the element.

Together, the start tag, content, and end tag make up the element.

For the rest of this course examples are generally going to be shown like this. On the left hand side are line numbers, which you do not need to type in, they are so I can talk about particular lines on
the slide.

*Important*: The line numbers might not be the same as the ones you see in VSCode.

In the main area is the actual text.

And there's a little badge off to the right to make it clear which language we're using.

--

Based on [[https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started][MDN: Introduction to HTML]] by [[https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started$about][Mozilla Contributors]] which is
licensed under [[https://creativecommons.org/licenses/by-sa/2.5/][CC-BY-SA 2.5]].

#+END_NOTES

* TODO Nesting elements

#+NAME: nesting-elements
#+BEGIN_SRC html
<p>This is an <em>HTML</em> paragraph.</p>
#+END_SRC

- =em= element is *nested* inside the =p= element
- =em= means "emphasis", often shown as italics

#+BEGIN_NOTES
Elements can be placed inside other elements. We say that they *nest*
inside each other.

For example, we can use the =em= element to make some text in the
paragraph be emphasised.

Try that -- make the change to the file in VSCode, save it, and reload
the page in Chrome.
#+END_NOTES
** Nesting elements

#+REVEAL_HTML: <div class="leftcol">
#+NAME: nesting-elements-results
#+BEGIN_SRC html-chrome :noweb yes
<<nesting-elements>>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS: nesting-elements-results
[[file:nesting-elements-results.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Here's what you should see.

If you don't see this, go back and double check that what you typed matches what is on the slide.
#+END_NOTES

** Elements can not overlap

#+BEGIN_EXAMPLE
<p>This is a <em>bad example.</p></em>
#+END_EXAMPLE

#+BEGIN_NOTES
Elements *must* *not* overlap. You can not close an element unless all
the elements that it contains are closed first.

In this example -- which is *wrong* -- the =p= element has been closed before the =em= element. So the =em= overlaps the =p=.

If you get this wrong the browser will try and guess what you meant.
Sometimes you get lucky and everything looks OK, and sometimes you get
very strange results.
#+END_NOTES


* Keyboard shortcuts

| Action         | Windows       | Mac         |
|----------------+---------------+-------------|
| VSCode, save   | =Ctrl= + =s=  | =⌘= + =s=   |
| Switch apps    | =Alt= + =Tab= | =⌘= + =Tab= |
| Chrome, reload | =Ctrl= + =r=  | =⌘= + =r=   |

#+BEGIN_NOTES
It's a good idea to get used to some keyboard shortcuts. This will
speed up your working so you don't need to take your hands from
the keyboard to the mouse and back again so frequently.

To save a file in VSCode use =Ctrl= or =Command= and =s=.

Chrome will not automatically reload the file when it changes, so
you need to switch to it.

Pressing =Alt= or =Command= and =Tab= once will switch to the window
you last used. So if you went from Chrome to VSCode, pressing this will
take you back to Chrome, and vice-versa.

Once you're back in Chrome, =Ctrl= or =Command= and =r= will reload
the page, allowing you to see your changes.

So it's very common to type something in VSCode, save it with the keyboard shortcut, then switch to Chrome with the keyboard shortcut, reload the page, and check that it matches what you expected.
#+END_NOTES

* Block-level and inline elements

#+NAME: block-level-and-inline-elements
#+BEGIN_SRC html
<p><em>One</em> <em>two</em>
  <em>three</em></p>

<p>four</p> <p>five</p> <p>six</p>
#+END_SRC

#+BEGIN_NOTES
Broadly, we can put HTML elements in to two groups.

The first are called *block-level* elements. They form a new block on
the page -- there will be a blank line before and after each block
level element.

These tend to represent large-scale structure on the page, so things
like

- headings
- paragraphs
- lists
- menus

and so on.

The second are called *inline elements*. These are always contained
inside a block-level element and normally only surround a small part
of the content.

Examples include:

- emphasis
- links

Try this example, save, and reload (and try and use the keyboard shortcuts to do that). But before you do that, try and imagine what you think the result will be, and see if you get it right.
#+END_NOTES

*** Results

#+REVEAL_HTML: <div class="leftcol">
#+NAME: block-level-and-inline-elements-results
#+BEGIN_SRC html-chrome :noweb yes
<<block-level-and-inline-elements>>
#+END_SRC

- Is this what you expected?
- Notice how the break between line 1 and 2 doesn't appear on the web
  page
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS: block-level-and-inline-elements-results
[[file:block-level-and-inline-elements-results.png]]
#+REVEAL_HTML: </div>


* A more complicated example

#+NAME: a-more-complicated-example
#+BEGIN_SRC html -n
<!DOCTYPE html>
<html>
  <head>
    <title>My test page</title>
  </head>

  <body>
    <h1>This is a heading</h1>

    <p>This is a single paragraph.</p>
  </body>
</html>
#+END_SRC

#+BEGIN_NOTES
Here's a more complicated example that introduces some new elements
and best practices.

The first thing to notice is the indentation. HTML does not require
you to do this -- the browser will ignore it. However, as you can see
it makes the nested structure of the document very easy to see, to so
it is very good practice to get in to.

From now on, you should make sure that all of the HTML that you write
has correct indentation. I do that be indenting by two spaces for
each new block level element.

If you have configured VSCode correctly from last week then it will do this for you, and will correct the indentation every time you save the file. If you have not done this yet then go back to last week's VSCode instructions and complete that exercise. Then come back here.

Lets look at this line by line.

The first line specifies the *document type*. This looks a little bit
like an element, but it isn't. Back when HTML was first being
developed the idea was that there might be lots of different document
types, and this line would tell the browser what type it was and what
rules to follow. That never really worked out, and =html= is the only document type you need to worry about, so now you just need to include this line.

Note that the second character is an exclamation mark.

The second line is the opening tag for the =html= element. This element
should contain all the content on the page. You will also hear this
called the root element.

The =html= element should contain two child elements. The next line
introduces the first of these, =head=. This element is used to contain
various bits of additional information -- we call it *metadata* about
the page.

Here, the =head= contains a =title= element, with some text content.

Places you'll see the contents of the =title= used include:

- In the tab for the page in the browser
- The default name for the page's bookmark
- In a search engine result page

Moving down the page, we close the =head= element, and open a new
=body= element. The =body= should contain *all* the content that you
want to show to the user, whether that's text, images, videos, or
whatever else.

We start the body with an =h1= element. This is a *Level 1 heading*,
and we talk more about those later.

Then we have a =p= element, exactly as we have already seen.

Finaly, we need to close the open =body= and =html= elements.
It's important to do those in the right order.

Now replace the contents of your =scratch/index.html= page with this,
save, and reload.
#+END_NOTES

** Results

#+NAME: a-more-complicated-example-results
#+BEGIN_SRC html-chrome :noweb yes :exports results
<<a-more-complicated-example>>
#+END_SRC

#+RESULTS[57aad9bf348b7c3644a118d8ddbf7051051a7924]: a-more-complicated-example-results
[[file:a-more-complicated-example-results.png]]

* Exercise: Break it

1. Mis-spell =<h1>= as =<h>=
2. Mis-spell =</h1>= as =</h>=
3. Delete the =</p>=
4. Delete the blank spaces before the =<p>=

#+BEGIN_NOTES
It's common to occasionally make errors when typing in HTML, so I want
you to see what the effect of some of those errors is so that you can
recognise them in the future.

For each of the four exercises here make the change, save, and reload
the file. Write down what seems to be different, and then undo the
change so the file is correct, before moving on the next change.
#+END_NOTES

** Solution: Break it

#+REVEAL_HTML: <div class="leftcol">
1. Mis-spell =<h1>= as =<h>=

#+NAME: break-it-1
#+BEGIN_SRC html-chrome
<h>This is a heading</h1>

<p>This is a single paragraph</p>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS: break-it-1
[[file:break-it-1.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Because =h= is not a valid HTML element the browser didn't know what
to do with the text. So it plays it safe, and displays it like
regular text.

By the way, in these and future examples I'm going to leave out
the =html=, =head=, and =body= elements to make space on the slides.
You have to assume that they're there.
#+END_NOTES

** Solution: Break it

#+REVEAL_HTML: <div class="leftcol">
2. Mis-spell =</h1>= as =</h>=

#+NAME: break-it-2
#+BEGIN_SRC html-chrome
<h1>This is a heading</h>

<p>This is a single paragraph</p>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS: break-it-2
[[file:break-it-2.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
This time the closing tag is wrong, and doesn't close the opening
tag. The browser decided that the =h1= element stays open, and places
the =p= element *inside* the heading.

This is why the paragraph text looks the same as the heading.
#+END_NOTES

** Solution: Break it

#+REVEAL_HTML: <div class="leftcol">
3. Delete the =</p>=

#+NAME: break-it-3
#+BEGIN_SRC html-chrome
<h1>This is a heading</h1>

<p>This is a single paragraph
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS: break-it-3
[[file:break-it-3.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
In this case it doesn't look any different. We got lucky because
of where the breakage is. The browser knows that there can be
no more content after the closing =</body>= tag, so it acts as
though any tags that are still open at that point are closed.

Although the results look the same this is still bad HTML.
#+END_NOTES

** Solution: Break it

#+REVEAL_HTML: <div class="leftcol">
4. Delete the blank spaces before the =<p>=

#+NAME: break-it-4
#+BEGIN_SRC html-chrome
<html>
  <body>
    <h1>This is a heading</h1>

<p>This is a single paragraph</p>
  </body>
</html>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS: break-it-4
[[file:break-it-4.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Again, it doesn't look any different. This because this is not
bad HTML.

Browsers completely ignore any whitespace *outside* HTML elements.
We saw this earlier too with the *block* vs. *inline* display example.
#+END_NOTES

* Images

#+BEGIN_SRC html
<img src="name-of-file" alt="Image of ...">
#+END_SRC

#+BEGIN_NOTES
To add an image to a page we use the =img= element.

Remember earlier when I said that teaching is all about lying
to students? This is one of those times.

Earlier I said that all elements have a start tag, content, and an end
tag.

Some elements are what we call *empty elements*. They have no content,
and no end tag. So to write them you just use the start tag. And =img=
is one of those elements.

The =img= element also has *attributes*.

These are written inside the start tag as the name of the attribute,
then an equals sign, and then the value, enclosed in quotes.

*Important*: These should be together -- no spaces on either side of
equals sign.

Attributes allow us to specify extra information about the element.

Two of the attributes the =img= element supports are =src= and =alt=.

Use the =src= attribute to specify the filename of the image to load.

Use the =alt= attribute to specify some text that should be displayed or used if the
image can not be loaded or is not useful to the user. For example,
it's possible for blind or partially sighted people to get *screen
readers* that read the contents of the page to them. In this case
the contents of the =alt= attribute is read to the user. =alt= means *alternative*.
#+END_NOTES

** Download an image

1. Go to https://powercoders.org
2. Right-click the Powercoders logo at the top of the page
3. Choose =Save image as= in the menu
4. Save to your =scratch= directory
  - Should be called =powercoders-logo-CMYK.svg=

** Update your scratch file

#+NAME: example-with-image
#+BEGIN_SRC html -n
<!DOCTYPE html>
<html>
  <head>
    <title>My test page</title>
  </head>

  <body>
    <h1>This is a heading</h1>

    <p>This is a single paragraph.</p>

    <p><img src="powercoders-logo-CMYK.svg" alt="Powercoders"></p>
  </body>
</html>
#+END_SRC

#+BEGIN_NOTES
Add the =img= element inside a new =p= element,  below the existing =p= element, exactly as shown here.

Save, and reload the page in the browser.
#+END_NOTES

** An image on the page

#+BEGIN_SRC html-chrome :noweb yes :exports results :flags --window-size=640x240 --force-device-scale-factor=2
<<example-with-image>>
#+END_SRC

#+RESULTS:
[[file:an-image-on-the-page.png]]

#+BEGIN_NOTES
=img= is an inline element -- it must be wrapped (or nested) inside
a block level element.
#+END_NOTES

** Exercise: Break it

1. Mis-spell =src= as =source=
2. Leave off a double-quote ="=
3. Mis-spell the filename

#+BEGIN_NOTES
Here are more things for you to try and do to break the page. I want
you to try each one of these things, and see what happens.

For each one, break it, note what happens, then fix it and make sure
the page displays OK after you fix it. Then move on to the next one.

1. VSCode didn't tell you there was a mistake. This is because VSCode is lenient, and assumes there might be some attributes that it doesn't know about.

  The lesson here is -- just because VSCode says it's OK doesn't mean it necessarily is. You still need to check.

2. The missing quote depends on which one is missing. If it's one of the ones from the =src= attribute then the file will not be found.

  If it's one of the ones from the =alt= attribute then the page should still look like you expect, but the =alt= attribute value will not work properly.

3. If you mis-spell the filename then the image won't be found.
#+END_NOTES

** Types of images

- PNG (Portable Network Graphics), =.png=
  - Raster format
  - Lossless compression
  - Best for images with text, line-art, flat colours
- JPEG (Joint Photographic Expert Group), =.jpeg=, =.jpg=
  - Raster format
  - Lossy compression
  - Good for photos
- SVG (Scalable Vector Graphics), =.svg=
  - Vector format
  - Supports interactivity and animation

#+BEGIN_NOTES
There are typically three image formats that you will encounter on the
web.

PNG and JPEG images are both examples of raster, or bitmap images.
The files contain information that describes, for each pixel of
the image, what colour and transparency the pixel has.

Both formats are *compressed*, meaning that an image takes up a lot
less space to transmit than the underlying raw image data is.

They do this compression in different ways. PNG uses *lossless*
compression. This means that if you take an image, convert it to
PNG, and then display it again you get exactly the same pixel colours
and transparency as the original image.

This makes it useful for drawings, images with lots of flat colours,
and so on.

JPEG uses *lossy* compression. Once you have converted an image to
JPEG some of the image data has been discarded. This makes the
file significantly smaller. JPEG is designed so that the data that
is thrown away normally doesn't affect the image in ways that we
can perceive, but this works best with images that are photos or
contain a lot of other detail. For other types of images this can
result in visible *artifacts*.

Unlike the other two, SVG describes the image, with information
like "Draw a line from *here* to *there*, or place a circle here,
make it red, and the outline blue.

Because of this SVG images can be made larger without becoming
blurry. They also support interactivity (such as being able to
react to clicking on different parts of the image) and animation.

SVG is best used for logos, technical drawings, and the like.

The Powercoders logo file that we downloaded was an SVG image.
#+END_NOTES

* Element content and attribute content

#+BEGIN_SRC html
<!-- This does *not* work -->

<img>
  <src>name-of-file.png</src>
  <alt>Image of ...</alt>
</img>
#+END_SRC

#+BEGIN_NOTES
You might be wondering why images are empty elements with attributes?
Couldn't they be a nested element, with other elements to specify the
image file and the alternative content?

That's a great question. The answer is that, generally, element content
represents something that the user will immediately see on the page, while
attributes are used to specify how that content should be displayed, or
other information that would normally be hidden.

This is not a hard and fast rule. When HTML was first being developed
rules like this didn't really exist, and so the language is not completely
consistent about how these things are treated. It's just something you
have to get used to.

By the way, that weird element at the top with an exclamation mark and
the minus signs. That's what a comment looks like in HTML. We'll talk
more about that later.
#+END_NOTES

* Different elements have different attributes

#+BEGIN_SRC html
<!-- This does *not* work -->

<p src="name-of-file.png">...</p>
#+END_SRC

#+BEGIN_NOTES
The HTML specification says which attributes are allowed for each
element, you can't just write an attribute on an element and hope it
will work.

So this example here does not work.

We'll be seeing many more attributes as we go through the course.
#+END_NOTES

* Heading levels

#+REVEAL_HTML: <div class="leftcol">
#+NAME: html-headings
#+BEGIN_SRC html-chrome :flags --window-size=300,300 --force-device-scale-factor=2
  <h1>Level 1 heading</h1>

  <h2>Level 2 heading</h2>

  <h3>Level 3 heading</h3>

  <h4>Level 4 heading</h4>

  <h5>Level 5 heading</h5>

  <h6>Level 6 heading</h6>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS: html-headings
[[file:html-headings.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
You may have guessed that the =h1= element was just one of many
different heading elemnts.

If so, you're right. There are six of them. =h1= is the largest
to =h6= which is the smallest.

Copy these in to your =scratch= file (don't delete the existing
content, just add these to the body) to make sure it works for
you.
#+END_NOTES

* Unordered lists

#+NAME: html-ul
#+BEGIN_SRC html
  <p>The unordered list uses bullet points.</p>

  <ul>
    <li>This is a list item.</li>

    <li>So is this.
      <ul>
	<li>Lists can be nested inside each other.</li>

	<li>And have more list items.</li>
      </ul>
    </li>
  </ul>
#+END_SRC

#+BEGIN_NOTES
HTML supports writing lists of things. One way is as an *unordered list* using the =ul= element. The list itself consists of zero or more *list items* using the =li= element.

Each list item in an unordered list is normally shown with a bullet point next to it.

Copy these in to your =scratch= file (don't delete the existing
content, just add these to the body) to make sure it works for
you.
#+END_NOTES

** TODO Unordered lists

 #+REVEAL_HTML: <div class="leftcol">
 #+NAME: html-ul-results
 #+BEGIN_SRC html-chrome :noweb yes
 <<html-ul>>
 #+END_SRC
 #+REVEAL_HTML: </div>

 #+REVEAL_HTML: <div class="rightcol">
 #+RESULTS: html-ul-results
 [[file:html-ul-results.png]]
 #+REVEAL_HTML: </div>

* TODO Ordered lists

#+NAME: html-ol
#+BEGIN_SRC html
  <p>The ordered list uses numbers.</p>

  <ol>
    <li>This is a list item.</li>

    <li>So is this.
      <ol>
	<li>Lists can be nested inside each other.</li>

	<li>And have more list items.</li>
      </ol>
    </li>
  </ol>
#+END_SRC

#+begin_notes
An *ordered list* is very similar, except that instead of using bullet points each entry in the list is normally numbered in some way.

Like the ordered list, each list item is created using an =li= element. However, the container element is =ol= (ordered list) instead of =ul=.
#+end_notes

** TODO Ordered lists

 #+REVEAL_HTML: <div class="leftcol">
 #+NAME: html-ol-results
 #+BEGIN_SRC html-chrome :noweb yes
 <<html-ol>>
 #+END_SRC
 #+REVEAL_HTML: </div>

 #+REVEAL_HTML: <div class="rightcol">
 #+RESULTS: html-ol-results
 [[file:html-ol-results.png]]
 #+REVEAL_HTML: </div>

#+BEGIN_NOTES
Copy these in to your =scratch= file (don't delete the existing
content, just add these to the body) to make sure it works for
you.
#+END_NOTES

* TODO =div=

- =div= element is purely structural
- Use it to group blocks of related elements
- Grouping making styling and Javascript easier later

#+BEGIN_NOTES
=div= is a special type of element. It's purely structural -- if you don't do anything to style it (more on that next week) then it doesn't change what the page looks like at all.

We use it because it gives us a way of grouping together elements that are related in some way, and where we will want to refer back to that group later (maybe because we want to change the style, or because we want to change the page using Javascript).
#+END_NOTES

** TODO =div= example

#+REVEAL_HTML: <div class="leftcol">
#+NAME: div-example
#+BEGIN_SRC html-chrome
<div id="header">
  <p>Article heading</p>

  <p>Home : Articles : Article one</p>
</div>

<div id="content">
  <p>Some content.</p>

  <p>Some more content.</p>
</div>

<div id="footer">
  <p>Author: Nik</p>
</div>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[78d23a885b7bc8e99a897809603f16b92185f324]: div-example
[[file:div-example.png]]

#+REVEAL_HTML: </div>

#+BEGIN_NOTES
In this example I've decided that my page consists of three logical
units. They are:

- A header
- The main content
- A footer

I've wrapped the content elements -- the paragraphs -- in =div=
elements to reflect that structure.

As you can see in the screenshot, right now this doesn't do anything
different to the presentation of the material, it looks exactly the
same. There's no extra whitespace, or indentation, or anything like
that.

This will, however, become more important in a couple of days when
we introduce stylesheets to all of this.

That's why you need to know about =div= now.

You see those =id= attributes? Those are also new. Again, there's more
on them later, but for now it's enough to know that, within each page
the value of each =id= must be unique, and we use them to be able to refer back to
specific =div= elements in stylesheets and other places.

Add these in to your =scratch= file (don't delete the existing
content, just add these to the body) to make sure it works for
you.
#+END_NOTES

* TODO =span=

- =span= is also purely structural
- Like =div=, but for inline content

#+BEGIN_NOTES
The =span= element is used the same way as =div=, but instead of
using it group related block level elements together we use it
to wrap inline elements that we want to treat differently.
#+END_NOTES

** TODO =span= example

#+REVEAL_HTML: <div class="leftcol">
#+NAME: span-example
#+BEGIN_SRC html-chrome
  <div id="header">
    <p>Article heading</p>

    <p><span class="nav">Home</span> :
      <span class="nav">Articles</span> :
      Article one</p>
  </div>

  <div id="content">
    <p>Some content.</p>

    <p>Some more content.</p>
  </p>

  <div id="footer">
    <p>Author:
      <span class="author-name">Nik</span></p>
  </div>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[9f101ba20955146133ecf3c65a8f01ce7937bae5]: span-example
[[file:span-example.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
This is the same HTML as in the =div= example, only I've added
some =span= elements to it.

In the navigation section I've used it to indicate that some text
is part of the navigation in the page.

And in the footer I've used it to indicate that a bit of text is
the name of the author.

Just like with =div= this doesn't make the text look any different
at this point. We'll come to that later when we use stylesheets, but
just like =div= you need to know that this is possible.

Copy these in to your =scratch= file (don't delete the existing
content, just add these to the body) to make sure it works for
you.
#+END_NOTES

* TODO Entities

- Difficult to write some characters in HTML
- Because they have special meaning
- =<=, =>=, =&=
- Use *entities*
- =&lt;= =&gt;= =&amp;=

#+BEGIN_NOTES
Some characters are difficult to include in your HTML, because
they have special meanings.

The obvious examples are the left and right angle brackets, because
they're used for tags.

Ampersand also sometimes has problems.

To includes these in your pages we use a thing called *entities*.

To write an entity you start with an ampersand, then the entity
name, and then a semi-colon.

The names for the brackets are =lt=, =gt=, and for ampersand it's
=amp=.

We're going to need this very shortly in the exercises.
#+END_NOTES

** Entity example

#+REVEAL_HTML: <div class="leftcol">
#+NAME: html-entitites
#+BEGIN_SRC html-chrome
<p>You write a p tag like &lt;p&gt;.</p>

<p>You write an & entity like &amp;amp;.</p>
#+END_SRC
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
#+RESULTS[82991b0f0ae17ede9ccf9c6365206d8071539f4a]: html-entitites
[[file:html-entitites.png]]
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
Copy these in to your =scratch= file (don't delete the existing
content, just add these to the body) to make sure it works for
you.
#+END_NOTES

** Other entities include...

#+REVEAL_HTML: <div class="leftcol">
- \copy = =&copy;=
- \frac14 = =&frac14;=
- \frac12 = =&frac12;=
- \frac34 = =&frac34;=

#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- \leftarrow = =&leftarrow;=
- \uparrow = =&uparrow;=
- \rightarrow = =&rightarrow;=
- \downarrow = =&downarrow;=
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
There are more entities, used as handy ways for describing hard to
enter characters.
#+END_NOTES

* Structure recap

#+BEGIN_SRC html
<!DOCTYPE html>
<html>
  <head>
    <title>Title goes here</title>
  </head>

  <body>
    <!-- other elements go here -->
  </body>
</html>
#+END_SRC

#+BEGIN_NOTES
Let's just recap the basic structure of every HTML page. You're going to be doing these like this from now on.

Every page starts with the =DOCTYPE= declaration.

The first element is always =html=, which itself contains two elements, the =head= and the =body=.

You put a =title= in the =head= element, and the rest of the content goes inside the =body= element.

Sometimes, for reasons of space on the slides, I'm not going to show this boilerplate, but it's always there, and when you're creating HTML files it needs to be there too.

And don't forget the indentation!
#+END_NOTES

* HTML recap

#+REVEAL_HTML: <div class="leftcol">
- Headings, =h1= ... =h6=
- Paragraph, =p=
- Lists
  - =ol= and =li=
  - =ul= and =li=
- Images, =img=
  - =src= and =alt= attributes
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Structure
  - =div=
  - =span=
- Entities
  - =&lt;=, =&gt;=, =&amp;=
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
And here are the elements we've seen so far.

Headings use =h1= through =h6=, depending on how important the heading is.

Paragraphs are wrapped with a =p= element, while lists use either =ol= if it's an *ordered list* with numbers, or =ul= if it's an *unordered list* with bullet points.

Either way, the individual *list items* are wrapped in =li= elements.

Images are included using the =img= element, which has an attribute, =src= that references the file name of the image, and =alt=, which provides alternative text to use if the image can't be used.

=div= and =span= allows us to apply additional structure to our document, and you can use these three entities to include special characters in the page.
#+END_NOTES

* Mozilla Developer Network

- Mozilla Developer Network (MDN)
- https://developer.mozilla.org/en-US/docs/Web/HTML/Element

#+BEGIN_NOTES
Mozilla is the organization responsible for, amongst other things, the Firefox web browser, and the provide a very comprehensive set of reference documents and tutorials online.
#+END_NOTES

** MDN Exercise, =p=

- Open https://developer.mozilla.org/en-US/docs/Web/HTML/Element
- Find an open the page for the =p= element
- Read the content
  - You can skip *Styling paragraphs*
  - That's for next week!

#+begin_notes
As a programmer you'll need to get used to reading and understanding technical documentation. So we're going to start doing that.

Open the MDN page for HTML elements. You'll see it contains a long list of the different types of elements (there are many more than the ones we've looked at so far).

Go down this list until you find the entry for the =p= element. You'll see that it contains a link to another page with more information, click the link to go that page.

You should be looking at a page with the title "<p>: The Paragraph Element". This is pretty typical of the MDN reference documentation for different elements.

The first one or two paragraphs of the page are normally are short description of the element. You should read this -- if there are any terms there that you don't understand then look them up. If you still don't understand them after that then post a question to the Slack channel for the course.

There's normally a demo section after that, with two sections. One section contains some HTML, the other section shows you what the result looks like.

This is great for quick experiments if you're trying to understand a new element. Try changing the text in the *HTML* section on the page and see how the *Output* section changes.

Below that is normally a table that shows you *where* in the document you can put the element. This is more precise and formal than we've been using so far.

There will be a section that shows you the *attributes* that you can use with the element. For the =p= element there are no element-specific attributes you can use, only the *global* attributes that can be used for all elements. We haven't looked at that in any detail yet, although we have used one global attribute -- =id= -- already.

There's another section that talks about how to *style* the element. You can skip over that at the moment as we haven't covered that topic yet.
#+end_notes

** MDN Exercise, =img=

- Open https://developer.mozilla.org/en-US/docs/Web/HTML/Element
- Find an open the page for the =img= element
- Read the content

#+begin_notes
Do the same thing, but review what MDN has to say about the =img= element.
#+end_notes

** MDN Exercise, =ol=

- Open https://developer.mozilla.org/en-US/docs/Web/HTML/Element
- Find an open the page for the =ol= element
- Read the content

#+begin_notes
In an ordered list each list item is normally numbered, starting from the number 1.

Read the content of this page, and find out how to:

1. Start a list from number *4*, instead of number *1*
2. Have the list use letters (i.e., *A*, *B*, *C*, etc) instead of numbers

Add an example to your scratch file.
#+end_notes

** MDN Exercise, =dl=

- Open https://developer.mozilla.org/en-US/docs/Web/HTML/Element
- Find an open the page for the =img= element
- Read the content

** MDN Exercise, other elements

- Open https://developer.mozilla.org/en-US/docs/Web/HTML/Element
- Review content for
  - =dl=
  - =blockquote=
  - =hr=
  - =pre=

#+begin_notes
Here's an element we haven't looked at yet, =dl=, a *description list*. It's another type of list (like =ol= and =ul= that we've already seen).

Find the page for =dl= in the MDN reference and read through it carefully.

Then try adding a description list to your =scratch= file to make sure that you have understood how it works.

Do the same for other elements, like =blockquote=, =hr=, and =pre=.
#+end_notes

* Exercise: Cheatsheet                                             :exercise:

- Create a =cheatsheet= directory in the =poco= directory
- Create =poco/cheatsheet/html.html=
- Add notes about what you've learned
- Structure, not style
- Remember, =&lt;=, =&gt;=, and =&amp;=
- Look up other entities

#+BEGIN_NOTES
Start creating a cheatsheet for yourself. This will be a document
that contains any information you want to remember or refer back to.

This should be an HTML file. Note down the elements and other things
that you've learned so far, in as much detail as you can.

All through today you've been copying stuff in to your =scratch= file,
so use that as a reference for the things you want to put in your
cheatsheet.
#+END_NOTES

* Exercise: Recipes

#+REVEAL_HTML: <div class="leftcol">
- Create a =recipes= directory in the =poco= directory
- Create HTML files for 3 recipes, in the =recipes= directory
- Focus on the HTML structure and elements
- Add at least one image to each
- *DO NOT* use CSS or other formatting
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="rightcol">
- Recipe has a:
  - Description
  - Details
    - # servings
    - cooking time
    - notes (allergy, special ingredients, etc)
  - List of ingredients
  - Instructions
#+REVEAL_HTML: </div>

#+BEGIN_NOTES
This is a chance to put together the elements we've already seen. You can use regular paragraphs, headings, and lists.

Different sections of the recipe should be wrapped in =div= elements, and you can use =span= to indicate special things in the text.

Some of what you're writing will be lists of things, so think about what the best type of list element is to use.
#+END_NOTES

** Portfolio                                                  :noexport:

- Implement your CV / portfolio in HTML
- Include a photo of yourself

#+begin_notes
Note to self: Not using this exercise at the moment, it causes too much confusion with the CV work that the students do on Wednesdays.
#+end_notes
